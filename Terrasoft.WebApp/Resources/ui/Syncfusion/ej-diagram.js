/*!
*  filename: ej.diagram.js
*  version : 12.4.0.24
*  Copyright Syncfusion Inc. 2001 - 2014. All rights reserved.
*  Use of this code is subject to the terms of our license.
*  A copy of the current license can be obtained at any time by e-mailing
*  licensing@syncfusion.com. Any infringement will be prosecuted under
*  applicable laws. 
*/
(function (fn) {
    //typeof define === 'function' && define.amd ? define(["./../common/ej.core","./../common/ej.data","./../common/ej.touch","./../common/ej.draggable","./../common/ej.scrollbar","./../common/ej.scroller","./../common/ej.unobtrusive","./../web/ej.menu"], fn) : fn();
	typeof define === 'function' && define.amd ? define(fn) : fn();
})
(function () {
	
/**
* @fileOverview Plugin to style the Html Button elements
* @copyright Copyright Syncfusion Inc. 2001 - 2013. All rights reserved.
* Use of this code is subject to the terms of our license.
* A copy of the current license can be obtained at any time by e-mailing
* licensing@syncfusion.com. Any infringement will be prosecuted under
* applicable laws. 
* @version 12.1 
* @author <a href="mailto:licensing@syncfusion.com">Syncfusion Inc</a>
*/
(function ($, ej, undefined) {
    /**
    * @namespace ej
    * @class ejDiagram
    * @requires jquery.js
    * @requires jquery.easing.min.js
    * @requires jsrender.min.js
    * @requires ej.core.js
    * @requires ej.draggable.js
    * @requires ej.scrollbar.js
    * @requires ej.touch.js
    * @requires ej.diagram.js
    * @requires ej.diagramcommon.js
    * @requires ej.diagraminteraction.js
    * @requires ej.diagramsvg.js
    * @requires ej.diagramtools.js
    * @requires ej.diagramlayout.js
    * @requires ej.matrix.js
    * @classdesc The diagram control provides 2D surface to visualize the data as shapes, lines, text and images. It can be configured to DOM element such as DIV.
    * @example 
    * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * //Create Diagram
    $("#diagram").ejDiagram();
    * &lt;/script&gt
    */

    "use strict";
    //#region ej.Diagram widget
    ej.widget("ejDiagram", "ej.datavisualization.Diagram", {
        // widget element will be automatically set in this
        element: null,

        // user defined model will be automatically set in this
        model: null,
        validTags: ["div"],

        //#region defaults
        defaults: {
            /**Specifies the width of the diagram. 
            * @default null
            * @type {string}
            * @example
            * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
            * &lt;script&gt;
            * $("#diagram").ejDiagram({ width:"100%" });
            * &lt;/script&gt
              * @memberof ejDiagram
              * @instance
            */
            width: null,
            /**Specifies the height of the diagram.
            * @default null
            * @type {string}
            * @example
            * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
            * &lt;script&gt;
            * $("#diagram").ejDiagram({ height:"100%" });
            * &lt;/script&gt
              * @memberof ejDiagram
              * @instance
            */
            height: null,
            /**Array of node objects where each object has definition/properties of node.
            * @default []
            * @type {array}
            * @example
            * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
            * &lt;script&gt;
            * var nodes = [{ name: "node", width: 175, height: 60}];
            * $("#diagram").ejDiagram({ nodes:nodes });
            * &lt;/script&gt
              * @memberof ejDiagram
              * @instance
            */
            nodes: [],
            /**Array of connector objects where each object has definition/properties of connector.
            * @default []
            * @type {array}
            * @example
            * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
            * &lt;script&gt;
            * var connectors = [{ name: "connector" sourceNode: "node1", targetNode: "node2"}];
            * $("#diagram").ejDiagram({ connectors:connectors });
            * &lt;/script&gt
              * @memberof ejDiagram
              * @instance
            */
            connectors: [],

            /** To set the default properties for nodes and connectors.
        * @default {}
        * @type {object}
        * @example
        * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * $("#diagram").ejDiagram({ defaultSettings: { node:  {width: 110, height: 40, fillColor:"skyblue"}}});
        * &lt;/script&gt
        * @memberof ejDiagram
        * @instance
       */
            defaultSettings: {
                /** To set the default properties of connector.
                * @default null
                * @type {object}
                * @example
                * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
                * &lt;script&gt;
                * $("#diagram").ejDiagram({ defaultSettings:{ connector:{ lineColor: "gray", lineWidth: 2 }}});
                * &lt;/script&gt
                 * @alias  ejDiagram#defaultSettings->connector
                  * @memberof ejDiagram
                  * @instance
                */
                connector: null,
                /**To set the default properties of node.
                * @default null
                * @type {object}
                * @example
                * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
                * &lt;script&gt;
                * $("#diagram").ejDiagram({ defaultSettings:{node: { fillColor: "#83A93F", borderColor: "#000000" }}});
                * &lt;/script&gt
                * @alias  ejDiagram#defaultSettings->node
                  * @memberof ejDiagram
                  * @instance
                */
                node: null
            },


            /**To customize the node properties before rendering the node.
               * @default null
               * @type {object}
               * @example
               * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
               * &lt;script&gt;
               *function nodeTemplate(diagram, node) {node.labels[0].text = node.Name};
               * $("#diagram").ejDiagram({ nodeTemplate:nodeTemplate});
               * &lt;/script&gt
                 * @memberof ejDiagram
                 * @instance
               */

            nodeTemplate: null,
            /** To customize the connector properties before rendering the connector.
               * @default null
               * @type {object}
               * @example
               * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
               * &lt;script&gt;
               *function connectorTemplate(diagram, connector, data) {connector.labels[0].text = data.Name};
               * $("#diagram").ejDiagram({ connectorTemplate:connectorTemplate});
               * &lt;/script&gt
                 * @memberof ejDiagram
                 * @instance
               */
            connectorTemplate: null,
            /** Configures the datasource for diagram.
      * @default {id: "Id", parent: "ReportingPerson",dataSource: data  }
      * @type {object}
      * @example
      * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * $("#diagram").ejDiagram({ dataSourceSettings: {id: "Id", parent: "ReportingPerson",dataSource: data  }});
      * &lt;/script&gt
         * @memberof ejDiagram
        * @instance
      */
            dataSourceSettings: {
                /** Describes the datasource for diagram. 
            * @default null
            * @type {object}
            * @example
            * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
            * &lt;script&gt;
            * $("#diagram").ejDiagram({ dataSourceSettings: {dataSource: localData}});
            * &lt;/script&gt
            * @alias ejDiagram#dataSourceSettings->dataSource
            */

                dataSource: null,
                /**Describes query to retrieve data from the datasource.
        * @default null
        * @type {object}
        * @example
        * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        *query: ej.Query().from("Categories").select("CategoryID,CategoryName").take(3);
        * &lt;/script&gt
        * @alias ejDiagram#dataSourceSettings->query
        */
                query: null,
                /**Describes table name to execute query on the corresponding table.
     * @default null
     * @type {String}
     * @example
     * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
     * &lt;script&gt;
     * $("#diagram").ejDiagram({ dataSourceSettings:{tableName: "Categories"}});
     * &lt;/script&gt
     * @alias ejDiagram#dataSourceSettings->tablename
     */
                tableName: null,
                /** Describes the unique id of datasource items.
        * @default null
        * @type {String}
        * @example
        * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * $("#diagram").ejDiagram({ dataSourceSettings: {id: "CategoryID"}});
        * &lt;/script&gt
        * @alias ejDiagram#dataSourceSettings->id
        */
                id: "",

                /**Describes the parent id of datasource items.
        * @default null
        * @type {String}
        * @example
        * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * $("#diagram").ejDiagram({ dataSourceSettings: { parent: "reportingPerson"}});
        * &lt;/script&gt
        * @alias ejDiagram#dataSourceSettings->parent
        */
                parent: "",

                nodes: null,

                connectors: null,
                //nodeBinding: null,
                //connectorBinding: null,
            },
            /**Specifies the snap settings of the diagram.
            * @type {object}
               * @memberof ejDiagram
              * @instance
            */
            snapSettings: /** @lends ejDiagram# */ {
                /**Specifies the settings of horizontal grid lines.
                * @type {object}
                * @alias ejDiagram#snapSettings->horizontalGridLines
                */
                horizontalGridLines: {
                    /**Specifies the space between horizontal grid lines
                    * @default [1.25, 18.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75]
                    * @type {array}
                    * @example
                    * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
                    * &lt;script&gt;
                    * $("#diagram").ejDiagram({ snapSettings: { 
                    *     horizontalGridLines: { linesInterval: [1, 14, 0.25, 15, 0.25, 15, 0.25, 15, 0.25, 15] }
                    * }}); 
                    * &lt;/script&gt
                    * @alias ejDiagram#snapSettings->horizontalGridLines->linesInterval
                    */
                    linesInterval: [1.25, 18.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75],
                    /**Specifies the snap intervals for horizontal grid lines.
                    * @default [20]
                    * @type {array}
                    * @example 
                    * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
                    * &lt;script&gt;
                    * $("#diagram").ejDiagram({ snapSettings: { horizontalGridLines: { snapInterval: [10] }}}); 
                    * &lt;/script&gt
                   * @alias ejDiagram#snapSettings->horizontalGridLines->snapInterval
                    */
                    snapInterval: [20],
                    /**Specifies the pattern of dashes and gaps used to stroke horizontal grid lines
                    * @default "0"
                    * @type {string}
                    * @example 
                    * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
                    * &lt;/script&gt
                    * $("#diagram").ejDiagram({ snapSettings: { horizontalGridLines: { lineDashArray: "2 2"}}}); 
                    * &lt;/script&gt
                     * @alias ejDiagram#snapSettings->horizontalGridLines->lineDashArray
                    */
                    lineDashArray: "0",
                    /**		
                    * Line color for horizontal gridlines
                    * @default "lightgray"
                    * @type {string}
                    * @example 
                    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
                    * &lt;/script&gt
                    * var gridline = { "snapConstraints":"lineColor": "blue" };
                    * //Linecolor of the horizontal gridlines
                    * $("#diagramContent").ejDiagram({snapSettings: { horizontalGridLines: gridline} }); 
                    * &lt;/script&gt
                   * @alias ejDiagram#snapSettings->horizontalGridLines->lineColor
                    */
                    lineColor: "lightgray"
                },
                /**Specifies the settings of vertical grid lines.
                * @type {object}
                * @alias ejDiagram#snapSettings->verticalGridLines
                */
                verticalGridLines: {
                    /**Specifies the space between vertical grid lines
                    * @default [1.25, 18.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75]
                    * @type {array}
                    * @example
                    * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
                    * &lt;script&gt;
                    * $("#diagram").ejDiagram({ snapSettings: { 
                    *     verticalGridLines: { linesInterval: [1, 14, 0.25, 15, 0.25, 15, 0.25, 15, 0.25, 15] }
                    * }}); 
                    * &lt;/script&gt
                    * @alias ejDiagram#snapSettings->verticalGridLines->linesInterval
                    */
                    linesInterval: [1.25, 18.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75],
                    /**Specifies the snap intervals for vertical grid lines.
                    * @default [20]
                    * @type {array}
                    * @example 
                    * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
                    * &lt;script&gt;
                    * $("#diagram").ejDiagram({ snapSettings: { verticalGridLines: { snapInterval: [10] }}}); 
                    * &lt;/script&gt
                  * @alias ejDiagram#snapSettings->verticalGridLines->snapInterval
                    */
                    snapInterval: [20],
                    /**Specifies the pattern of dashes and gaps used to stroke vertical grid lines
                    * @default "0"
                    * @type {string}
                    * @example 
                    * &lt;div id="diagram"&gt;&lt;/div&gt;<br>
                    * &lt;/script&gt
                    * $("#diagram").ejDiagram({ snapSettings: { verticalGridLines: { lineDashArray: "2 2"}}}); 
                    * &lt;/script&gt
                   * @alias ejDiagram#snapSettings->verticalGridLines->lineDashArray
                    */
                    lineDashArray: "0",
                    /**		
               * Line Color of vertical grid lines
               * @default "lightgray"
               * @type {string}
               * @example 
               * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
               * &lt;/script&gt
               * var gridline = { "snapConstraints":"lineColor": "blue" };
               * //Linecolor of the vertical gridlines
               * $("#diagramContent").ejDiagram({snapSettings: { verticalGridLines: gridline} });
               * &lt;/script&gt
              * @alias ejDiagram#snapSettings->verticalGridLines->lineColor
               */
                    lineColor: "lightgray"
                },
                /**		
           * Enables or disables the snapconstraints of gridlines see{@link snapConstraints}
           * @name SnapConstraints
           * @default SnapConstraints.ShowLines 
           * @type {enum}
           * @example 
           * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
           * &lt;/script&gt
           * var gridline = { "snapConstraints": ej.datavisualization.Diagram.SnapConstraints.ShowLines};
           * //snap constraints of gridlines
           * $("#diagramContent").ejDiagram({snapSettings: gridline} });
           * &lt;/script&gt
           * @alias ejDiagram#snapSettings->snapConstraints
           */
                snapConstraints: 1 | 2 | 4 | 8,
                /**		
            * Enables or disables the snap object 
            * @default true
            * @type {Boolean}
            * @example 
            *var snap = {"enableSnapToObject":true};
            * //enableSnapToObject: 
            * $("#diagramContent").ejDiagram({snapSettings: snap}); 
            * @alias ejDiagram#snapSettings->enableSnapToObject
            */
                enableSnapToObject: true,
                /**		
         * The Angle to which the object to be snapped
         * @default 5
         * @type {Number}
         * @example 
         *var snap = {"snapAngle":5};
         * //enableSnapToObject: 
         *$("#diagramContent").ejDiagram({snapSettings: snap}); 
         * @alias ejDiagram#snapSettings->snapAngle
         */
                snapAngle: 5,
                /**		
            * Relative distance between the nearer object and selected object
            * @default 5
            * @type {Number}
            * @example 
            *var snap = {"snapObjectDistance":5};
            * //snapObjectDistance
            *$("#diagramContent").ejDiagram({snapSettings: snap}); 
            * @alias ejDiagram#snapSettings->snapObjectDistance
            */
                snapObjectDistance: 5
            },
            /**		
            * The pageSetting of the diagram
               * @memberof ejDiagram
              * @instance*/
            pageSettings: /** @lends ejDiagram# */ {
                /**		
         * This is used to set the width of the page 
         * @default null
         * @type {Number}
         * @example 
         * //pageWidth
         *$("#diagramContent").ejDiagram({pageSettings: {pageWidth: 4500}}); 
         * @alias ejDiagram#pageSettings->pageWidth
         */
                pageWidth: null,
                /**		
         * This is used to set the height of the page 
         * @default null
         * @type {Number}
         * @example 
         * //pageHeight of the diagram
         *$("#diagramContent").ejDiagram({pageSettings: {pageHeight: 4500}}); 
         * @alias ejDiagram#pageSettings->pageHeight
         */
                pageHeight: null,
                /**		
         * Enables or disables the multiple page
         * @default false
         * @type {Boolean}
         * @example 
         * //multiplePage of the diagram
         *$("#diagramContent").ejDiagram({pageSettings: {multiplePage: false}}); 
         * @alias ejDiagram#pageSettings->multiplePage
         */
                multiplePage: false,
                /**		
         *This is used to set the width of the page border 
         * @default 0
         * @type {Number}
         * @example 
         * //pageBorderWidth of the diagram
         *$("#diagramContent").ejDiagram({pageSettings: {pageBorderWidth: 3}}); 
         * @alias ejDiagram#pageSettings->pageBorderWidth
         */

                pageBorderWidth: 0,
                /**		
          * Used set the background color of the page 
          * @default "#ffffff"
          * @type {String}
          * @example 
          * //pageBackgroundColor of the diagram
          * $("#diagramContent").ejDiagram({pageSettings: {pageBackgroundColor: "#ffffff"}}); 
          * @alias ejDiagram#pageSettings->pageBackgroundColor
          */
                pageBackgroundColor: "#ffffff",
                /**		
         * Used to set the border color of the page
         * @default "#565656"
         * @type {String}
         * @example 
         * //pageBorderColor of the diagram
         *$("#diagramContent").ejDiagram({pageSettings: {pageBorderColor: "#565656"}}); 
         * @alias ejDiagram#pageSettings->pageBorderColor
         */
                pageBorderColor: "#565656",
                /**		
         * Margin of the page
         * @default 24
         * @type {Number}
         * @example 
         * //pageMargin of the diagram
         *$("#diagramContent").ejDiagram({pageSettings: {pageMargin: 24}}); 
         * @alias ejDiagram#pageSettings->pageMargin
         */
                pageMargin: 24,
                /**		
         * Enables or disables the page breaks in diagram
         * @default false
         * @type {Boolean}
         * @example 
         * //showPageBreak of the diagram
         *$("#diagramContent").ejDiagram({pageSettings: {showPageBreak: false}}); 
         * @alias ejDiagram#pageSettings->showPageBreak
         */
                showPageBreak: false,
                /**		
          * Orientation allows placement of element on a page that set through page set up see{@link PageOrientations}
          * @name pageOrientation
          * @default "portrait"
          * @type {enum}
          * @example 
          * //pageOrientation of the diagram
          *$("#diagramContent").ejDiagram({pageSettings: {pageOrientation: "portrait"}}); 
          * @alias ejDiagram#pageSettings->pageOrientation
          */
                pageOrientation: "portrait",

                /**		
      * scrollLimit used to set the scroll limit on the diagram that set through page set up see{@link ScrollLimit}
      * @name scrollLimit
      * @default "infinity"
      * @type {enum}
      * @example 
      * //scrollLimit of the diagram
      *$("#diagramContent").ejDiagram({pageSettings: {scrollLimit: "infinity"}}); 
      * @alias ejDiagram#pageSettings->scrollLimit
      */
                scrollLimit: "infinity",

                /**		
     * scrollableArea used to set the scroll area on the diagram.
     * @name scrollableArea
     * @default {scrollableArea: { x: Infinity, y: Infinity, width: Infinity, height: Infinity }}
     * @type {object}
     * @example 
     * //scrollableArea of the diagram
     *$("#diagramContent").ejDiagram({pageSettings: {scrollableArea: { x: 0, y: 0, width: 0, height: 0 }}}); 
     * @alias ejDiagram#pageSettings->scrollableArea
     */
                scrollableArea: { x: Infinity, y: Infinity, width: Infinity, height: Infinity },

                /**
     * Specifics the auto scroll starting point of diagram control.
     * @name autoScrollBorder
     * @default { autoScrollBorder: { left: 15, top: 15, right: 15, bottom: 15 }}
     * @type {object}
     * @example
     * //scrollableArea of the diagram
     *$("#diagramContent").ejDiagram({pageSettings: {autoScrollBorder: { left: 15, top: 15, right: 15, bottom: 15 }}}); 
     * @alias ejDiagram#pageSettings->autoScrollBorder
     */
                autoScrollBorder: { left: 15, top: 15, right: 15, bottom: 15 },
            },

            locale: "en-US",
            /**		
           *The contextmenu of the diagram
              * @memberof ejDiagram
              * @instance*/
            contextMenu: {
                /**		
      * Collection of items of Contextmenu
      * @default []
      * @type {Object}                          
      * @example 
	  * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * //Collection of  items
      *var menucollection = [{ "name": "hyperLink", "text": "Hyperlink", "image": "", "style": "" }];
	  *var contextMenu = { items: menucollection};
      *$("#diagramContent").ejDiagram({contextMenu: contextMenu}); 
      * &lt;/script&gt
      * @alias ejDiagram#contextMenu->items
       * @memberof ejDiagram
         * @instance
        */
                items: [],
                /**To display or hide items of contextmenu
                          * @default true
                          * @type {Boolean}
                          * @example
                          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
                          * &lt;script&gt;
                          * $("#diagramcontent").ejDiagram({showCustomMenuItemsOnly: true});
                          * &lt;/script&gt
						    * @alias ejDiagram#contextMenu->showCustomMenuItemsOnly
                             * @memberof ejDiagram
                             * @instance
                          */

                showCustomMenuItemsOnly: false
            },
            enableContextMenu: true,
            /** Enables or disables Auto scroll in diagram
           * @default true
           * @type {Boolean}
           * @example
           * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
           * &lt;script&gt;
           * $("#diagramcontent").ejDiagram({enableAutoScroll: true});
           * &lt;/script&gt
              * @memberof ejDiagram
              * @instance
           */
            enableAutoScroll: true,
            /** Enables or disables tooltip of diagram
         * @default true
         * @type {Boolean}
         * @example
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         * &lt;script&gt;
         * $("#diagramcontent").ejDiagram({showTooltip: true});
         * &lt;/script&gt
            * @memberof ejDiagram
              * @instance
         */
            showTooltip: true,
            /** To set custom style for tool tip of diagram
         * @default ""
         * @type {String}
         * @example
         * &lt;script type="text/x-jsrender" id="toolTipId"&gt;
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         *&lt;span &gt;{{:offsetX}}{{:x}}{{:offsetY}}{{:y}}
         * &lt;/script&gt
         *&lt;/span&gt;
         * &lt;script&gt;
         * $("#diagramcontent").ejDiagram({ tooltipTemplateId: "toolTipId"});
         * &lt;/script&gt
            * @memberof ejDiagram
              * @instance
         */
            tooltipTemplateId: "",
            /** To arrange elements on the page in diagram
               * @memberof ejDiagram
              * @instance*/
            layout: /** @lends ejDiagram# */{
                /**		
          * Type of the layout on the page
          * @default "none"
          * @type {String}
          * @example 
          * //type of the layout
          * $("#diagramContent").ejDiagram({layout: {type: "none"}}); 
          * @alias ejDiagram#layout->type
          */
                type: "none",
                /**		
          * Alignment of elements based on some specific direction see {@link LayoutOrientations}
          * @default "topToBottom"
          * @type {String}
          * @example 
          * //orientation of the layout
          *$("#diagramContent").ejDiagram({layout: {orientation: "topToBottom"}}); 
          * @alias ejDiagram#layout->orientation
          */
                orientation: "toptobottom",
                /**		
          * Horizontal Spacing between the nodes in layout
          * @default 30
          * @type {Number}
          * @example 
          * //horizontalSpacing of the layout
          *$("#diagramContent").ejDiagram({layout: {horizontalSpacing: 30}}); 
          * @alias ejDiagram#layout->horizontalSpacing
          */
                horizontalSpacing: 30,
                /**		
          * Vertical Spacing between the nodes in layout
          * @default 30
          * @type {Number}
          * @example 
          * //verticalSpacing of the layout
          *$("#diagramContent").ejDiagram({layout: {verticalSpacing: 30}}); 
          * @alias ejDiagram#layout->verticalSpacing
          */
                verticalSpacing: 30,
                /**		
         * Margin value along X -Axis 
         * @default 0
         * @type {Number}
         * @example 
         * //marginX of the layout
         *$("#diagramContent").ejDiagram({layout: {marginX: 0}}); 
         * @alias ejDiagram#layout->marginX
         */
                marginX: 0,
                /**		
          * Margin value along y -Axis
          * @default 0
          * @type {Number}
          * @example 
          * // marginY of the layout
          *$("#diagramContent").ejDiagram({layout: { marginY: 0}}); 
          * @alias ejDiagram#layout-> marginY
          */
                marginY: 0,
                /**	 Nodes position is set as fixed and draw all node based on the fixed node
             * @default ""
             * @type {String}
             * @example 
             * //fixedNode of the layout
             *$("#diagramContent").ejDiagram({layout: { fixedNode: "nodename"}}); 
             * @alias ejDiagram#layout-> fixedNode
             */
                fixedNode: "",
            },
            /** Enables to choose which interactive feature to be performed
         * @default ""
         * @type {Object}
         * @example
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         * &lt;script&gt;
         * $("#diagramcontent").ejDiagram({ drawingTools: {textTool: ej.datavisualization.Diagram.TextTool()}});
         * &lt;/script&gt
            * @memberof ejDiagram
              * @instance
         */
            drawingTools: {},
            /** Image to be used as an background of the elements
         * @default null
         * @type {String}
         * @example
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         * &lt;script&gt;
         * $("#diagramcontent").ejDiagram({ backgroundImage: "Syncfusion.png"});
         * &lt;/script&gt
            * @memberof ejDiagram
              * @instance
         */
            backgroundImage: null,
            /** color to be used as an background of the elements
     * @default null
     * @type {String}
     * @example
     * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
     * &lt;script&gt;
     * $("#diagramcontent").ejDiagram({ backgroundColor: "red"});
     * &lt;/script&gt
        * @memberof ejDiagram
          * @instance
     */
            backgroundColor: "transparent",

            /** Sets the bridge direction of connectors
       * @default "top" 
       * @type {String}
       * @example 
       * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
       * &lt;script&gt;
       *$("#diagramContent").ejDiagram({bridgeDirection: "top"} }); 
       * &lt;/script&gt
          * @memberof ejDiagram
       * @instance
       */
            bridgeDirection: "top",

            /** Sets the default behaviour of the diagram see{@link DiagramConstraints}
           * @default constraints.All 
           * @type {enum}
           * @example 
           * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
           * &lt;script&gt;
           *$("#diagramContent").ejDiagram({constraints: ej.datavisualization.Diagram.DiagramConstraints.Default} }); 
           * &lt;/script&gt
              * @memberof ejDiagram
           * @instance
           */

            constraints: 1 << 1 | 1 << 3 | 1 << 4 | 1 << 5 | 1 << 6,

            /** Sets the default behaviour of the diagram see{@link Tool}
       * @default Tool.All 
       * @type {enum}
       * @example 
       * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
       * &lt;script&gt;
       *$("#diagramContent").ejDiagram({tool: ej.datavisualization.Diagram.Tool.Default} }); 
       * &lt;/script&gt
          * @memberof ejDiagram
       * @instance
       */


            tool: 1 << 1 | 1 << 2,
            /**		
   * Type of the Connector to be drawn through drawing tool see {@link ConnectorType}
   * @default 1
   * @type {String}
   * @example 
   * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
   * &lt;script&gt;
    *$("#diagramContent").ejDiagram({connectorType: ej.datavisualization.Diagram.ConnectorType.straightLine} }); 
   * &lt;/script&gt
   * @memberof ejDiagram
         * @instance
   */

            connectorType: "orthogonalLine",

            /*The selectedItems of the diagram
              * @memberof ejDiagram
              * @instance*/
            selectedItems: {
                /**		
             * Align selected items position along X-axis
             * @default 0
             * @type {Number}
             * @example 
             *$("#diagramContent").ejDiagram({selectedItems: {offsetX: 50}}); 
             * @alias ejDiagram#selectedItems->offsetX
                */
                offsetX: 0,
                /**		
             * Align selected items position along Y-axis
             * @default 0
             * @type {Number}
             * @example 
             *$("#diagramContent").ejDiagram({selectedItems: {offsetY: 50}}); 
             * @alias ejDiagram#selectedItems->offsetY
                */
                offsetY: 0,
                /**		
             * set the width of the selected items.
             * @default 0
             * @type {Number}
             * @example 
             *$("#diagramContent").ejDiagram({selectedItems: {width: 50}}); 
             * @alias ejDiagram#selectedItems->width
                */
                width: 0,
                /**		
             * set the height of the selected items.
             * @default 0
             * @type {Number}
             * @example 
             *$("#diagramContent").ejDiagram({selectedItems: {height: 50}}); 
             * @alias ejDiagram#selectedItems->height
                */
                height: 0,
                /**		
             * set the rotation angle of the selected items.
             * @default 0
             * @type {Number}
             * @example 
             *$("#diagramContent").ejDiagram({selectedItems: {rotateAngle: 50}}); 
             * @alias ejDiagram#selectedItems->offsetX
                */
                rotateAngle: 0,

                children: [],

                /**		
              * Enables or disables the selector constraints see{@link SelectorConstraints}
              * @default SelectorConstraints.All 
              * @type {enum}
              * @example 
              * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
              * &lt;script&gt;
              *$("#diagramContent").ejDiagram({selectedItems:{constraints: ej.datavisualization.Diagram.SelectorConstraints.None} }}); 
              * &lt;/script&gt
                 * @memberof ejDiagram
              * @instance
              */
                constraints: 1 << 1 | 1 << 2 | 1 << 3,

                /** To add frequently using commands around selector
         * @default ""
         * @type {string}
         * @example
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         * &lt;script&gt;
         * var userHandle= [];
         * function createUserHandles() {
         * var cloneHandle = ej.datavisualization.Diagram.UserHandle();
         * userhandle.push(cloneHandles);
         * }
         * $("#diagramcontent").ejDiagram({selectedItems:{userHandles:userHandle}});
         * &lt;/script&gt
            * @memberof ejDiagram
              * @instance
         */
                userHandles: [],
            },


            /**		
        * Allow to set the factor by which we can zoom in or zoom out
        * @default 1
        * @type {Number}
        * @example 
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        *$("#diagramContent").ejDiagram({zoomFactor: 1}); 
        * &lt;/script&gt
        * @memberof ejDiagram
              * @instance
        */
            zoomFactor: 0.2,
            /**
        *Triggers When node collection get change
        * @event
        * @name ejDiagram#nodeCollectionChange
        * @param {Object} argument args parameter from diagram              
        * @param {String} argument.changetype return should be insert or remove
        * @param {Object} argument.element parameter returns node which to be added or deleted
        * @example
        * // nodeCollectionChange event for diagram
        * $("#diagramcontent").ejDiagram({
        * nodeCollectionChange:function (args)  {}
        *  });
        */
            nodeCollectionChange: null,
            /**
       *Triggers When auto scroll get change
       * @event
       * @name ejDiagram#autoScrollChange             
       * @param {String} argument.delay return should be insert or remove
       * @param {Object} argument.distanceFromDiagram parameter returns node which to be added or deleted
       * @example
       * // nodeCollectionChange event for diagram
       * $("#diagramcontent").ejDiagram({
       * autoScrollChange:function (args)  {}
       *  });
       */
            autoScrollChange: null,
            /**
        *Triggers the selected object changed in the diagram model
        * @event
        * @name ejDiagram#itemClick
        * @param {object} argument args.cancel  if the event should be cancelled ,otherwise fasle             
        * @param {String} argument.type return event name
        * @param {Object} argument.actualObject node was clicked
        * @param {Object} argument.selectedObject actual selected object
        * @param {Object} argument.model contains holds the reference of diagram
        
        * @example
        * // connectorCollectionChange event for diagram
        * $("#diagramcontent").ejDiagram({
        * connectorCollectionChange:function (args) {}
        });
        */
            itemClick: null,
            /**
        *Triggers When connector collection get change
        * @event
        * @name ejDiagram#connectorCollectionChange
        * @param {Object} argument args parameter from diagram              
        * @param {String} argument.changetype return should be insert or remove
        * @param {Object} argument.element parameter returns connector which to be added or deleted
        * @example
        * // connectorCollectionChange event for diagram
        * $("#diagramcontent").ejDiagram({
        * connectorCollectionChange:function (args) {}
        });
        */
            connectorCollectionChange: null,
            /**
        *Triggers When selection get change
        * @event
        * @name ejDiagram#selectionChanged
        * @param {Object} argument args parameter from diagram 
        * @param {String} argument.changetype return should be inserted or removed
        * @param {Object} argument.element parameter returns node or connector which to be added or deleted
        * @example
        * //  selectionChange event for diagram
        * $("#diagramcontent").ejDiagram({
        * selectionChange:function (args)  {}
        });
        */
            selectionChange: null,
            /**
        *Triggers When mouse leaves node/connector
        * @event
        * @name ejDiagram#mouseLeave
        * @param {Object} argument args parameter from diagram 
        * @param {Object} argument.element parameter returns node or connector 
            * @param {Object} argument.source the object dragged from this container 
            * @param {Object} argument.target the object is going to be dropped.  
            * @example
            * //  mouseLeave event for diagram
            * $("#diagramcontent").ejDiagram({
            * mouseLeave:function (args)  {}
               });
            */
            mouseLeave: null,
            /**
        *Triggers When mouse enter node/connector
        * @event
        * @name ejDiagram#mouseEnter
        * @param {Object} argument args parameter from diagram 
        * @param {Object} argument.element parameter returns node or connector 
        * @param {Object} argument.source the object dragged from this container 
        * @param {Object} argument.target the object is going to be dropped.  
        * @example
        * //  mouseEnter event for diagram
        * $("#diagramcontent").ejDiagram({
        * mouseEnter:function (args)  {}
        });
        */
            mouseEnter: null,
            /**
        *Triggers When mouse Hover on node/connector
        * @event
        * @name ejDiagram#mouseOver
        * @param {Object} argument args parameter from diagram 
        * @param {Object} argument.diagram parameter returns node or connector 
        * @param {Object} argument.source the object dragged from this container 
        * @param {Object} argument.target the object is going to be dropped.  
        * @example
        * //  mouseOver event for diagram
        * $("#diagramcontent").ejDiagram({
        * mouseOver:function (args)  {}
        });   
        */
            mouseOver: null,
            /**
        *Triggers When click node/connector
        * @event
        * @name ejDiagram#click
        * @param {Object} argument args parameter from diagram 
        * @param {Object} argument.element parameter returns diagram
        * @example
        * //  click event for diagram
        * $("#diagramcontent").ejDiagram({
        * click:function (args)  {}
        });
        */
            click: null,
            /**
        *Triggers When doubleClick node/connector
        * @event
        * @name ejDiagram#doubleClick
        * @param {Object} argument args parameter from diagram 
        * @param {Boolean} argument.cancel if the event should be cancelled ,otherwise fasle
        * @param {Object} argument.element parameter returns selected object in list
        * @example
        * //  doubleClick event for diagram
        * $("#diagramcontent").ejDiagram({
        * doubleClick:function (args)  {}
        });
        */
            doubleClick: null,
            /**
        *Triggers When drag and drop symbols from palette to drawing area 
        * @event
        * @name ejDiagram#drop
        * @param {Object} argument args parameter from diagram 
        * @param {Object} argument.element parameter returns node or connector
        * @example
        * //  drop event for diagram
        * $("#diagramcontent").ejDiagram({
        * drop:function (args)  {}
        });
        */
            drop: null,
            /**
  *Triggers When drag and drop symbols from palette to drawing area 
  * @event
  * @name ejDiagram#drag
  * @param {Object} argument args parameter from diagram 
  * @param {Object} argument.element parameter returns node or connector
  * @example
  * //  deag event for diagram
  * $("#diagramcontent").ejDiagram({
  * drag:function (args)  {}
  });
  */
            drag: null,
            /**
        *Triggers When label edit gets ended 
        * @event
        * @name ejDiagram#textchanged
        * @param {Object} argument args parameter from diagram 
        * @param {Object} argument.element parameter returns shape
        * @param {String} argument.value parameter returns value in label edit box
        * @example
        * // textChanged event for diagram
        * $("#diagramcontent").ejDiagram({
        * textChanged:function (args)  {}
        });
        */
            textChange: null,
            /**
        *Triggers When node size has been change
        * @event
        * @name ejDiagram#nodeSizeChange
        * @param {Object} argument args parameter from diagram 
        * @param {Object} argument.element parameter returns node that was resized
        * @param {Number} argument.offset parameter returns size of the node
        * @param {Boolean} argument.cancel if the event should be cancelled ,otherwise fasle
        * @example
        * // sizeChange event for diagram
        * $("#diagramcontent").ejDiagram({
        * sizeChange:function (args)  {}
         });
        */
            sizeChange: null,
            /**
        *Triggers When connection changes has been done
        * @event
        * @name ejDiagram#connectionChange
        * @param {Object} argument args parameter from diagram 
        * @param {Object} argument.element parameter returns connector
        * @param {String} argument.connection parameter returns source or target node that was connected
        * @param {port} argument.port parameter returns source or target port that was connected
        * @example
        * // connectionChange event for diagram
        * $("#diagramcontent").ejDiagram({
        * connectionChange:function (args)  {}
        }); 
        */
            connectionChange: null,
            /**
        *Triggers When rotate node
        * @event
        * @name ejDiagram#rotationChange
        * @param {Object} argument args parameter from diagram 
        * @param {Object} argument.element parameter returns node
        * @param {Boolean} argument.cancel if the event should be cancelled ,otherwise fasle
        * @example
        * // rotationChange event for diagram
        * $("#diagramcontent").ejDiagram({
        * rotationChange:function (args)  {}
        });
        */
            rotationChange: null,
            /**
          *Triggers When context menu item clicked
          * @event
          * @name ejDiagram#contextMenuClick
          * @param {Object} argument args parameter from diagram  
          * @example
          * // contextMenuClick event for diagram
          * $("#diagramcontent").ejDiagram({
          * contextMenuClick:function (args)  {}
          });
          */
            contextMenuClick: null,
            /**
         *Triggers bofore open the context menu
         * @event
         * @name ejDiagram#contextMenuBeforeOpen
         * @param {Object} argument args parameter from diagram  
         * @example
         * // contextMenuBeforeOpen event for diagram
         * $("#diagramcontent").ejDiagram({
         * contextMenuBeforeOpen:function (args)  {}
         });
         */
            contextMenuBeforeOpen: null
        },

        observables: [
            "nodes",
            "connectors",
            "locale",
            "enableContextMenu",
            "enableAutoScroll",
            "showTooltip",
            "bridgeDirection",
            "tool",
            "zoomFactor",
            "pageSettings.pageHeight",
            "pageSettings.pageWidth",
            "pageSettings.multiplePage",
            "pageSettings.pageBorderWidth",
            "pageSettings.pageBackgroundColor",
            "pageSettings.pageBorderColor",
            "pageSettings.pageMargin",
            "pageSettings.showPageBreak",
            "pageSettings.pageOrientation",
			"pageSettings.scrollLimit",
            "snapSettings.enableSnapToObject",
            "snapSettings.snapAngle",
            "snapSettings.snapObjectDistance",
            "selector.offsetX",
            "selector.offsetY",
            "selector.width",
            "selector.height",
            "selector.rotateAngle",
        ],

        nodes: ej.util.valueFunction("nodes"),
        connectors: ej.util.valueFunction("connectors"),
        locale: ej.util.valueFunction("locale"),
        enableContextMenu: ej.util.valueFunction("enableContextMenu"),
        enableAutoScroll: ej.util.valueFunction("enableAutoScroll"),
        showTooltip: ej.util.valueFunction("showTooltip"),
        bridgeDirection: ej.util.valueFunction("bridgeDirection"),
        tool: ej.util.valueFunction("tool"),
        zoomFactor: ej.util.valueFunction("zoomFactor"),
        _pageHeight: ej.util.valueFunction("pageSettings.pageHeight"),
        _pageWidth: ej.util.valueFunction("pageSettings.pageWidth"),
        _multiplePage: ej.util.valueFunction("pageSettings.multiplePage"),
        _pageBorderWidth: ej.util.valueFunction("pageSettings.pageBorderWidth"),
        _pageBackgroundColor: ej.util.valueFunction("pageSettings.pageBackgroundColor"),
        _pageBorderColor: ej.util.valueFunction("pageSettings.pageBorderColor"),
        _pageMargin: ej.util.valueFunction("pageSettings.pageMargin"),
        _showPageBreak: ej.util.valueFunction("pageSettings.showPageBreak"),
        _pageOrientation: ej.util.valueFunction("pageSettings.pageOrientation"),
        _scrollLimit: ej.util.valueFunction("pageSettings.scrollLimit"),
        _enableSnapToObject: ej.util.valueFunction("snapSettings.enableSnapToObject"),
        _snapAngle: ej.util.valueFunction("snapSettings.snapAngle"),
        _snapObjectDistance: ej.util.valueFunction("snapSettings.snapObjectDistance"),
        _selectorOffsetX: ej.util.valueFunction("selector.offsetX"),
        _selectorOffsetY: ej.util.valueFunction("selector.offsetY"),
        _selectorWidth: ej.util.valueFunction("selector.width"),
        _selectorHeight: ej.util.valueFunction("selector.height"),
        _selectorRotateAngle: ej.util.valueFunction("selector.rotateAngle"),

        dataTypes: {
            contextMenu: {
                items: "array",
                showCustomMenuItemsOnly: "boolean"
            },
            layout: {
                type: "enum",
                orientation: "enum",
                horizontalSpacing: "number",
                verticalSpacing: "number",
                marginX: "number",
                marginY: "number"
            },
        },

        //#endregion

        //#region Local members
        _canvas: null,
        _svg: null,
        _toolToActivate: null,
        _inAction: false,
        _isPinching: false,
        _isEditing: false,
        _nodeToHit: null,
        _currentCursor: null,
        _pasteIndex: null,
        _page: null,
        _view: null,
        _currentLabel: null,
        _zOrder: 0,
        _clipboardData: null,
        _currZoom: 1,
        _selectedItem: "",
        _historyList: {
            currentEntry: {
                next: null,
                previous: null
            },
            canUndo: false,
            canRedo: false
        },

        _defaultContextMenuItems: [
            { name: "cut", text: "Cut" },
            { name: "copy", text: "Copy" },
            { name: "paste", text: "Paste" },
            { name: "undo", text: "Undo" },
            { name: "redo", text: "Redo" },
            { name: "selectAll", text: "Select All" },
            {
                name: "grouping",
                text: "Grouping",
                subItems: [
                            { name: "group", text: "Group" },
                            { name: "ungroup", text: "Ungroup" }
                ]
            },
            {
                name: "order",
                text: "Order",
                subItems: [
                            { name: "bringToFront", text: "Bring To Front" },
                            { name: "moveForward", text: "Move Forward" },
                            { name: "sendToBack", text: "Send To Back" },
                            { name: "sendBackward", text: "Send Backward" }
                ]
            }
        ],

        _hScrollOffset: 0,
        _vScrollOffset: 0,
        _hScrollbar: null,
        _vScrollbar: null,
        _scrollPixel: 30,
        //#endregion

        //#region public members
        activeTool: null,
        selectionList: [],
        tools: null,
        nameTable: {},
        //#endregion

        //#region Initialization
        _updateScrollOffset: function (hScrollOffset, vScrollOffset, canScale) {
            this._hScrollOffset = hScrollOffset;
            this._vScrollOffset = vScrollOffset;
            ej.datavisualization.Diagram.ScrollUtil._transform(this, hScrollOffset, vScrollOffset, canScale);
            var diagram = this;
            this._views.forEach(function (viewid) {
                var view = diagram._views[viewid];
                if (view.type == "overview") {
                    var ovw = $("#" + viewid).ejOverview("instance");
                    if (ovw)
                        ovw._scrollOverviewRect(hScrollOffset, vScrollOffset, diagram._currZoom);
                }
            });
        },

        _init: function () {
            if (!(ej.browserInfo().name === "msie" && Number(ej.browserInfo().version) < 9)) {
                this._spatialSearch = ej.datavisualization.Diagram.SpatialSearch();
                this._initDefaults();
                this._initViews();
                this._initData();
                this._doLayout();
                this._initCanvas();
                this._initDiagramTool();
                this._initVisualGuide();
                this._wireEvents();
                this._initHandles();
                this._initContextMenu();
                this._drawingTool = false;
                this._isDropped = false;
            }
        },

        _setModel: function (options) {
            for (var option in options) {
                switch (option) {
                    case "nodes":
                        this.nodes(typeof option.nodes === 'function' ? option.nodes() : option.nodes);
                        this._initNodeCollection(true);
                        $(this.element).find(".ej-d-node").remove();
                        $(this.element).find(".ej-d-group").remove();
                        if (this._hasSelection())
                            this._clearSelection();
                        var diagram = this;
                        this._views.forEach(function (viewid) {
                            var view = diagram._views[viewid];
                            diagram._renderNodes(view, true);
                        });
                        break;
                    case "connectors":
                        this.connectors(typeof option.connectors === 'function' ? option.connectors() : option.connectors);
                        this._initConnectorCollection();
                        $(this.element).find(".ej-d-connector").remove();
                        if (this._hasSelection())
                            this._clearSelection();
                        var diagram = this;
                        this._views.forEach(function (viewid) {
                            var view = diagram._views[viewid];
                            diagram._renderConnectors(view);
                        });
                        break;
                    case "phases":
                        this.element.remove(".ej-d-node");
                        this.element.remove(".ej-d-group");
                        var diagram = this;
                        this._views.forEach(function (viewid) {
                            var view = diagram._views[viewid];
                            diagram._renderphases(view);
                        });
                        break;
                    case "enableContextMenu":
                    case "contextMenu":
                        this.model.contextMenu = options[option];
                        this._initContextMenu();
                        break;
                    case "snapSettings":
                        var object = options[option];
                        if (object && Object.keys(object).length > 0) {
                            this._updateSnapSettings(options[option]);
                            ej.datavisualization.Diagram.SvgContext._renderGrid(this._canvas, this._svg, this._page, this);
                        }
                        break;
                    case "selectorConstraints":
                        this._setSelectorConstraints(options[option]);
                        break;
                    case "constraints":
                        if (this._hasSelection())
                            this._clearSelection();
                        break;
                    case "drawingTools":
                        this.model.drawingTools = options[option];
                        this._registerDrawingTools();
                        break;
                    case "backgroundImage":
                        this.model.backgroundImage = options[option];
                        ej.datavisualization.Diagram.SvgContext._renderBackground(this._canvas, this._svg, this._page, this.model);
                        break;
                    case "enableAutoScroll":
                        this.enableAutoScroll(options[option]);
                        break;
                    case "autoScrollMargin":
                        this.model.autoScrollMargin = options[option];
                        break;
                    case "layout":
                        this.model.layout = $.extend(true, {}, this.model.layout, options[option]);
                        this._setLayout(options[option]);
                        break;
                    case "selectedItems":
                        this.updateSelector(options[option]);
                        break;
                    case "pageSettings":
                        this.updatePageSettings(options[option]);
                        break;
                    case "locale":
                        this.locale(options[option]);
                        var contextmenu = document.getElementById(this.element[0].id + "_contextMenu");
                        contextmenu.parentNode.removeChild(contextmenu);
                        if (this.model.contextMenu && this.model.contextMenu.items && this.model.contextMenu.items.length > 0)
                            this.model.contextMenu.items = [];
                        this._renderContextMenu();
                        break;
                    case "nodeTemplate":
                        this.clear();
                        this._initData();
                        var diagram = this;
                        this._views.forEach(function (viewid) {
                            var view = diagram._views[viewid];
                            diagram._renderNodes(view);
                            diagram._renderConnectors(view);
                        });
                        this.layout();
                        break;
                    case "bridgeDirection":
                    case "tool":
                        this.update(options);
                        break;
                    case "connectorTemplate":
                        this._updateConnectors();
                        break;
                    case "dataSourceSettings":
                        var object = options[option];
                        if (object && Object.keys(object).length > 0) {
                            this.clear();
                            $.extend(true, this.model.dataSourceSettings, {}, options[option]);
                            this._initData();
                            var diagram = this;
                            this._views.forEach(function (viewid) {
                                var view = diagram._views[viewid];
                                diagram._renderNodes(view);
                                diagram._renderConnectors(view);
                            });
                            this.layout();
                        }
                        break;
                }
            }
        },

        _initData: function () {
            if (this.model.dataSourceSettings)
                var dataSource = this.model.dataSourceSettings.dataSource || this.model.dataSourceSettings.nodes || this.model.dataSourceSettings.connectors;
            if (dataSource) {
                var nodes = [];
                var connectors = [];
                var dataSourceApplied;
                if (this.model.dataSourceSettings.nodes || this.model.dataSourceSettings.connectors) {
                    if (this.model.dataSourceSettings.nodes) {
                        dataSource = this.model.dataSourceSettings.nodes.dataSource || this.model.dataSourceSettings.dataSource;
                        if (dataSource) {
                            if (dataSource instanceof ej.DataManager) {
                                $.ajaxSetup({
                                    async: false
                                });
                                var query = this._findQuery(this.model.dataSourceSettings.nodes, this.model.dataSourceSettings.nodeBinding);
                                var queryPromise = dataSource.executeQuery(eval(query));
                                var diagram = this;
                                queryPromise.done(function (e) {
                                    diagram.retriveData = e.result;
                                    diagram._applyTemplate(diagram.model.dataSourceSettings, e.result, nodes, "nodes");
                                });
                            } else
                                this._applyTemplate(this.model.dataSourceSettings, dataSource, nodes, "nodes");
                        }
                        if (this.model.dataSourceSettings.connectors) {
                            dataSource = this.model.dataSourceSettings.connectors.dataSource || this.model.dataSourceSettings.dataSource;
                            if (dataSource) {
                                if (dataSource instanceof ej.DataManager) {
                                    $.ajaxSetup({
                                        async: false
                                    });
                                    query = this._findQuery(this.model.dataSourceSettings.connectors, this.model.dataSourceSettings.connectorBinding);
                                    queryPromise = dataSource.executeQuery(eval(query));
                                    queryPromise.done(function (e) {
                                        diagram.retriveData = e.result;
                                        diagram._applyTemplate(diagram.model.dataSourceSettings, e.result, connectors, "connectors");
                                    });
                                } else {
                                    this._applyTemplate(this.model.dataSourceSettings, dataSource, connectors, "connectors");
                                }
                            }
                        }
                    }
                } else if (dataSource instanceof ej.DataManager)
                    this._initDataSource(dataSource, nodes, connectors);
                else if (dataSource.length) {
                    this._applyDataSource(this.model.dataSourceSettings, dataSource, nodes, connectors);
                    dataSourceApplied = true;
                }
                var tempNodes = [], tempconnectors = [];
                if (this.nodes().length > 0)
                    tempNodes = this.nodes();
                if (this.connectors().length > 0)
                    tempconnectors = this.connectors();
                this.nodes(nodes);
                this.connectors(connectors);

                for (var i = 0; i < tempNodes.length; i++) {
                    this.nodes().push(tempNodes[i]);
                }
                for (var i = 0; i < tempconnectors.length; i++) {
                    this.connectors().push(tempconnectors[i]);
                }

            }
            var collapsedNodes = this._initNodeCollection(false, dataSourceApplied);
            this._initConnectorCollection(dataSourceApplied);
            if (collapsedNodes.length > 0) {
                this._collapseNodes(collapsedNodes);
            }
        },

        _initDataSource: function (dataSource, nodes, connectors) {
            var mapper = this.model.dataSourceSettings;
            if (dataSource instanceof ej.DataManager) {
                $.ajaxSetup({
                    async: false
                });
                var query = this._findQuery(mapper, this.model.dataSourceSettings.nodeBinding);
                var queryPromise = this.model.dataSourceSettings["dataSource"].executeQuery(eval(query));
                var diagram = this;
                queryPromise.done(function (e) {
                    diagram.retriveData = e.result;
                    diagram._applyDataSource(diagram.model.dataSourceSettings, e.result, nodes, connectors);
                });
            }
        },

        _findQuery: function (mapper, binding) {
            var column = [], queryManager = ej.Query();
            var query = mapper.query || this.model.dataSourceSettings.query;

            if (ej.isNullOrUndefined(query)) {
                var dataSource = mapper.dataSource || this.model.dataSourceSettings.dataSource;
                var tableName = mapper.tableName || this.model.dataSourceSettings.tableName;;
                for (var col in mapper) {
                    if (col !== "tableName" && col !== "dataSource" && col !== "designTemplate" && !col.match("Binding"))
                        if (mapper[col]) column.push(mapper[col]);
                }
                for (var tempcol in binding) {
                    if (tempcol === "labels") {
                        var labels = binding[tempcol];
                        for (var i = 0; i < labels.length; i++) {
                            if (labels[i].text) column.push(labels[i].text);
                        }
                    } else if (tempcol == "shape" || tempcol == "line") {
                        if (binding[tempcol][type]) col.push(binding[tempcol][type]);
                    } else
                        if (binding[tempcol]) column.push(binding[tempcol]);
                }

                if (column.length > 0)
                    queryManager.select(column);
                if (!dataSource["dataSource"].url.match(tableName + "$"))
                    !ej.isNullOrUndefined(tableName) && queryManager.from(tableName);

            } else
                queryManager = query;
            return queryManager;
        },

        _applyDataSource: function (mapper, data, nodes, connectors, ancestor) {
            var rootNodes = ej.DataManager(data).executeLocal(ej.Query().group(mapper.parent));
            if (mapper.parent) {
                var firstLvel = [];
                for (var i = 0; i < rootNodes.length; i++) {
                    if (rootNodes[i].key == undefined || rootNodes[i].key == "\"\"") {
                        firstLvel.push(rootNodes[i]);
                    }
                }
            }
            else firstLvel = rootNodes;
            var nodeBinding = this.model.dataSourceSettings.nodeBinding || {};
            var nodeDefaults = this.model.defaultSettings.node || {};
            var connectorDefaults = this.model.defaultSettings.connector || {};
            var connectorBinding = this.model.dataSourceSettings.connectorBinding || {};
            for (var i = 0; i < firstLvel.length; i++) {
                for (var j = 0; j < firstLvel[i].items.length; j++) {
                    var item = firstLvel[i].items[j];
                    var node = this._applyNodeTemplate(mapper, item, nodeBinding, nodeDefaults);
                    nodes.push(node);
                    var nextLevel = ej.DataManager(rootNodes).executeLocal(ej.Query().where("key", ej.FilterOperators.equal, item[mapper.id]));
                    if (nextLevel[0] && nextLevel[0].items)
                        this._renderChildNodes(mapper, nextLevel[0], node.name, nodes, connectors, rootNodes);
                }
            }
        },

        _renderChildNodes: function (mapper, parent, ancestor, nodes, connectors, rootNodes) {
            var nodeBinding = this.model.dataSourceSettings.nodeBinding || {};
            var nodeDefaults = this.model.defaultSettings.node || {};
            var connectorDefaults = this.model.defaultSettings.connector || {};
            var connectorBinding = this.model.dataSourceSettings.connectorBinding || {};
            for (var j = 0; j < parent.items.length; j++) {
                var child = parent.items[j];
                var node = this._applyNodeTemplate(mapper, child, nodeBinding, nodeDefaults);
                nodes.push(node);
                connectors.push(this._applyConnectorTemplate(mapper, null, connectorBinding, connectorDefaults, ancestor, node.name));
                var nextLevel = ej.DataManager(rootNodes).executeLocal(ej.Query().where("key", ej.FilterOperators.equal, child[mapper.id]));
                if (nextLevel[0] && nextLevel[0].items)
                    this._renderChildNodes(mapper, nextLevel[0], node.name, nodes, connectors, rootNodes);
            }
        },

        _applyTemplate: function (mapper, data, collection, collname) {
            if (collname == "nodes") {
                var template = this.model.dataSourceSettings.nodeBinding || {};
                var defaults = this.model.defaultSettings.node || {};
                for (var i = 0; i < data.length; i++) {
                    var node = this._applyNodeTemplate(mapper, data[i], template, defaults);
                    collection.push(node);
                }
            }
            if (collname == "connectors") {
                var template = this.model.dataSourceSettings.connectorBinding || {};
                var defaults = this.model.defaultSettings.connector || {};
                for (var i = 0; i < data.length; i++) {
                    var conn = this._applyConnectorTemplate(mapper, data[i], template, defaults);
                    collection.push(conn);
                }
            }
        },

        _applyNodeTemplate: function (mapper, item, nodeBinding, nodeDefaults) {
            var root = jQuery.extend(true, {}, nodeDefaults, item);
            if (root.name === "" || !root.name)
                root.name = ej.datavisualization.Diagram.Util.randomId();
            if (nodeBinding) {
                for (var prop in nodeBinding) {
                    if (prop != "labels")
                        root[prop] = item[nodeBinding[prop]];
                }
                if (nodeBinding.labels) {
                    if (!root.labels) {
                        root.labels = [];
                    }
                    for (var i = 0; i < nodeBinding.labels.length; i++) {
                        var label = nodeDefaults && nodeDefaults.labels && nodeDefaults.labels.length ? nodeDefaults.labels[i % nodeDefaults.labels.length] : {};
                        label.name = ej.datavisualization.Diagram.Util.randomId();
                        label.text = item[nodeBinding.labels[i].text];
                        root.labels[i] = label;
                    }
                }
                if (nodeBinding.shape) {
                    var shape = nodeDefaults && nodeDefaults.shape ? nodeDefaults.shape : {};
                    shape.type = item[nodeBinding.shape.type];
                    root.shape = shape;
                }
            }
            root = ej.datavisualization.Diagram.Node(root);
            if (root)
                root = this._getNewNode(root);
            if (this.model.nodeTemplate) {
                if (typeof this.model.nodeTemplate === "string") {
                    this.model.nodeTemplate = ej.util.getObject(this.model.nodeTemplate, window);
                }
                if ($.isFunction(this.model.nodeTemplate)) {
                    this.model.nodeTemplate(this, root);
                }
            }

            if (root.type == "group") {
                root = this._getNewGroup(root);
                this._initGroupNode(root);
            }
            else if (root.type == "node") {
                root = this._getNewNode(root)
            }

            return root;
        },

        _applyConnectorTemplate: function (mapper, item, connectorBinding, connectorDefaults, sourceNode, targetNode) {
            var connector = jQuery.extend(true, {}, connectorDefaults);
            connector.name = ej.datavisualization.Diagram.Util.randomId();
            connector.sourceNode = sourceNode;
            connector.targetNode = targetNode;
            if (connectorBinding) {
                for (var prop in connectorBinding) {
                    if (prop != "labels")
                        connector[prop] = item[connectorBinding[prop]];
                }
                if (connectorBinding.labels) {
                    if (!connector.labels) {
                        connector.labels = [];
                    }
                    for (var i = 0; i < connectorBinding.labels.length; i++) {
                        var label = connectorDefaults && connectorDefaults.labels && connectorDefaults.labels.length ? connectorDefaults.labels[i % connectorDefaults.labels.length] : {};
                        label.name = ej.datavisualization.Diagram.Util.randomId();
                        label.text = item[connectorBinding.labels[i].text];
                        connector.labels[i] = label;
                    }
                }
                //if (connectorBinding.segments) {
                //    var line = {};
                //    line.type = item[connectorBinding.line.type];
                //    connector.line = line;
                //}
            }
            var connector = ej.datavisualization.Diagram.Connector(connector);
            if (this.model.connectorTemplate) {
                this.model.connectorTemplate(this, connector, item);
            }
            return connector;
        },

        _collapseNodes: function (nodes) {
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                this._collapseChildren(node);
            }
        },

        _initViews: function () {
            this._views = [];
            this._views.push(this._id);
            this._views[this._id] = {
                "type": "mainview",
                "context": ej.datavisualization.Diagram.SvgContext,
                "style": "position:relative; height:" + this.model.height + "; width:" + this.model.width + ";"
            };
        },
        _setOverview: function (overview, id) {
            if (overview) {
                this._overview = overview;
                if (!this._views[overview._id]) {
                    this._views.push(overview._id);
                    this._views[overview._id] = { "context": ej.datavisualization.Diagram.SvgContext, "type": "overview" };
                    overview._renderDocument(this._views[overview._id]);
                    this._renderNodes(this._views[overview._id], null, true);
                    this._renderConnectors(this._views[overview._id]);
                    overview._updateOverview(this._views[overview._id]);
                }
            } else {
                var overview = $("#" + id).ejOverview("instance");
                overview._removeDocument(this._views[id]);
                this._views[id] = undefined;
                var index = this._views.indexOf(id);
                this._views.splice(index, 1);
                //this._overview = null;
            }

        },

        _getChild: function (child) {
            if (child) {
                if (typeof (child) == "object") {
                    return child.name;
                }
                else {
                    return child;
                }
            }
        },

        _getChildren: function (children) {
            if (children) {
                var children1 = [];
                for (var i = 0; i < children.length; i++) {
                    var child = children[i];
                    if (child) {
                        if (typeof (child) == "object") {
                            children1.push(child.name);
                        }
                        else {
                            children1.push(child);
                        }
                    }
                }
                return children1;
            }
        },
        _initGroupNode: function (group) {
            var child = null;
            for (var i = 0; i < group.children.length; i++) {
                child = group.children[i];
                if (child && typeof (child) == "object") {
                    if (child.type != "group" && !child.children && !child.segments && child.type != "connector") {
                        group.children[i] = child = this._getNewNode(child);
                        if (child.name == "") {
                            child.name = ej.datavisualization.Diagram.Util.randomId();
                        }
                    }
                    else if (child.segments || child.type == "connector") {
                        group.children[i] = child = this._getNewConnector(child);
                        if (child.name == "") {
                            child.name = ej.datavisualization.Diagram.Util.randomId();
                        }
                    }
                    else {
                        group.children[i] = child = this._getNewGroup(child);
                        if (child.name == "") {
                            child.name = ej.datavisualization.Diagram.Util.randomId();
                        }
                        this._initGroupNode(child);
                    }
                    child.parent = group.name;
                    this.nameTable[child.name] = child;
                    this.nodes()[this.nodes().length] = this.nameTable[child.name];
                }
            }
        },
        _initNodeCollection: function (isLoad, dataSourceApplied) {
            var collapsedNodes = [];
            var nodes = this.nodes();
            var length = this.nodes().length;
            for (var i = 0; i < length; i++) {
                if (nodes[i].name == "") {
                    nodes[i].name == ej.datavisualization.Diagram.Util.randomId();
                }
                if (nodes[i].type == "swimlane" || nodes[i].isSwimlane) {
                    if (isLoad)
                        nodes[i] = nodes[i];
                    else
                        nodes[i] = ej.datavisualization.Diagram.SwimLaneHelper._initSwimLane(nodes[i], this);
                    this.nameTable[nodes[i].name] = ej.datavisualization.Diagram.Group(nodes[i]);

                }
                else if (nodes[i].type == "group" || (nodes[i].children && nodes[i].children.length > 0)) {
                    nodes[i] = ej.datavisualization.Diagram.Group(nodes[i]);
                    this.nameTable[nodes[i].name] = nodes[i];
                    this._initGroupNode(nodes[i]);
                }
                else {
                    if (!dataSourceApplied)
                        nodes[i] = this._getNewNode(nodes[i]); //ej.datavisualization.Diagram.Node(nodes[i]);
                    this.nameTable[nodes[i].name] = nodes[i];
                    ej.datavisualization.Diagram.SpatialUtil._updateQuad(this, this._spatialSearch, nodes[i]);
                }
                this.nameTable[nodes[i].name] = nodes[i];
                if (!nodes[i].isExpanded) {
                    collapsedNodes.push(nodes[i]);
                }
            }
            return collapsedNodes;
        },

        _getNewNode: function (options) {
            return ej.datavisualization.Diagram.Node($.extend(true, {}, this.model.defaultSettings.node, options));
        },

        _getNewGroup: function (options) {
            var child = null;
            if (options.children && options.children.length > 0) {
                for (var i in options.children) {
                    child = this.nameTable[this._getChild(options.children[i])];
                    if (child) {
                        if (child.segments) {
                            if (this.nameTable[child.name])
                                delete this.nameTable[child.name];
                            this.nameTable[child.name] = this._getNewConnector(child);
                            this._dock(this.nameTable[child.name], this.nameTable);
                            ej.datavisualization.Diagram.Util.updateBridging(this.nameTable[child.name], this);
                            this._updateQuad(this, this.nameTable[child.name]);
                        }
                        else if (child.type == "node") {
                            if (this.nameTable[child.name])
                                delete this.nameTable[child.name];
                            this.nameTable[child.name] = this._getNewNode(child);
                        }
                        else if (child.type == "group") {
                            if (this.nameTable[child.name])
                                delete this.nameTable[child.name];
                            this.nameTable[child.name] = this._getNewGroup(child);
                        }
                    }
                }
            }
            return ej.datavisualization.Diagram.Group($.extend(true, {}, this.model.defaultSettings.node, options));

        },
        _getNewConnector: function (options) {
            var obj = $.extend(true, {}, this.model.defaultSettings.connector, options);
            if (this.model.defaultSettings.connector && (this.model.defaultSettings.connector.segments && this.model.defaultSettings.connector.segments[0])) {
                obj.defaultType = this.model.defaultSettings.connector.segments[0].type;
            }
            return ej.datavisualization.Diagram.Connector(obj);
        },
        _getTightChildrenBounds: function (node) {
            var children = this._getChildren(node.children), rect, bounds = null, child;
            for (var i = 0, len = children.length; i < len; i++) {
                child = this.nameTable[children[i]];
                if (child) {
                    var rect1 = ej.datavisualization.Diagram.Util.bounds(child);
                    rect = ej.datavisualization.Diagram.Geometry.rect([rect1.topLeft, rect1.topRight, rect1.bottomRight, rect1.bottomLeft]);
                    if (child.verticalAlign == "stretch") {
                        rect.height = 0;
                    } else if (child.horizontalAlign == "stretch") {
                        rect.width = 0;
                    }
                }
                if (bounds)
                    bounds = this._union(rect, bounds);
                else
                    bounds = rect;
            }
            return bounds;
        },
        _getBoundsWithoutStretch: function (node, vertical, horizontal) {
            var children = this._getChildren(node.children), rect, rect1, bounds = null, child;
            for (var i = 0, len = children.length; i < len; i++) {
                child = this.nameTable[children[i]];
                rect1 = ej.datavisualization.Diagram.Util.bounds(child);
                rect = ej.datavisualization.Diagram.Geometry.rect([rect1.topLeft, rect1.topRight, rect1.bottomRight, rect1.bottomLeft]);
                if (vertical) {
                    if (child.verticalAlign == "stretch" && !(child.verticalAlign == "stretch" && child.horizontalAlign == "stretch")) {
                        rect.height = 0;
                    }
                } else if (horizontal) {
                    if (child.horizontalAlign == "stretch" && !(child.verticalAlign == "stretch" && child.horizontalAlign == "stretch")) {
                        rect.width = 0;
                    }
                }

                if (bounds)
                    bounds = this._union(rect, bounds);
                else
                    bounds = rect;
            }

            bounds.width += node.paddingLeft + node.paddingRight;
            bounds.height += node.paddingTop + node.paddingBottom;
            return bounds;
        },
        _getMinMaxSize: function (node, width, height, stretch) {
            var nw = null, nh = null;
            if (width >= node.minWidth && width <= node.maxWidth) {
                nw = width;
            } else {
                if (node.horizontalAlign == "stretch" && node.parent && !stretch) {
                    var group = this.nameTable[node.parent];
                    if (group) {
                        var rSize = ej.datavisualization.Diagram.Util.bounds(group);// ej.datavisualization.Diagram.SvgContext._measureCanvasSize(group, this);
                        if (rSize.width == 0 && rSize.height == 0) {
                            rSize.width = width;
                            rSize.height = height;
                        }
                        var newSize = this._getMinMaxSize(group, rSize.width, rSize.height);
                        newSize.width -= (group.paddingLeft + group.paddingRight + group.marginLeft + group.marginRight);
                        newSize.height -= (group.paddingTop + group.paddingBottom + group.marginTop + group.marginBottom);
                        nw = newSize.width ? newSize.width : width;
                    }
                } else if (width < node.minWidth && node.minWidth != 0)
                    nw = node.minWidth;
                else if (width > node.maxWidth && node.maxWidth != 0)
                    nw = node.maxWidth;
                else
                    nw = width;
            }

            if (height >= node.minHeight && height <= node.maxHeight) {
                nh = height;
            } else {
                if (node.verticalAlign == "stretch" && node.parent && !stretch) {
                    var group = this.nameTable[node.parent];
                    var rSize = ej.datavisualization.Diagram.Util.bounds(group);
                    if (rSize.width == 0 && rSize.height == 0) {
                        //rSize.width = width;
                        //rSize.height = height;
                        var status = null;
                        var state = false;
                        rSize.width = node.minWidth;
                        rSize.height = node.minHeight;
                        if (node.minWidth == 0 && node.minHeight == 0) {
                            rSize.width = width;
                            rSize.height = height;
                            status = false;
                            state = true;
                        }
                        if (!state)
                            status = true;
                    }
                    var newSize = this._getMinMaxSize(group, rSize.width, rSize.height);
                    newSize.width -= (group.paddingLeft + group.paddingRight + group.marginLeft + group.marginRight);
                    newSize.height -= (group.paddingTop + group.paddingBottom + group.marginTop + group.marginBottom);
                    if (status) {
                        newSize.height -= node.marginTop;

                    }
                    nh = newSize.height ? newSize.height : height;
                } else if (height < node.minHeight && node.minHeight != 0)
                    nh = node.minHeight;
                else if (height > node.maxHeight && node.maxHeight != 0)
                    nh = node.maxHeight;
                else
                    nh = height;
            }
            return { width: nw, height: nh };
        },
        _initConnectorCollection: function (dataSourceApplied) {
            var connectors = this.connectors();
            var connector;
            for (var i = 0, len = connectors.length; i < len; i++) {
                connector = this._getNewConnector(connectors[i]);
                this.nameTable[connector.name] = connector;
                ej.datavisualization.Diagram.SpatialUtil._updateQuad(this, this._spatialSearch, connector);
                var segment = connectors[i].segments || (this.model.defaultSettings.connector && this.model.defaultSettings.connector.segments);
                if (segment)
                    segment = $.extend(true, {}, { value: segment });
                var update = false;
                var port, bounds;
                if (connector.sourceNode && connector.sourcePort) {
                    bounds = ej.datavisualization.Diagram.Util.bounds(this.nameTable[connector.sourceNode], true);
                    port = ej.datavisualization.Diagram.Util.findPortByName(this.nameTable[connector.sourceNode], connector.sourcePort);
                    connector.sourcePoint = ej.datavisualization.Diagram.Util._getPortPosition(port, bounds);
                    update = true;
                }
                if (connector.targetNode && connector.targetPort) {
                    bounds = ej.datavisualization.Diagram.Util.bounds(this.nameTable[connector.targetNode], true);
                    port = ej.datavisualization.Diagram.Util.findPortByName(this.nameTable[connector.targetNode], connector.targetPort);
                    connector.targetPoint = ej.datavisualization.Diagram.Util._getPortPosition(port, bounds);
                    update = true;
                }
                if (update)
                    ej.datavisualization.Diagram.Util._updateConnectorSegments(connector, null, null, this);
                this._dock(connector, this.nameTable);
                if (segment && connector.segments.length > 1 && !connector.sourcePort) {
                    if (this.model.defaultSettings.connector && (this.model.defaultSettings.connector.segments && this.model.defaultSettings.connector.segments[0])) {
                        var defaultType = this.model.defaultSettings.connector.segments[0].type;
                    }
                    if (segment)
                        connector.segments = segment.value;
                    ej.datavisualization.Diagram.Util._initializeSegments(connector, defaultType);
                    ej.datavisualization.Diagram.Util.updateBridging(connector, this);
                }
                this._updateEdges(connector);
                connectors[i] = connector;
            }
        },

        _initDefaults: function () {
            this._initTools();
        },

        _initCanvas: function () {
            this._renderCanvas();
            if (this.model.selectorConstraints && this.model.selectedItems) {
                this.model.selectedItems.constraints = this.model.selectorConstraints;
            }
        },

        _updateConnectorBridging: function (baseConnector) {
            var childBounds = ej.datavisualization.Diagram.Util.bounds(baseConnector);
            var quads = ej.datavisualization.Diagram.SpatialUtil.findQuads(this._spatialSearch, childBounds);
            for (var item = 0; item < quads.length; item++) {
                var quad = quads[item];
                if (quad.objects.length > 0) {
                    for (var q = 0; q < quad.objects.length; q++) {
                        var connector = quad.objects[q];
                        if (connector.segments) {
                            if (connector != baseConnector) {
                                ej.datavisualization.Diagram.Util.updateBridging(connector, this);
                                ej.datavisualization.Diagram.DiagramContext.update(connector, this);
                            }
                        }
                    }
                }
            }
        },

        _initVisualGuide: function () {
            if (this.showTooltip() && !this.model.tooltipTemplateId) {
                var script = document.createElement("script");
                var attr = {
                    "id": this.element[0].id + "_defaultTooltip",
                    "type": "text/x-jsrender"
                };
                ej.datavisualization.Diagram.Util.attr(script, attr);
                script.innerHTML = "<span class=\"e-diagram-tooltipLabel-default\"> {{:type}}{{:x}}{{:type1}}{{:y}}</span>";
                this._canvas.appendChild(script);
            } else {
                this.element.remove("#" + this.element[0].id + "_defaultTooltip");
            }
        },

        _initTools: function () {
            this.tools = {
                "select": new ej.datavisualization.Diagram.SelectTool(this),
                "move": new ej.datavisualization.Diagram.MoveTool(this),
                "resize": new ej.datavisualization.Diagram.ResizeTool(this),
                "rotate": new ej.datavisualization.Diagram.RotateTool(this),
                //"pivot": new ej.datavisualization.Diagram.PivotTool(this),
                "endPoint": new ej.datavisualization.Diagram.ConnectionEditTool(this),
                "panTool": new ej.datavisualization.Diagram.PanTool(this),
                "straightLine": new ej.datavisualization.Diagram.StraightLineTool(this),
                "orthogonalLine": new ej.datavisualization.Diagram.OrthogonalLineTool(this),
                "phase": new ej.datavisualization.Diagram.PhaseTool(this)
            };
            this._toolToActivate = "select";
            this.activeTool = this.tools[this._toolToActivate];
            this._registerDrawingTools();
        },

        _initDiagramTool: function () {
            var tool = this.tool();
            if (tool & ej.datavisualization.Diagram.Tool.ContinuesDraw) {
                this.activateTool(this.model.connectorType, false);
            }
            else if (tool & ej.datavisualization.Diagram.Tool.DrawOnce) {
                this.activateTool(this.model.connectorType, true);
            }
            else if (tool & ej.datavisualization.Diagram.Tool.ZoomPan) {
                if (ej.datavisualization.Diagram.Util.canPanning(this)) {
                    this._toolToActivate = "panTool";
                    this.activeTool = this.tools[this._toolToActivate];
                    this.activeTool._isMouseDown = false;
                    this._currentCursor = "pointer";
                }
            }
            else if (tool & ej.datavisualization.Diagram.Tool.MultipleSelect) {
                this.activateTool("select");
            }
        },

        _initHandles: function () {
            var userHandles = this.model.selectedItems.userHandles;
            if (userHandles) {
                for (var i = 0; i < userHandles.length; i++) {
                    userHandles[i] = ej.datavisualization.Diagram.UserHandle(userHandles[i]);
                    if (userHandles[i].tool) {
                        userHandles[i].tool.diagram = this;
                        this.tools[userHandles[i].name] = userHandles[i].tool;
                    }
                }
            }
        },

        _destroy: function () {
            this.element.empty().removeClass("e-datavisualization-diagram");
        },
        //#endregion       

        updatePageSettings: function (option) {
            if (option) {
                if (option.pageHeight) {
                    this._pageHeight(Number(typeof option.pageHeight === 'function' ? option.pageHeight() : option.pageHeight));
                }
                if (option.pageWidth) {
                    this._pageWidth(Number(typeof option.pageWidth === 'function' ? option.pageWidth() : option.pageWidth));
                }
                if (option.pageBorderWidth) {
                    this._pageBorderWidth(Number(typeof option.pageBorderWidth === 'function' ? option.pageBorderWidth() : option.pageBorderWidth));
                }
                if (option.pageMargin) {
                    this._pageMargin(Number(typeof option.pageMargin === 'function' ? option.pageMargin() : option.pageMargin));
                }
                if (option.pageBackgroundColor) {
                    this._pageBackgroundColor(typeof option.pageBackgroundColor === 'function' ? option.pageBackgroundColor() : option.pageBackgroundColor);
                }
                if (option.scrollLimit) {
                    this._scrollLimit(typeof option.scrollLimit === 'function' ? option.scrollLimit() : option.scrollLimit);
                }
                if (option.scrollableArea) {
                    this.model.pageSettings.scrollableArea = option.scrollableArea;
                }

                ej.datavisualization.Diagram.PageUtil._updatePageSize(this);
                ej.datavisualization.Diagram.SvgContext._updateBackground(this._hScrollOffset, this._vScrollOffset, this._currZoom, this);
                ej.datavisualization.Diagram.SvgContext._updateGrid(this._hScrollOffset, this._vScrollOffset, this._currZoom, this);
            }
        },

        _updateSnapSettings: function (option) {
            if (option) {
                if (option.snapAngle) {
                    this._snapAngle(Number(typeof option.snapAngle === 'function' ? option.snapAngle() : option.snapAngle));
                }
                if (option.snapObjectDistance) {
                    this._snapObjectDistance(Number(typeof option.snapObjectDistance === 'function' ? option.snapObjectDistance() : option.snapObjectDistance));
                }
            }
        },

        /**
     *update Node with their specific properties
     *@return jQuery
     *@param {String} name  to identify the Node from the model
     *@param {String} options to specify which property of the Node to be update
     *@example
     *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
     *&lt;script&gt;
     *var diagram=$("#diagramcontent").ejDiagram("instance");
     *var value = ej.datavisualization.Diagram.NodeConstraints.Default & ~ej.datavisualization.Diagram.NodeConstraints.Connect;
     *diagram.updateNode(node.name, { constraints: value });
     *&lt;/script&gt;
     *@memberof ejDiagram
     *@instance
     */
        //#region Public methods

        updateNode: function (name, options) {

            if (name) {
                var node = this._findNode(name);
                if (node) {
                    if (options.offsetX | options.offsetX === 0) {
                        this._translate(node, options.offsetX - node.offsetX, 0, this.nameTable);
                    }
                    if (options.offsetY | options.offsetY === 0) {
                        this._translate(node, 0, options.offsetY - node.offsetY, this.nameTable);
                    }
                    if (options.rotateAngle | options.rotateAngle === 0) {
                        this._rotate(node, options.rotateAngle - node.rotateAngle, this.nameTable);
                    }
                    if (options.width) {
                        node.width = node.width ? node.width : 1;
                        this.scale(node, options.width / node.width, 1, new ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY), this.nameTable);
                    }
                    if (options.height) {
                        node.height = node.height ? node.height : 1;
                        this.scale(node, 1, options.height / node.height, new ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY), this.nameTable);
                    }
                    if (options.connectorPadding != undefined) {
                        node.connectorPadding = options.connectorPadding;
                        this.scale(node, 1, 1, new ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY), this.nameTable);
                    }
                    if (options.visible != undefined) {
                        node.visible = options.visible;
                        if (!options.visible)
                            this._clearSelection();
                    }
                    if (options.constraints) {
                        if (node.type != "group") {
                            if (!(node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow)) {
                                node.constraints = options.constraints;
                                ej.datavisualization.Diagram.DiagramContext.renderShadow(node, this);
                            }
                            else {
                                node.constraints = options.constraints;
                                ej.datavisualization.Diagram.DiagramContext.removeShadow(node, this);
                            }
                        }
                        node.constraints = options.constraints;
                        if (this.selectionList[0] && this.selectionList[0].name === node.name) {
                            ej.datavisualization.Diagram.SvgContext.clearSelector(this._svg, this._adornerLayer);
                            ej.datavisualization.Diagram.SvgContext.renderSelector(this.selectionList[0], this._svg, this._adornerLayer, this._currZoom, this.model.selectedItems.constraints);
                            if (this.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles)
                                ej.datavisualization.Diagram.SvgContext.renderUserHandles(this.model.selectedItems.userHandles, this.selectionList[0], this._svg, this.selectionList[0].type == "pseudoGroup",
                                    this._currZoom, this._adornerLayer);
                        }
                    }
                    if (node.type != "group") {
                        if (options.fillColor) {
                            node.fillColor = options.fillColor;
                        }
                        if (options.opacity) {
                            node.opacity = options.opacity;
                        }
                        if (options.borderColor) {
                            node.borderColor = options.borderColor;
                        }
                        if (options.borderWidth) {
                            node.borderWidth = options.borderWidth;
                        }
                        if (options.borderDashArray) {
                            node.borderDashArray = options.borderDashArray;
                        }
                        if (options.gradient !== undefined)
                            node.gradient = options.gradient;
                    }
                    if (options.shape) {
                        if (ej.browserInfo().name === "msie") {
                            if (node.shape && node.shape.html) {
                                var htmlelement = document.getElementById(node.name + "_parentdiv");
                                htmlelement.parentNode.removeChild(htmlelement);
                            }
                        }
                        node.shape = ej.datavisualization.Diagram.Shape(options.shape);
                        ej.datavisualization.Diagram.DiagramContext.setNodeShape(node, this);
                    }
                    ej.datavisualization.Diagram.DiagramContext.update(node, this);
                    ej.datavisualization.Diagram.DiagramContext.updateNodeStyle(node, this);
                    if (this.selectionList[0] && this.selectionList[0].name === node.name)
                        ej.datavisualization.Diagram.SvgContext.updateSelector(node, this._svg, this._currZoom, this, this.model.selectedItems.constraints);

                    if (options.isExpanded !== undefined) {
                        //if (this.model.layout.type == "hierarchicaltree")
                        {
                            if (options.isExpanded) {
                                node.isExpanded = true;
                                this._expandChildren(node);
                            }
                            else {
                                node.isExpanded = false;
                                this._collapseChildren(node);
                            }
                            this.layout();
                        }
                    }
                }
            }
            if (name) {
                var node = this._findNode(name);
                if (node && node.type == "node" && options && options.type && options.type == "group" && options.children && options.children.length > 0) {
                    var isRendered = false;
                    if (this._svg.document.getElementById(node.name))
                        isRendered = true;
                    this.remove(node);
                    node.borderColor = "transparent";
                    node.borderDashArray = "";
                    node.borderWidth = 1;
                    node.fillColor = "#1BA0E2";
                    node.labels = [];
                    node.fillColor = "";
                    node.type = options.type;
                    node.children = options.children;
                    node = ej.datavisualization.Diagram.Group(node);
                    this._initGroupNode(node);
                    if (isRendered) {
                        ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);
                        this.add(node);
                        this._clearSelection();
                        this._addSelection(node);
                    }
                }
            }
        },

        /**
       *update Connector with their specific properties
       *@return jQuery
       *@param {String} name  to identify the connector from the model
       *@param {object} options to specify which property of the Connector to be update
       *@example
       *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
       *&lt;script&gt;
       *var diagram=$("#diagramcontent").ejDiagram("instance");
       *var value = ej.datavisualization.Diagram.ConnectorConstraints.Default;
       *diagram.updateConnector(connector.name, { constraints: value });      
       *&lt;/script&gt;
       *@memberof ejDiagram
       *@instance
       */
        updateConnector: function (name, options) {
            if (name) {
                var connector = this._findConnector(name);
                if (connector) {
                    if (options.constraints) {
                        connector.constraints = options.constraints;
                    }
                    if (options.lineColor) {
                        connector.lineColor = options.lineColor;
                    }
                    if (options.lineWidth) {
                        connector.lineWidth = options.lineWidth;
                    }
                    if (options.lineDashArray) {
                        connector.lineDashArray = options.lineDashArray;
                    }
                    if (options.sourcePadding != undefined) {
                        connector.sourcePadding = options.sourcePadding;
                        this._dock(connector, this.nameTable);
                    }
                    if (options.targetPadding != undefined) {
                        connector.targetPadding = options.targetPadding;
                        this._dock(connector, this.nameTable);
                    }
                    if (options.visible != undefined) {
                        node.visible = options.visible;
                        if (!options.visible)
                            this._clearSelection();
                    }
                    if (options.segments) {
                        connector.segments = options.segments;
                        if (this.model.defaultSettings.connector && this.model.defaultSettings.connector.segments[0]) {
                            var defaultType = this.model.defaultSettings.connector.segments[0].type;
                        }
                        ej.datavisualization.Diagram.Util._initializeSegments(connector, defaultType);
                        this._dock(connector, this.nameTable);
                        ej.datavisualization.Diagram.Util.updateBridging(connector, this);
                        this._updateQuad(this, connector);
                        if (connector == this.selectionList[0]) {
                            this._clearSelection();
                            this._addSelection(connector);
                        }
                    }

                    var decorator;
                    if (options.targetDecorator) {
                        if (connector.targetDecorator) {
                            decorator = $.extend(true, {}, connector.targetDecorator, options.targetDecorator);
                        } else {
                            decorator = ej.datavisualization.Diagram.Decorator(options.targetDecorator);
                        }
                        connector.targetDecorator = decorator;
                    }
                    if (options.sourceDecorator) {
                        if (connector.sourceDecorator) {
                            decorator = $.extend(true, {}, connector.sourceDecorator, options.sourceDecorator);
                        } else {
                            decorator = ej.datavisualization.Diagram.Decorator(options.sourceDecorator);
                        }
                        connector.sourceDecorator = decorator;
                    }
                    if (options.sourceDecorator || options.targetDecorator) {
                        ej.datavisualization.Diagram.DiagramContext.clearDecorators(connector, this);
                        ej.datavisualization.Diagram.DiagramContext.renderDecorators(connector, this);
                    }
                    if (this._svg) {
                        ej.datavisualization.Diagram.DiagramContext.update(connector, this);
                        ej.datavisualization.Diagram.DiagramContext.updateConnectorStyle(connector, this);
                    }
                    if (this.selectionList[0] && this.selectionList[0].name === connector.name)
                        ej.datavisualization.Diagram.SvgContext.updateSelector(connector, this._svg, this._currZoom, this, this.model.selectedItems.constraints);
                }
            }
        },

        /**
      *update Diagram with its specific properties
      *@return jQuery
      *@param {String} name  to identify the diagram from the model
      *@param {object} options to specify which properties of the diagram to be updated
      *@example
      *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
      *&lt;script&gt;
      *var diagram=$("#diagramcontent").ejDiagram("instance");
      *var value = ej.datavisualization.Diagram.DiagramConstraints.Default;
      *diagram.updateDiagram(diagram.name, { constraints: value });      
      *&lt;/script&gt;
      *@memberof ejDiagram
      *@instance
      */

        update: function (option) {
            if (option.tool) {
                this.activeTool._showAllPorts(true);
                var tool = option.tool;
                this.tool(tool);
                if (tool & ej.datavisualization.Diagram.Tool.ContinuesDraw) {
                    this.activateTool(this.model.connectorType, false);
                }
                else if (tool & ej.datavisualization.Diagram.Tool.DrawOnce) {
                    this.activateTool(this.model.connectorType, true);
                }
                else if (tool & ej.datavisualization.Diagram.Tool.ZoomPan) {
                    if (ej.datavisualization.Diagram.Util.canPanning(this)) {
                        this._toolToActivate = "panTool";
                        this.activeTool = this.tools[this._toolToActivate];
                        this.activeTool._isMouseDown = false;
                        this._currentCursor = "pointer";
                    }
                }
                else if (tool & ej.datavisualization.Diagram.Tool.MultipleSelect) {
                    this.activateTool("select");
                }
            }
            if (option.bridgeDirection) {
                this.bridgeDirection(option.bridgeDirection);
                var connectors = this.connectors();
                for (var i = 0, len = connectors.length; i < len; i++) {
                    var connector = connectors[i];
                    ej.datavisualization.Diagram.Util.updateBridging(connector, this);
                    ej.datavisualization.Diagram.DiagramContext.update(connector, this);
                }
            }
        },
        /**
       *To bring the specified portion of the diagram content to center of the diagram viewport
       *@return jQuery
       *@param {Object} rect pass bounds value (x,y,height,width)
       *@example
       
       *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
       *&lt;script&gt;
       *var diagram=$("#diagramcontent").ejDiagram("instance");
       *diagram.bringToCenter(ej.datavisualization.Diagram.Rectangle(700, 500, 80, 80));
       *&lt;/script&gt;
       *@memberof ejDiagram
        *@instance
       */
        bringToCenter: function (rect) {
            var scale = this._currZoom;
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this);
            var hoffset = rect.x + (rect.width) / 2 - viewPort.width / 2;
            var voffset = rect.y + (rect.height) / 2 - viewPort.height / 2;
            hoffset = Math.max(0, hoffset) * scale;
            voffset = Math.max(0, voffset) * scale;
            ej.datavisualization.Diagram.ZoomUtil._applyTransform(this, scale, ej.datavisualization.Diagram.Point(-hoffset, -voffset), null);
        },
        /**
        *To bring the specified portion of the diagram content to the diagram viewport
        *@return jQuery
        *@param {Object} bounds pass bounds value (x,y,height,width)
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.bringIntoView(ej.datavisualization.Diagram.Rectangle(700, 500, 80, 80));
        *&lt;/script&gt;
        *@memberof ejDiagram
        *@instance
        */
        bringIntoView: function (bounds) {
            var x = 0, y = 0;
            bounds.right = bounds.right ? bounds.right : bounds.x + bounds.width;
            bounds.bottom = bounds.bottom ? bounds.bottom : bounds.y + bounds.height;
            var hoffset = this._hScrollOffset;
            var voffset = this._vScrollOffset;
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this);
            if (bounds.right > (-hoffset + viewPort.width)) {
                x = bounds.right - viewPort.width;
            }
            if (bounds.x < -hoffset) {
                x = bounds.x;
            }
            if (bounds.bottom > (-voffset + viewPort.height)) {
                y = bounds.bottom - viewPort.height;
            }
            if (bounds.y < -voffset) {
                y = bounds.y;
            }
            ej.datavisualization.Diagram.ZoomUtil._applyTransform(this, this._currZoom, ej.datavisualization.Diagram.Point(-x, -y), null);

        },
        getBridgeSegment: function (startPt, endPt, angle, bridgeSpace, sweep) {
            var path = "A " + bridgeSpace / 2 + " " + bridgeSpace / 2 + "  " + angle + " , 1 " + sweep + " " + endPt.x + "," + endPt.y;
            return path;
        },


        /**
      
          *To fit the diagram content into diagram viewport       
          *@return jQuery
          *@param {Object} type to specify diagramcontent either by width or height or both of the viewport    
          *@param {Object} region to set fit whether to diagramcontent and pagesettings
          *@param {Object} margin to set the required margin viewport
          *@example         
          *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
          *&lt;script&gt;
          *var diagram=$("#diagramcontent").ejDiagram("instance");
          *diagram.fitToPage(type,region,margin);
          *&lt;/script&gt;
          *@memberof ejDiagram
          *@instance
          */

        fitToPage: function (type, region, margin) {
            var zoomFactor, factor, scale = {}, bounds;
            if (this.nodes().length > 0 || this.connectors().length > 0) {
                var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this);
                if (!margin)
                    margin = ej.datavisualization.Diagram.Margin();
                if (region != "custom") {
                    if (region == "content") {
                        bounds = new ej.datavisualization.Diagram.Rectangle();
                        bounds.x = this._spatialSearch.pageLeft;
                        bounds.y = this._spatialSearch.pageTop;
                        bounds.width = this._spatialSearch.pageRight;
                        bounds.height = this._spatialSearch.pageBottom;
                    }
                    else
                        bounds = this._getDigramBounds();
                }
                var width = region != "custom" ? bounds.width - bounds.x : bounds.width;
                var height = region != "custom" ? bounds.height - bounds.y : bounds.height;
                scale.x = (viewPort.width - (margin.left + margin.right)) / width;
                scale.y = (viewPort.height - (margin.top + margin.bottom)) / height;
                var deltaX = this._hScrollOffset;
                var deltaY = this._vScrollOffset;

                switch (type) {
                    case "width":
                        zoomFactor = scale.x;
                        factor = zoomFactor / this._getCurrentZoom();
                        deltaX -= bounds.x * zoomFactor;
                        deltaY -= this._vScrollOffset * factor;
                        deltaY = region != "custom" ? deltaY : deltaY + this._vScrollOffset * factor;
                        break;
                    case "height":
                        zoomFactor = scale.y;
                        factor = zoomFactor / this._getCurrentZoom();
                        //var centerX = (viewPort.width - (bounds.x > 0 ? bounds.width : width) * zoomFactor - bounds.x * zoomFactor) / 2;
                        //deltaX += centerX - (bounds.x * zoomFactor) / 4 + margin.left;
                        //deltaY -= bounds.y * zoomFactor - margin.top;
                        var centerX = (viewPort.width - (region != "content" ? bounds.width : width) * zoomFactor) / 2 - bounds.x * zoomFactor;
                        var centerY = (viewPort.height - (region != "content" ? bounds.height : height) * zoomFactor) / 2 - bounds.y * zoomFactor;
                        deltaX += centerX + (margin.left - margin.right) / 2 * zoomFactor;
                        deltaY += centerY + (margin.top - margin.bottom) / 2 * zoomFactor;
                        break;
                    case "page":
                        zoomFactor = Math.min(scale.x, scale.y);
                        factor = zoomFactor / this._getCurrentZoom();
                        if (Math.min(scale.x, scale.y) == scale.x) {
                            deltaX -= bounds.x * zoomFactor;
                            deltaY -= this._vScrollOffset * factor;
                            deltaY = region != "custom" ? deltaY : deltaY + this._vScrollOffset * factor;
                        }
                        else {
                            var centerX = (viewPort.width - (region != "content" ? bounds.width : width) * zoomFactor) / 2 - bounds.x * zoomFactor;
                            var centerY = (viewPort.height - (region != "content" ? bounds.height : height) * zoomFactor) / 2 - bounds.y * zoomFactor;
                            deltaX += centerX + (margin.left - margin.right) / 2 * zoomFactor;
                            deltaY += centerY + (margin.top - margin.bottom) / 2 * zoomFactor;
                        }
                        break;
                }
                ej.datavisualization.Diagram.ZoomUtil.zoomPan(this, factor, deltaX, deltaY, new ej.datavisualization.Diagram.Point(0, 0), true);
            }
            else {
                factor = 1 / this._getCurrentZoom();
                ej.datavisualization.Diagram.ZoomUtil.zoomPan(this, factor, this._hScrollOffset, this._vScrollOffset, new ej.datavisualization.Diagram.Point(0, 0), true);
            }
        },



        /**
    *To export the diagram as image .
    *@return jQuery
    *@example
 
    *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
    *&lt;script&gt;
    *var diagram=$("#diagramcontent").ejDiagram("instance");
    *diagram.exportAsImage();
    *&lt;/script&gt;
    *@memberof ejDiagram
    *@instance
 */
        exportAsImage: function () {
            var bounds = this._getDigramBounds();
            var bounds = {
                x: this._spatialSearch.pageLeft || bounds.x,
                y: this._spatialSearch.pageTop || bounds.y,
                width: this._spatialSearch.pageRight - this._spatialSearch.pageLeft || bounds.width,
                height: this._spatialSearch.pageBottom - this._spatialSearch.pageTop || bounds.height
            };
            var canvas = new ej.datavisualization.Diagram.Canvas({ "id": "mycanvas", "width": bounds.width + 50, "height": bounds.height + 50 });
            var context = canvas.document.getContext("2d");
            context.translate(-bounds.x + 25, -bounds.y + 25);
            context.fillStyle = this.model.pageSettings.pageBackgroundColor;
            context.fillRect(bounds.x - 25, bounds.y - 25, bounds.width + 50, bounds.height + 50);
            var elements = this.nodes().concat(this.connectors());
            elements = this._sortByZIndex(elements, true);
            for (var i = 0; i < elements.length; i++) {
                var element = elements[i];
                if (element.type == "group" && !element.parent)
                    ej.datavisualization.Diagram.CanvasContext.renderGroup(element, canvas, this);
                else if (element.shape)
                    ej.datavisualization.Diagram.CanvasContext.renderNode(element, canvas);
                else if (element.segments)
                    ej.datavisualization.Diagram.CanvasContext.renderConnector(element, canvas);
            }

            var tx = 0, ty = 0;
            if (this.model.phases) {
                for (var i = 0; i < this.model.phases.length; i++) {
                    var parNode = this.nameTable[this.model.phases[i].parent];
                    if (parNode) {
                        var children = this._getChildren(parNode.children);
                        if (children.length > 1)
                            var header = this.nameTable[children[0]];
                        var bounds = ej.datavisualization.Diagram.Util.bounds(parNode);
                        var points = [], nPoint;
                        var top = bounds.top + 50;
                        var left = bounds.left + 50;
                        if (this.model.phases[i].orientation == "vertical") {
                            points.push({ x: 0, y: 0 });
                            points.push({ x: bounds.width, y: 0 });
                            nPoint = this._convertToSVGPoints(points);
                            tx = bounds.x;
                            ty = bounds.y + this.model.phases[i].offset;
                            if (header)
                                top += header.height;
                            if (!(ty < bounds.bottom && ty > top)) {
                                visibility = "hidden";
                            }
                        } else {
                            points.push({ x: 0, y: header.height ? header.height : 0 });
                            points.push({ x: 0, y: bounds.height });
                            tx = bounds.x + this.model.phases[i].offset;
                            ty = bounds.y;
                            for (var j = 0, len = points.length; j < len; ++j) {
                                var point = ej.datavisualization.Diagram.Geometry.translate(points[j], tx, ty);
                                points[j] = point;
                            }
                        }
                    }
                    ej.datavisualization.Diagram.CanvasContext.renderPhases(this.model.phases[i], canvas, points);
                }
            }
            var url = canvas.document.toDataURL('image/png');
            return url;
        },
        /**
     *To print the diagram as image .
     *@return jQuery
     *@example
  
     *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
     *&lt;script&gt;
     *var diagram=$("#diagramcontent").ejDiagram("instance");
     *diagram.print();
     *&lt;/script&gt;
     *@memberof ejDiagram
     *@instance
  */
        print: function () {
            var url = this.exportAsImage();
            var img = document.createElement('img');
            var attr = {
                "id": this.element[0].id + "_printImage",
                "src": url,
            };
            ej.datavisualization.Diagram.Util.attr(img, attr);
            var div = document.createElement("div");
            div.appendChild(img);

            // specify window parameters
            var PrintWind = window.open('');
            if (PrintWind != null) {
                PrintWind.document.write('<html><head><title></title></head>');
                PrintWind.document.write('<BODY onload="window.print()">');
                PrintWind.document.write("<center>" + div.innerHTML + "</center>");
                PrintWind.document.close();
            }
        },

        /**
*To save the diagram .
*@return jQuery
*@param {Object} 
*@example

*&lt;div id="diagramcontent"&gt;&lt;/div&gt;
*&lt;script&gt;
*var diagram=$("#diagramcontent").ejDiagram("instance");
*diagram.save();
*&lt;/script&gt;
*@memberof ejDiagram
*@instance
*/
        save: function () {
            var drawingTools = this.model.drawingTools;
            var userHandles = this.model.selectedItems.userHandles;
            this.model.drawingTools = null;
            this.model.selectedItems.userHandles = null;
            if (this.nameTable["multipleSelection"]) {
                ej.datavisualization.Diagram.Util.removeItem(this.nodes(), this.nameTable["multipleSelection"]);
            }
            this._updateTableNodes();
            var model = jQuery.extend(true, {}, this.model);
            this.model.drawingTools = drawingTools;
            this.model.selectedItems.userHandles = userHandles;
            return model;
        },

        _updateTableNodes: function () {
            var i = 0, node, connector;
            for (i; i < this.nodes().length; i++) {
                node = this.nameTable[this.nodes()[i].name];
                if (node) {
                    this.nodes()[i] = node;
                    if (node.type == "group") {
                        this._updateTableGroup(node);
                    }
                }
            }
            for (i; i < this.connectors().length; i++) {
                connector = this.nameTable[this.connectors()[i].name];
                if (connector) {
                    this.connectors()[i] = connector;
                }
            }
        },
        _updateTableGroup: function (group) {
            var children = group.children;
            for (var i = 0; i < group.children.length; i++) {
                group.children[i] = this.nameTable[this._getChild(group.children[i])];
                if (group.children[i] && group.children[i].type == "group") {
                    this._updateTableGroup(group.children[i]);
                }
            }
        },

        /**
*To load the diagram .
*@return jQuery 
*@param {Object} 
*@example

*&lt;div id="diagramcontent"&gt;&lt;/div&gt;
*&lt;script&gt;
*var diagram=$("#diagramcontent").ejDiagram("instance");
*diagram.load(data);
*&lt;/script&gt;
*@memberof ejDiagram
*@instance
*/
        load: function (data) {
            this.clear();
            var contextmenu = document.getElementById(this.element[0].id + "_contextMenu");
            if (contextmenu)
                contextmenu.parentNode.removeChild(contextmenu);
            var load = {
                nodes: data.nodes ? data.nodes : [],
                connectors: data.connectors ? data.connectors : [],
                contextMenu: data.contextMenu ? data.contextMenu : {},
                snapSettings: data.snapSettings ? data.snapSettings : {},
                backgroundImage: data.backgroundImage ? data.backgroundImage : null,
                enableAutoScroll: data.enableAutoScroll ? data.enableAutoScroll : true,
                autoScrollMargin: data.autoScrollMargin ? data.autoScrollMargin : 20,
                layout: data.layout ? data.layout : {},
                pageSettings: data.pageSettings ? data.pageSettings : {},
                click: data.click ? data.click : null,
                connectionChange: data.connectionChange ? data.connectionChange : null,
                defaultSettings: data.defaultSettings ? data.defaultSettings : null,
                dataSource: data.dataSource ? data.dataSource : null,
                dataSourceSchema: data.dataSourceSettings ? data.dataSourceSettings : null,
                doubleClick: data.doubleClick ? data.doubleClick : null,
                enableContextMenu: data.enableContextMenu ? data.enableContextMenu : true,
                showTooltip: data.showTooltip ? data.showTooltip : true,
                height: data.height ? data.height : null,
                mouseEnter: data.mouseEnter ? data.mouseEnter : null,
                mouseOver: data.mouseOver ? data.mouseOver : null,
                mouseLeave: data.mouseLeave ? data.mouseLeave : null,
                nodeTemplate: data.nodeTemplate ? data.nodeTemplate : null,
                rotationChange: data.rotationChange ? data.rotationChange : null,
                selectorConstraints: data.selectorConstraints ? data.selectorConstraints : ej.datavisualization.Diagram.SelectorConstraints.All,
                tooltipTemplateId: data.tooltipTemplateId ? data.tooltipTemplateId : null,
                width: data.width ? data.width : null,
                constraints: data.constraints,
                zoomFactor: data.zoomFactor ? data.zoomFactor : 1,
                phases: data.phases ? data.phases : [],
            };
            $("#" + this._id).ejDiagram(load);
        },

        /**
*To arrange the elements on the page in the diagram .
*@return jQuery
*@param {String} 
*@example

*&lt;div id="diagramcontent"&gt;&lt;/div&gt;
*&lt;script&gt;
*var diagram=$("#diagramcontent").ejDiagram("instance");
*diagram.layout();
*&lt;/script&gt;
*@memberof ejDiagram
*@instance
*/

        layout: function () {
            this._setLayout();
        },

        _setLayout: function () {
            //this.model.layout = new ej.datavisualization.Diagram.HierarchicalLayout(this.model.layout);
            this._doLayout();
            ej.datavisualization.Diagram.PageUtil._updatePageSize(this);
            this._clearSelection();
            //this._updateNodes();
            //this._updateConnectors();
        },
        /**
               *Select the target node
               *@return jQuery
               *@param {Object} node pass target node to be updated
               *@example
               *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
               *&lt;script&gt;
               *var diagram=$("#diagramcontent").ejDiagram("instance");
               *var node=diagram.model.nodes[0];
               *diagram.addSelection(node);
               *&lt;/script&gt;
               *@memberof ejDiagram
*@instance
               */
        addSelection: function (node) {
            this._addSelection(node);
        },

        /**
     *update specified node as selected object.
     *@return jQuery
     *@param {String} name  to identify the object from the model 
     *@example
     *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
     *&lt;script&gt;
     *var diagram=$("#diagramcontent").ejDiagram("instance"); 
     *diagram.updateSelectedObject(name);    
     *&lt;/script&gt;
     *@memberof ejDiagram
     *@instance
     */
        updateSelectedObject: function (nodeName) {
            var node = this.nameTable[nodeName];
            if (node) {
                this.activeTool.selectedObject = node;

            }
        },
        /**
        *Update the selection of target node/connector
        *@return jQuery
        *@param {Boolean} isDragging pass true/false whether to drag or not
        *@example
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.updateSelection(true);
        *&lt;/script&gt;
        *@memberof ejDiagram
        *@instance
        */

        updateSelection: function (isDragging) {
            if (ej.datavisualization.Diagram.Util.isPageEditable(this)) {
                this._updateSelectionHandle(isDragging);
            }
        },
        /**
        *To activate registered tool 
        *@return jQuery
        *@param {String} toolName name of the tool to be activated
        *@param {Boolean} singleAction default value set to true tool action to be performed only once
        *@example
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.activateTool("panTool");
                 *&lt;/script&gt;

          *@example
            *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
                 *&lt;script&gt;
                 *var diagram=$("#diagramcontent").ejDiagram("instance");                 
                 *diagram.activateTool("orthogonalTool",false);
                 *&lt;/script&gt;
                 *@memberof ejDiagram
                 *@instance
        */
        activateTool: function (toolName, singleAction) {

            if (this.tools[toolName]) {
                if (this.activeTool instanceof ej.datavisualization.Diagram.LineTool) {
                    this.activeTool._showAllPorts(true);
                }
                this._toolToActivate = toolName;
                this.activeTool = this.tools[this._toolToActivate];
                if (singleAction != undefined)
                    this.activeTool.singleAction = singleAction;
            }
            if (this.activeTool instanceof ej.datavisualization.Diagram.ImageTool && this.activeTool.autoOpenUpload) {
                this.activeTool._showPopup();
            }
            if (this.activeTool instanceof ej.datavisualization.Diagram.PanTool) {
                this._currentCursor = "pointer";
            }
            if (this.activeTool instanceof ej.datavisualization.Diagram.LineTool) {
                if (this.activeTool.singleAction)
                    this.tool(this.tool() | ej.datavisualization.Diagram.Tool.DrawOnce);
                else
                    this.tool(this.tool() | ej.datavisualization.Diagram.Tool.ContinuesDraw);
                this.activeTool._showAllPorts();
            }
            this._drawingTool = true;
        },
        /**
       *Deactivate the current activated tool
       *@return jQuery
       *@example
       *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
       *&lt;script&gt;
       *var diagram=$("#diagramcontent").ejDiagram("instance");
       *diagram.deactivateTool();
       *&lt;/script&gt;
       *@memberof ejDiagram
       *@instance
       */
        deactivateTool: function () {
            if (this.activeTool instanceof ej.datavisualization.Diagram.LineTool) {
                this.activeTool._showAllPorts(true);
            }
            if (this.tool() & ej.datavisualization.Diagram.Tool.DrawOnce)
                this.tool(this.tool() ^ ej.datavisualization.Diagram.Tool.DrawOnce);
            if (this.tool() & ej.datavisualization.Diagram.Tool.ContinuesDraw)
                this.tool(this.tool() ^ ej.datavisualization.Diagram.Tool.ContinuesDraw);
            if (this.tool() & ej.datavisualization.Diagram.Tool.ZoomPan) {
                this._toolToActivate = "panTool";
                this.activeTool = this.tools[this._toolToActivate];
                this.activeTool._mousedown = false;
                this._currentCursor = "pointer";
            }
            else {
                this._toolToActivate = "select";
                this.activeTool = this.tools[this._toolToActivate];
            }
        },

        /**
                    *Update the given label style
                    *@return jQuery
                    *@param {String} nodeName pass the name of node/connector
                    *@param {Object} label pass the label to be modified
                    *@param {Object} obj pass the new porperties of the label
                    *@example
                    
                    *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
                    *&lt;script&gt;
                    *var diagram=$("#diagramcontent").ejDiagram("instance");
                    *var node=diagram.selectionList[0];
                    *var label = [];
                    *label =[{"name":"node1" "text": "node", "bold": true, "italic": true}]
                    *diagram.updateLabel(node.name,node.labels[0],label);
                    *&lt;/script&gt;
                    *@memberof ejDiagram
*@instance
                    */
        updateLabel: function (nodeName, label, obj) {
            if (nodeName && ej.datavisualization.Diagram.Util.isPageEditable(this)) {
                var mNode = this._findNode(nodeName);
                if (!mNode)
                    mNode = this._findConnector(nodeName);
                if (obj && label && !obj.name || label.name == obj.name) {
                    if (mNode) {
                        for (var prop in obj)
                            if (label.hasOwnProperty(prop)) {
                                label[prop] = obj[prop];
                            }
                        if (mNode.segments || (mNode.shape && mNode.shape.type !== "text")) {
                            ej.datavisualization.Diagram.DiagramContext.updateLabelStyle(mNode, label, this);
                            ej.datavisualization.Diagram.DiagramContext.updateLabel(mNode, label, this);
                        } else if (mNode.shape && mNode.shape.type === "text") {
                            ej.datavisualization.Diagram.DiagramContext.updateTextBlock(mNode, label, this);
                        }
                    }
                    if (obj.mode === ej.datavisualization.Diagram.LabelEditMode.Edit) {
                        this.startLabelEdit(mNode, label);
                    }
                }
            }
        },
        /**
                    *Starts the editing of the specified label in the given node
                    *@return jQuery
                    *@param {Object} node pass the node/connector to which label to be edited
                      *@param {Object} label pass the label to be edited
                    *@example
                    
                    *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
                    *&lt;script&gt;
                    *var diagram=$("#diagramcontent").ejDiagram("instance");
                    *var node=diagram.selectionList[0];
                    *diagram.startLabelEdit(node,node.labels[0]);
                    *&lt;/script&gt;
                    *@memberof ejDiagram
                    *@instance
                    */
        startLabelEdit: function (node, label) {
            if (node) {
                //Disables the edit mode of labels in the selectionList
                for (var i = 0; i < this.selectionList.length; i++) {
                    var mNode = this.selectionList[i];
                    if (mNode !== node && typeof mNode.labels.length != "undefined") {
                        for (var j = 0; j < mNode.labels.length; j++)
                            mNode.labels[j].mode = ej.datavisualization.Diagram.LabelEditMode.View;
                    }
                }
                if (!label && node.shape.type === "text")
                    label = node.shape.textBlock;
                if (this._setLabelEditing(label))
                    this._startEdit(node);
                else {
                    this._endEdit();
                }
            }
        },

        _setSelectorConstraints: function (constraints) {
            this.model.selectedItems.constraints = constraints;
            if (this.selectionList[0]) {
                ej.datavisualization.Diagram.SvgContext.clearSelector(this._svg, this._adornerLayer);
                ej.datavisualization.Diagram.SvgContext.renderSelector(this.selectionList[0], this._svg, this._adornerLayer, this._currZoom, constraints);
                if (this.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles)
                    ej.datavisualization.Diagram.SvgContext.renderUserHandles(this.model.selectedItems.userHandles, this.selectionList[0], this._svg, this.selectionList[0].type == "pseudoGroup",
                        this._currZoom, this._adornerLayer);
            }
        },
        /**
        *Group the selected node and connector
        *@return jQuery
        *@example
       
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.group(); 
        *&lt;/script&gt;
        *@memberof ejDiagram
        *@instance
        */
        group: function () {
            if (this.selectionList[0] && this.selectionList[0].type == "pseudoGroup") {
                var selectionList = [];
                var i;
                for (i = 0; i < this.selectionList[0].children.length; i++)
                    selectionList.push(this.nameTable[this.selectionList[0].children[i]]);
                this._sortByZIndex(selectionList, true);
                var element;
                var groupName = ej.datavisualization.Diagram.Util.randomId();
                var group = new ej.datavisualization.Diagram.Group({ name: groupName, });
                this._clearSelection();
                for (i = 0; i < selectionList.length; i++) {
                    this._isUndo = true;
                    group.children.push(selectionList[i].name);
                    selectionList[i].parent = groupName;
                    ej.datavisualization.Diagram.Util.removeItem(this.selectionList, selectionList[i].name);
                    if (!selectionList[i].segments) ej.datavisualization.Diagram.Util.removeItem(this.nodes(), this.nameTable[selectionList[i].name]);
                    else ej.datavisualization.Diagram.Util.removeItem(this.connectors(), this.nameTable[selectionList[i].name]);
                    ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(this._spatialSearch, this._spatialSearch.quadTable[selectionList[i].name], selectionList[i]);
                    if (ej.browserInfo().name === "msie") {
                        if (selectionList[i].shape && selectionList[i].shape.type == "html") {
                            element = document.getElementById(selectionList[i].name + "_parentdiv");
                            element.parentNode.removeChild(element);
                        }
                        else {
                            if (selectionList[i].type == "group")
                                this._checkForHtmlNode(selectionList[i]);
                        }
                    }
                    // $("#" + selectionList[i].name)[0].parentNode.removeChild($("#" + selectionList[i].name)[0]);
                    element = this._svg.document.getElementById(selectionList[i].name);
                    element.parentNode.removeChild(element);
                }
                ej.datavisualization.Diagram.Util.clear(this.selectionList);
                group = this._getNewGroup(group);
                this.add(group);
                this._addSelection(group);
                var entry = { type: "groupchanged", object: group, actionType: "group" };
                this.addHistoryEntry(entry);
                //var entry = new ej.datavisualization.Diagram.HistoryEntry(new ej.datavisualization.Diagram.GroupHandleCmd(group, "group"));
                //this.historyManager.addHistoryEntry(entry);
                this._isUndo = false;
            }
        },

        _checkForHtmlNode: function (group) {
            var children = this._getChildren(group.children);
            for (var i = 0; i < children.length; i++) {
                var child = this.nameTable[children[i]];
                if (child) {
                    if (child.type == "group") {
                        this._checkForHtmlNode(child);
                    } else {
                        if (child.shape && child.shape.type == "html") {
                            var element = document.getElementById(child.name + "_parentdiv");
                            element.parentNode.removeChild(element);
                        }
                    }
                }
            }
        },
        _removeChildren: function (group, args) {
            var children = this._getChildren(group.children);
            for (var i = 0; i < children.length; i++) {
                var child = this.nameTable[children[i]];
                if (child) {
                    if (group.isLane) {
                        this._disConnect(child, args);
                        this._removeConnector(child, args);
                    }
                    else
                        this._disConnect(child, args, true);
                    ej.datavisualization.Diagram.Util.removeItem(this.nodes(), child);
                    if (child.type == "group") {
                        this._removeChildren(child, args);
                    } else {
                        ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(this._spatialSearch, this._spatialSearch.quadTable[child.name], child);
                        ej.datavisualization.Diagram.SpatialUtil._updateBounds(this, this._spatialSearch, child);
                        delete this.nameTable[child.name];
                    }
                }
            }
        },
        /**
*Ungroup the selected group
*@return jQuery
*@example

*&lt;div id="diagramcontent"&gt;&lt;/div&gt;
*&lt;script&gt;
*var diagram=$("#diagramcontent").ejDiagram("instance");
*diagram.ungroup(); 
*&lt;/script&gt;
*@memberof ejDiagram
*@instance
*/
        ungroup: function () {
            if (this.selectionList[0] && this.selectionList[0].type == "group" && !(this.selectionList[0].isSwimlane || this.selectionList[0].isLane)) {
                this._isUndo = true;
                var selectionList = this.selectionList[0].children;
                var i, node;
                node = this.selectionList[0];
                $("#" + this.selectionList[0].name)[0].parentNode.removeChild($("#" + this.selectionList[0].name)[0]);
                if ($("#" + this.selectionList[0].name)[0])
                    $("#" + this.selectionList[0].name)[0].parentNode.removeChild($("#" + this.selectionList[0].name)[0]);
                if (ej.browserInfo().name === "msie")
                    this._checkForHtmlNode(this.selectionList[0]);
                this._clearSelection();
                var object;
                ej.datavisualization.Diagram.Util.clear(this.selectionList);
                for (i = 0; i < selectionList.length; i++) {
                    var item = this.nameTable[selectionList[i]];
                    if (item) {
                        if (item.parent)
                            item.parent = null;
                        if (item.segments) {
                            object = item;
                            object.parent = "";
                            this._updateEdges(object);
                            this._dock(object, this.nameTable);
                            ej.datavisualization.Diagram.DiagramContext.renderConnector(object, this);
                            this.connectors().push(object);
                        }
                        else {
                            object = item;
                            object.parent = "";
                            if (object.type == "group") {
                                this._updateChildrenEdges(object);
                                if (object.isLane || object.isSwimlane) {
                                    object.width = 0;
                                    object.height = 0;
                                }
                                ej.datavisualization.Diagram.DiagramContext.renderGroup(object, this);
                            }
                            else
                                ej.datavisualization.Diagram.DiagramContext.renderNode(object, this);
                            this.nodes().push(object);
                        }
                    }

                }
                //this._clearSelection();
                ej.datavisualization.Diagram.Util.removeItem(this.nodes(), this._findNode(node.name));

                var entry = { type: "groupchanged", object: node, actionType: "ungroup" };
                this.addHistoryEntry(entry);

                //var entry = new ej.datavisualization.Diagram.HistoryEntry(new ej.datavisualization.Diagram.GroupHandleCmd(node, "ungroup"));
                //this.historyManager.addHistoryEntry(entry);
                this._isUndo = false;

            }
        },


        /**
       *Executes nudge command tp move selected node/connector one pixel 
       *@return jQuery
       *@param {String} direction  specify the driection to move the selected objects ("left","right",top","bottom")
       *@example
       *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
       *&lt;script&gt;
       *var diagram=$("#diagramcontent").ejDiagram("instance");
       *diagram.nudge("direction"); 
       *&lt;/script&gt;
       *@memberof ejDiagram
       *@instance
       */

        nudge: function (direction, nudgeDelta) {
            nudgeDelta = !nudgeDelta ? 1 : nudgeDelta;
            var dir = { up: { x: 0, y: -nudgeDelta }, down: { x: 0, y: nudgeDelta }, left: { x: -nudgeDelta, y: 0 }, right: { x: nudgeDelta, y: 0 } };
            var nudge = dir[direction];
            if (nudge && this.selectionList[0]) {
                this._nudge(this.selectionList[0], nudge.x, nudge.y);
            }
        },

        /**
              *Select all nodes and connector in diagram
              *@return jQuery
              *@example
             
              *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
              *&lt;script&gt;
              *var diagram=$("#diagramcontent").ejDiagram("instance");
              *diagram.selectAll(); 
              *&lt;/script&gt;
              *@memberof ejDiagram
              *@instance
              */
        selectAll: function () {
            var collection, nodes, i, len, item = null;
            this._clearSelection();
            collection = ej.datavisualization.Diagram.Group({ type: "pseudoGroup", name: "multipleSelection" });
            nodes = this.nodes();
            for (i = 0, len = nodes.length; i < len; i++) {
                if (ej.datavisualization.Diagram.Util.canSelect(nodes[i])) {
                    item = this.nameTable[nodes[i].name];
                    if (item && item.parent == "") {
                        collection.children.push(item.name);
                    }
                }
            }
            var connectors = this.connectors();
            for (i = 0, len = connectors.length; i < len; i++) {
                if (ej.datavisualization.Diagram.Util.canSelect(connectors[i])) {
                    if (connectors[i].parent == "") {
                        collection.children.push(connectors[i].name);
                    }
                }
            }
            ej.datavisualization.Diagram.Util._updateGroupBounds(collection, this);
            //ej.datavisualization.Diagram.Util.clear(this.selectionList);
            this.nodes().push(collection);
            this.nameTable[collection.name] = collection;
            if (collection.children.length > 0)
                this._addSelection(collection);
        },
        /**
        *Align selected object based on reference object and direction
        *@return jQuery
        *@param {String} direction To specify the driection for alignment ("left","right",top","bottom")
        *@example
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.align("left"); 
        *&lt;/script&gt;
        *@memberof ejDiagram
        *@instance
        */
        align: function (direction) {
            if (this.selectionList[0] && this.selectionList[0].type == "pseudoGroup" && this.selectionList[0].children && this.selectionList[0].children.length > 0) {
                var list = this.nameTable[this.selectionList[0].name].children;
                var cNode;
                if (direction === "left")
                    cNode = this._findCornerNodes().left;
                else if (direction === "right")
                    cNode = this._findCornerNodes().right;
                else if (direction === "top")
                    cNode = this._findCornerNodes().top;
                else if (direction === "bottom")
                    cNode = this._findCornerNodes().bottom;
                var cNodeBounds;
                if (cNode)
                    cNodeBounds = ej.datavisualization.Diagram.Util.bounds(cNode);
                else if (direction === "center" || direction === "middle") {
                    cNodeBounds = ej.datavisualization.Diagram.Util.bounds(this.selectionList[0]);
                }
                if (cNodeBounds) {
                    var i, bounds, node, x = 0, y = 0;
                    for (i = 0; i < list.length; i++) {
                        node = this.nameTable[list[i]];
                        bounds = ej.datavisualization.Diagram.Util.bounds(node);
                        if (direction === "left")
                            x = -(bounds.x - cNodeBounds.x);
                        else if (direction === "right")
                            x = -((bounds.x + bounds.width) - (cNodeBounds.x + cNodeBounds.width));
                        else if (direction === "top")
                            y = -(bounds.y - cNodeBounds.y);
                        else if (direction === "bottom")
                            y = -((bounds.y + bounds.height) - (cNodeBounds.y + cNodeBounds.height));
                        else if (direction === "center")
                            x = -((bounds.x + bounds.width / 2) - (cNodeBounds.x + cNodeBounds.width / 2));
                        else if (direction === "middle")
                            y = -((bounds.y + bounds.height / 2) - (cNodeBounds.y + cNodeBounds.height / 2));
                        this._moveNode(x, y, node);
                    }
                    ej.datavisualization.Diagram.Util._updateGroupBounds(this.selectionList[0], this);
                    ej.datavisualization.Diagram.SvgContext.updateSelector(this.selectionList[0], this._svg, this._currZoom, this, this.model.selectedItems.constraints);
                }
            }
        },
        /**
        *Update size of the object in the selection list to the size of first object in selction list 
        *@return jQuery
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.sameSize(); 
        *&lt;/script&gt;
        *@memberof ejDiagram
        *@instance
        */
        sameSize: function () {
            if (this.selectionList[0] && this.selectionList[0].type == "pseudoGroup" && this.selectionList[0].children && this.selectionList[0].children.length > 0) {
                var list = this.nameTable[this.selectionList[0].name].children;
                var fNode = this.nameTable[this.selectionList[0].children[0]];
                var fNodeBounds = ej.datavisualization.Diagram.Util.bounds(fNode);
                for (var i = 0; i < list.length; i++) {
                    var element = this.nameTable[list[i]];
                    if (!(element.segments)) {
                        element.height = fNodeBounds.height;
                        element.width = fNodeBounds.width;
                        this._updateQuad(this, element);
                        ej.datavisualization.Diagram.DiagramContext.update(element, this);
                    }
                }
                ej.datavisualization.Diagram.Util._updateGroupBounds(this.selectionList[0], this);
                ej.datavisualization.Diagram.SvgContext.updateSelector(this.selectionList[0], this._svg, this._currZoom, this, this.model.selectedItems.constraints);
            }
        },
        /**
        *Update height of the object in the selection list to the height of first object in selection list 
        *@return jQuery
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.sameHeight(); 
        *&lt;/script&gt;
        *@memberof ejDiagram
*@instance
        */
        sameHeight: function () {
            if (this.selectionList[0] && this.selectionList[0].type == "pseudoGroup" && this.selectionList[0].children && this.selectionList[0].children.length > 0) {
                var list = this.nameTable[this.selectionList[0].name].children;
                var fNode = this.nameTable[this.selectionList[0].children[0]];
                var fNodeBounds = ej.datavisualization.Diagram.Util.bounds(fNode);
                for (var i = 0; i < list.length; i++) {
                    var element = this.nameTable[list[i]];
                    if (!(element.segments)) {
                        element.height = fNodeBounds.height;
                        this._updateQuad(this, element);
                        ej.datavisualization.Diagram.DiagramContext.update(element, this);
                    }
                }
                ej.datavisualization.Diagram.Util._updateGroupBounds(this.selectionList[0], this);
                ej.datavisualization.Diagram.SvgContext.updateSelector(this.selectionList[0], this._svg, this._currZoom, this, this.model.selectedItems.constraints);
            }
        },
        /**
        *Update width of the object in the selection list to the width of first object in selection list 
        *@return jQuery
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.sameWidth(); 
        *&lt;/script&gt;
        *@memberof ejDiagram
*@instance
        */
        sameWidth: function () {
            if (this.selectionList[0] && this.selectionList[0].type == "pseudoGroup" && this.selectionList[0].children && this.selectionList[0].children.length > 0) {
                var list = this.nameTable[this.selectionList[0].name].children;
                var fNode = this.nameTable[this.selectionList[0].children[0]];
                var fNodeBounds = ej.datavisualization.Diagram.Util.bounds(fNode);
                for (var i = 0; i < list.length; i++) {
                    var element = this.nameTable[list[i]];
                    if (!(element.segments)) {
                        element.width = fNodeBounds.width;
                        this._updateQuad(this, element);
                        ej.datavisualization.Diagram.DiagramContext.update(element, this);
                    }
                }
                ej.datavisualization.Diagram.Util._updateGroupBounds(this.selectionList[0], this);
                ej.datavisualization.Diagram.SvgContext.updateSelector(this.selectionList[0], this._svg, this._currZoom, this, this.model.selectedItems.constraints);
            }
        },
        /**
        *Update vertical space between the object is set with selection boundary
        *@return jQuery
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.spaceDown(); 
        *&lt;/script&gt;
        *@memberof ejDiagram
*@instance
        */
        spaceDown: function () {
            if (this.selectionList[0] && this.selectionList[0].type == "pseudoGroup") {
                var lstSelections = this.selectionList[0].children;
                this._sortByYvalue(this.selectionList[0].children);
                var selectionCount = lstSelections.length, fSpacing;
                if (lstSelections && selectionCount > 2) {
                    var cornerNodes = this._findCornerNodes();
                    var firstNode = cornerNodes.top;
                    var lastNode = cornerNodes.bottom;
                    if (firstNode && lastNode) {
                        var bFirst = ej.datavisualization.Diagram.Util.bounds(firstNode);
                        var bLast = ej.datavisualization.Diagram.Util.bounds(lastNode);
                        fSpacing = (bLast.y - bFirst.y) / (selectionCount - 1);
                        var y = 1;
                        for (var i = 0; i < lstSelections.length; i++) {
                            var inode = this.nameTable[lstSelections[i]];
                            if (inode !== firstNode && inode !== lastNode) {
                                if (!inode.segments) {
                                    inode.offsetY = bFirst.y + (y * fSpacing) + (inode.height / 2);
                                }
                                else {
                                    var dify;
                                    var inodes = ej.datavisualization.Diagram.Util.bounds(inode);
                                    dify = (bFirst.y + (y * fSpacing)) - (inodes.y);
                                    this._translate(inode, 0, dify, this.nameTable);
                                }
                                this._updateQuad(this, inode);
                                y += 1;
                                this._updateNodeMargin(inode);
                                ej.datavisualization.Diagram.DiagramContext.update(inode, this);
                            }
                        }
                    }
                }
            }
        },
        /**
        *Update horizontal space between the object is set with selection boundary
        *@return jQuery
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.spaceAcross(); 
        *&lt;/script&gt;
        *@memberof ejDiagram
*@instance
        */
        spaceAcross: function () {
            if (this.selectionList[0] && this.selectionList[0].type == "pseudoGroup") {
                var lstSelections = this.selectionList[0].children;
                this._sortByXvalue(this.selectionList[0].children);
                var selectionCount = lstSelections.length, fSpacing;
                if (lstSelections && selectionCount > 2) {
                    var cornerNodes = this._findCornerNodes();
                    var firstNode = cornerNodes.left;
                    var lastNode = cornerNodes.right;
                    if (firstNode && lastNode) {
                        var bFirst = ej.datavisualization.Diagram.Util.bounds(firstNode);
                        var bLast = ej.datavisualization.Diagram.Util.bounds(lastNode);
                        fSpacing = (bLast.x - bFirst.x) / (selectionCount - 1);
                        var x = 1;
                        for (var i = 0; i < lstSelections.length; i++) {
                            var inode = this.nameTable[lstSelections[i]];
                            if (inode !== firstNode && inode !== lastNode) {
                                if (!inode.segments) {
                                    inode.offsetX = bFirst.x + (x * fSpacing) + (inode.width / 2);
                                }
                                else {
                                    var difx;
                                    var inodes = ej.datavisualization.Diagram.Util.bounds(inode);
                                    difx = (bFirst.x + (x * fSpacing)) - (inodes.x);
                                    this._translate(inode, difx, 0, this.nameTable);
                                }
                                this._updateQuad(this, inode);
                                x += 1;
                                this._updateNodeMargin(inode);
                                ej.datavisualization.Diagram.DiagramContext.update(inode, this);
                            }
                        }
                    }
                }
            }
        },
        /**
        *Decrease the Z-index value of selected object by 1
        *@return jQuery
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.sendBackward(); 
        *&lt;/script&gt;
        *@memberof ejDiagram
*@instance
        */
        sendBackward: function () {
            var ovarLapNodes, i;
            var prevNode;
            if (this.selectionList[0] && this.selectionList[0].type != "pseudoGroup") {
                var node = this.selectionList[0];
                if (node) {
                    ovarLapNodes = this._findOverlapNode(node);
                    this._sortByZIndex(ovarLapNodes);
                    for (var k = 0; k < ovarLapNodes.length; k++)
                        if (node.zOrder > ovarLapNodes[k].zOrder) {
                            prevNode = ovarLapNodes[k];
                            break;
                        }
                    var start = node.zOrder;
                    if (prevNode) {
                        var end = prevNode.zOrder;
                        for (i = end; i < start; i++) {
                            if (node.parent != "")
                                this._findObjectByIndex(i, true).zOrder += 1;
                            else
                                this._findObjectByIndex(i).zOrder += 1;
                        }
                        if (node.parent != "") {
                            if (node.parent) {
                                var parent = this.nameTable[node.parent];
                                this._findChildren(parent, node.name).zOrder = end;
                            }
                        } else
                            this._findObjectByName(node.name).zOrder = end;
                        this._svg.getElementById(prevNode.name).parentNode.insertBefore(this._svg.getElementById(node.name), this._svg.getElementById(prevNode.name));
                        ej.datavisualization.Diagram.SvgContext.renderSelector(node, this._svg, this._adornerLayer, this._currZoom,
                        this.model.selectedItems.constraints);
                    }
                }
            }
        },
        /**
               *Increase the Z-index value of selected object by 1
               *@return jQuery
               *@example
              
               *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
               *&lt;script&gt;
               *var diagram=$("#diagramcontent").ejDiagram("instance");
               *diagram.moveForward(); 
               *&lt;/script&gt;
               *@memberof ejDiagram
*@instance
               */
        moveForward: function () {
            var ovarLapNodes, i;
            var prevNode;
            if (this.selectionList[0] && this.selectionList[0].type != "pseudoGroup") {
                var node = this.selectionList[0];
                if (node) {
                    ovarLapNodes = this._findOverlapNode(node);
                    this._sortByZIndex(ovarLapNodes);
                    for (var k = ovarLapNodes.length - 1; k >= 0; k--)
                        if (node.zOrder < ovarLapNodes[k].zOrder) {
                            prevNode = ovarLapNodes[k];
                            break;
                        }

                    var start = node.zOrder;
                    if (prevNode) {
                        var end = prevNode.zOrder;
                        for (i = end; i > start; i--) {
                            if (node.parent != "")
                                this._findObjectByIndex(i, true).zOrder -= 1;
                            else
                                this._findObjectByIndex(i).zOrder -= 1;
                        }
                        if (node.parent != "") {
                            if (node.parent) {
                                var parent = this.nameTable[node.parent];
                                this._findChildren(parent, node.name).zOrder = end;
                            }
                        }
                        else
                            this._findObjectByName(node.name).zOrder = end;
                        this._svg.getElementById(prevNode.name).parentNode.insertBefore(this._svg.getElementById(node.name), this._svg.getElementById(prevNode.name).nextSibling);
                        ej.datavisualization.Diagram.SvgContext.renderSelector(node, this._svg, this._adornerLayer, this._currZoom,
                        this.model.selectedItems.constraints);

                    }
                }
            }
        },
        /**
        *Move the selected object behind other object
        *@return jQuery
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.sendToBack(); 
        *&lt;/script&gt;
        *@memberof ejDiagram
*@instance
        */
        sendToBack: function () {
            var node = this.selectionList[0];
            var prevNode;
            if (node && node.type != "pseudoGroup") {
                var ovarLapNodes = this._findOverlapNode(node);
                var nodes = this._sortByZIndex(ovarLapNodes);
                var start = node.zOrder;
                var end = node.zOrder;
                for (var i = 0; i < nodes.length; i++) {
                    if (nodes[i].zOrder < end) {
                        end = nodes[i].zOrder;
                        prevNode = nodes[i];
                    }
                }
                if (prevNode) {
                    for (i = end; i < start; i++) {
                        if (node.parent != "")
                            this._findObjectByIndex(i, true).zOrder += 1;
                        else
                            this._findObjectByIndex(i).zOrder += 1;
                    }
                    if (node.parent != "") {
                        if (node.parent) {
                            var parent = this.nameTable[node.parent];
                            this._findChildren(parent, node.name).zOrder = end;
                        }
                    } else
                        this._findObjectByName(node.name).zOrder = end;
                    this._svg.getElementById(prevNode.name).parentNode.insertBefore(this._svg.getElementById(node.name), this._svg.getElementById(prevNode.name));
                    ej.datavisualization.Diagram.SvgContext.renderSelector(node, this._svg, this._adornerLayer, this._currZoom,
                        this.model.selectedItems.constraints);
                }
            }
        },
        /**
        *Move the selected object over other object
        *@return jQuery
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.bringToFront(); 
        *&lt;/script&gt;
        *@memberof ejDiagram
*@instance
        */

        bringToFront: function () {
            var node = this.selectionList[0];
            var prevNode;
            if (node && node.type != "pseudoGroup") {
                var ovarLapNodes = this._findOverlapNode(node);
                var nodes = this._sortByZIndex(ovarLapNodes);
                var start = node.zOrder;
                var end = node.zOrder;
                for (var i = 0; i < nodes.length; i++) {
                    if (nodes[i].zOrder > end) {
                        end = nodes[i].zOrder;
                        prevNode = nodes[i];
                    }
                }
                if (prevNode) {
                    for (i = 0; i < nodes.length; i++) {
                        if (nodes[i].zOrder > start) {
                            nodes[i].zOrder -= 1;
                        }
                    }
                    if (node.parent) {
                        var parent = this.nameTable[node.parent];
                        this._findChildren(parent, node.name).zOrder = end;
                    } else
                        this._findObjectByName(node.name).zOrder = end;

                    this._svg.getElementById(prevNode.name).parentNode.insertBefore(this._svg.getElementById(node.name), this._svg.getElementById(prevNode.name).nextSibling);
                    ej.datavisualization.Diagram.SvgContext.renderSelector(node, this._svg, this._adornerLayer, this._currZoom,
                        this.model.selectedItems.constraints);
                }
            }
        },
        /**
        *Reverse the last action thta was performed
        *@return jQuery
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.undo(); 
        *&lt;/script&gt;
        *@memberof ejDiagram
*@instance
        */
        undo: function () {
            if (ej.datavisualization.Diagram.Util.isPageEditable(this) && ej.datavisualization.Diagram.Util.canUndo(this)) {
                var args;
                this._isUndo = true;
                //this.historyManager.undo();
                var entryItem = this.getUndoEntry();
                switch (entryItem && entryItem.type) {
                    case "positionchanged":
                        args = { object: entryItem.undoObject, isMultipleNode: entryItem.isMultipleNode };
                        this._recordPinPointChanged(args);
                        break;
                    case "rotationchanged":
                        args = { object: entryItem.undoObject, isMultipleNode: entryItem.isMultipleNode };
                        this._recordRotationChanged(args);
                        break;
                    case "sizechanged":
                        args = { object: entryItem.undoObject, isMultipleNode: entryItem.isMultipleNode };
                        this._recordSizeChanged(args);
                        break;
                    case "endpointchanged":
                        args = { undoObject: entryItem.undoObject, redoObject: entryItem.redoObject, isMultipleNode: entryItem.isMultipleNode, _isUndo: true };
                        this._recordEndPointChanged(args);
                        break;
                    case "collectionchanged":
                        args = { changeType: entryItem.changeType, childTable: entryItem.childTable, edgeTable: entryItem.edgeTable, isUndo: true, sourcePorts: entryItem.sourcePorts, targetPorts: entryItem.targetPorts };
                        args.object = jQuery.extend(true, {}, entryItem.object);
                        this._recordCollectionChanged(args);
                        break;
                    case "labelchanged":
                        args = { object: entryItem.shape, label: entryItem.previousLabelValue };
                        this._recordLabelChanged(args);
                        break;
                    case "groupchanged":
                        args = { object: entryItem.object, isUndo: true, actionType: entryItem.actionType };
                        this._recordGroupChanged(args);
                        break;
                }

                this._isUndo = false;
            }
        },
        /**
        *Restore the last action thta was performed
        *@return jQuery
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.redo(); 
        *&lt;/script&gt;
        *@memberof ejDiagram
*@instance
        */
        redo: function () {
            this._isUndo = true;
            //this.historyManager.redo();
            var entryItem = this.getRedoEntry();
            switch (entryItem && entryItem.type) {
                case "positionchanged":
                    var args = { object: entryItem.redoObject, isMultipleNode: entryItem.isMultipleNode };
                    this._recordPinPointChanged(args);
                    break;
                case "rotationchanged":
                    args = { object: entryItem.redoObject, isMultipleNode: entryItem.isMultipleNode };
                    this._recordRotationChanged(args);
                    break;
                case "sizechanged":
                    args = { object: entryItem.redoObject, isMultipleNode: entryItem.isMultipleNode };
                    this._recordSizeChanged(args);
                    break;
                case "endpointchanged":
                    args = { undoObject: entryItem.undoObject, redoObject: entryItem.redoObject, isMultipleNode: entryItem.isMultipleNode, _isUndo: false };
                    this._recordEndPointChanged(args);
                case "collectionchanged":
                    args = { changeType: entryItem.changeType, childTable: entryItem.childTable, isUndo: false };
                    args.object = jQuery.extend(true, {}, entryItem.object);
                    this._recordCollectionChanged(args);
                    break;
                case "labelchanged":
                    args = { object: entryItem.shape, label: entryItem.updatedLabelValue };
                    this._recordLabelChanged(args);
                    break;
                case "groupchanged":
                    args = { object: entryItem.object, actionType: entryItem.actionType, isUndo: false };
                    this._recordGroupChanged(args);
                    break;
            }
            this._isUndo = false;
        },

        addHistoryEntry: function (entry) {
            if (this._historyList.currentEntry != null) {
                var cEntry = this._historyList.currentEntry;
                if (cEntry.next) {
                    if (cEntry.previous) {
                        var entry1 = cEntry.next;
                        entry1.previous = null;
                        cEntry.next = entry;
                        entry.previous = cEntry;
                    }
                } else {
                    cEntry.next = entry;
                    entry.previous = cEntry;
                }
            }
            this._historyList.currentEntry = entry;
            this._historyList.canUndo = true;
            this._historyList.canRedo = false;
        },

        clearHistory: function () {
            var hList = this._historyList;
            hList.currentEntry = null;
            hList.canUndo = false;
            hList.canRedo = false;
            this._hScrollbar._scrollData = null;
            this._vScrollbar._scrollData = null;
        },

        getUndoEntry: function () {
            var undoEntry = null;
            var currentEntry;
            var hList = this._historyList;
            if (hList.canUndo) {
                undoEntry = hList.currentEntry;
                currentEntry = hList.currentEntry.previous;
                if (currentEntry) {
                    hList.currentEntry = currentEntry;
                    if (!hList.canRedo)
                        hList.canRedo = true;
                } else {
                    hList.canRedo = true;
                    hList.canUndo = false;
                }
            }
            return undoEntry;
        },

        getRedoEntry: function () {
            var redoEntry = null;
            var entryCurrent;
            var hList = this._historyList;
            if (hList.canRedo) {
                if (!hList.currentEntry.previous && !hList.canUndo) {
                    entryCurrent = hList.currentEntry;
                } else
                    entryCurrent = hList.currentEntry.next;
                if (entryCurrent) {
                    hList.currentEntry = entryCurrent;
                    if (!hList.canUndo)
                        hList.canUndo = true;
                    if (!entryCurrent.next) {
                        hList.canRedo = false;
                        hList.canUndo = true;
                    }
                }
                redoEntry = hList.currentEntry;
            }
            return redoEntry;
        },
        /**
        *cut the selected object from diagram to diagram internal clipboard
        *@return jQuery
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.cut(); 
        *&lt;/script&gt;
        *@memberof ejDiagram
*@instance
        */
        cut: function () {
            this._pasteIndex = 0;
            this._setClipboard();
            this._delete();
        },


        /**
 *Add ports to the node
 *@return jQuery
 *@param {String} name  to identify the object from the model 
 *@example
 
 *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
 *&lt;script&gt;
 *var diagram = $("#diagramcontent").ejDiagram("instance");
 *var port = [{ offset: { x: 0, y: 0.5 }, name: "aport", fillColor: "yellow"}, { offset: { x: 0.5, y: 0.5 }, name: "bport", fillColor: "yellow",  }];
 *diagram.addPorts("Rect1", port);
 *&lt;/script&gt;
 *@memberof ejDiagram
 *@instance
 */
        addPorts: function (name, ports) {
            if (ej.datavisualization.Diagram.Util.isPageEditable(this)) {
                var node = this.nameTable[name];
                if (node && ports) {
                    var port;
                    for (var i = 0; i < ports.length; i++) {
                        port = ej.datavisualization.Diagram.Port(ports[i]);
                        node.ports.push(port);
                        ej.datavisualization.Diagram.DiagramContext.renderPort(node, port, this);
                    }
                }
            }
        },


        /**
        *copy the selected object from internal clipboard
        *@return jQuery
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.copy(); 
        *&lt;/script&gt;
        *@memberof ejDiagram
*@instance
        */

        copy: function () {
            this._pasteIndex = 1;
            if (this.selectionList && this.selectionList.length > 0) {
                this._setClipboard();
            }
        },
        /**
        *paste the selected object from internal clipboard to diagram
        *@return jQuery
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.paste(); 
        *&lt;/script&gt;
        *@memberof ejDiagram
*@instance
        */
        paste: function () {
            //this._isUndo = true; 
            this._paste();
            //this._isUndo = false;
        },

        _setClipboard: function () {
            if (this.selectionList.length > 0) {
                var data, node = this.selectionList[0];
                var childTable = {};
                if (node.type == "group" || node.type == "pseudoGroup") {
                    var temp, i, j;
                    var children = this._getChildren(node.children);
                    for (i = 0; i < children.length; i++) {
                        for (j = i + 1; j < children.length; j++) {
                            var nodei = this.nameTable[children[i]];
                            var nodej = this.nameTable[children[j]];
                            if (nodej && nodei) {
                                if (nodej.zOrder < nodei.zOrder) {
                                    temp = children[i];
                                    children[i] = children[j];
                                    children[j] = temp;
                                }
                            }
                        }
                    }
                    childTable = this._getChildTable(node, childTable);
                }
                childTable[node.name] = node;
                data = $.extend(true, {}, { "childTable": childTable, "node": node });
                if (data.node.segments) {
                    data.node.targetNode = null;
                    data.node.targetPort = null;
                    data.node.sourceNode = null;
                    data.node.sourcePort = null;
                }
                this._preserveHtmlContent(node, data.node);
                if (data.node.children && data.node.children.length > 0) {
                    for (var child in data.childTable) {
                        this._preserveHtmlContent(childTable[child], data.childTable[child]);
                    }
                }
                this._clipboardData = data;

            }
        },

        _preserveHtmlContent: function (node, cloneNode) {
            if (node.shape) {
                if (cloneNode.shape.type === "html") {
                    if (!(typeof (node.shape.html) === 'string'))
                        cloneNode.shape.html = node.shape.html.cloneNode(true);
                }
                else if (cloneNode.shape.type === "native") {
                    cloneNode.shape.content = node.shape.content.cloneNode(true);
                }
            }
        },

        _getChildTable: function (group, childTable) {
            var child, names, name;
            names = this._getChildren(group.children);
            if (names) {
                for (var i = 0; i < names.length; i++) {
                    name = names[i];
                    child = this.nameTable[name];
                    if (child && (child.parent === group.name || group.type == "pseudoGroup")) {
                        var node = childTable[child.name] = $.extend(true, {}, child);
                        if (node.type == "group" || node.type == "pseudoGroup")
                            childTable = this._getChildTable(node, childTable);
                        if (node.inEdges && node.inEdges.length > 0) {
                            for (var e in node.inEdges) {
                                var cCon = this.nameTable[node.inEdges[e]];
                                if (cCon) {
                                    if (childTable[cCon.name])
                                        delete childTable[cCon.name];
                                    childTable[cCon.name] = cCon;
                                }
                            }
                        }
                        if (node.outEdges && node.outEdges.length > 0) {
                            for (var f in node.outEdges) {
                                var cCon = this.nameTable[node.outEdges[f]];
                                if (cCon) {
                                    if (childTable[cCon.name])
                                        delete childTable[cCon.name];
                                    childTable[cCon.name] = cCon;
                                }
                            }
                        }
                    }
                }
            }
            return childTable;
        },

        _paste: function () {
            if (this._clipboardData) {
                var data = this._clipboardData;
                var dx, child;
                data = $.extend(true, {}, { "childTable": data.childTable, "node": data.node });
                this._preserveHtmlContent(this._clipboardData.node, data.node);
                if (data.node.children && data.node.children.length > 0) {
                    for (child in data.childTable) {
                        this._preserveHtmlContent(this._clipboardData.childTable[child], data.childTable[child]);
                    }
                }
                var node = data.node;
                if (!node.container) {
                    if (node.type == "pseudoGroup") {
                        var names = node.children;
                        var pseudoGroup = ej.datavisualization.Diagram.Group({ type: "pseudoGroup", "name": "multipleSelection" });
                        this._isUndo = true;
                        for (var i = 0; i < names.length; i++) {
                            var name = names[i];
                            child = data.childTable[name];
                            if (child && (child.isLane || child.isSwimlane)) {
                                this._pasteSwimlane(child, data, true)
                            }

                            else if (child) {
                                name = name + ej.datavisualization.Diagram.Util.randomId();
                                delete (data.childTable[child.name]);
                                child.name = name;
                                child.parent = "";
                                data.childTable[child.name] = child;
                                this._preserveConnection(data.childTable, child);
                                pseudoGroup.children.push(name);
                                if (child.type == "group") {
                                    this._pasteChildren(data.childTable, child);
                                }
                                dx = this._pasteIndex * 10;
                                this._translate(child, dx, dx, this.nameTable);
                                this.add(child);
                            }
                        }
                        this._clearSelection();
                        this.nodes().push(pseudoGroup);
                        this.nameTable[pseudoGroup.name] = pseudoGroup;
                        ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, this);
                        this._addSelection(pseudoGroup);
                        var childTable = {};
                        childTable = this._getChildTable(this.selectionList[0], childTable);
                        var entry = { type: "collectionchanged", object: jQuery.extend(true, {}, this.selectionList[0]), childTable: jQuery.extend(true, {}, childTable), changeType: "insert" };
                        this.addHistoryEntry(entry);
                        this._isUndo = false;
                    }
                    else {
                        node.name = node.name + ej.datavisualization.Diagram.Util.randomId();
                        node.parent = "";
                        if (node.type == "group") {
                            this._pasteChildren(data.childTable, node);
                        } else if (node.segments) {
                            //this._disConnect(node);
                        } else if (!node.segments) {
                            //@Fix
                            //this._disConnect(node);
                            node.inEdges = [];
                            node.outEdges = [];
                        }

                        dx = this._pasteIndex * 10;
                        if (!node.segments)
                            this._translate(node, dx, dx, this.nameTable);
                        else
                            ej.datavisualization.Diagram.Util._translateLine(node, dx, dx);
                        this.add(node);
                        // ej.datavisualization.Diagram.DiagramContext.update(node, this);
                        //this._clearSelection();
                        //this._addSelection(node);
                    }
                }
                else {
                    node = this._pasteSwimlane(node, data);
                    dx = this._pasteIndex * 10;
                    this._translate(node, dx, dx, this.nameTable);
                    ej.datavisualization.Diagram.DiagramContext.update(node, this);
                    this._clearSelection();
                    this._addSelection(node);
                }
                this._pasteIndex++;
            }
        },

        _pasteSwimlane: function (node, data, mSelection) {
            var name = ej.datavisualization.Diagram.Util.randomId();
            this._cloneSwimlane(node, data, name);
            if (node.isSwimlane) {
                node.width = 0;
                node.height = 0;
                node = this._getNewGroup(node)
                this.add(node);

                ej.datavisualization.Diagram.DiagramContext.update(node, this);
                return node;
            }
            else if (node.isLane) {
                var swimlane = ej.datavisualization.Diagram.SwimLaneHelper._createSwimlane(node, this, data);
                if (swimlane) {
                    swimlane.width = 0;
                    swimlane.height = 0;
                    this.add(swimlane);
                    return swimlane;
                }
            }
        },

        _cloneNode: function (node, data, name) {
            var node = jQuery.extend(true, {}, data.childTable[node]);
            if (node.children && node.children.length > 0) {
                for (var i in node.children) {
                    this._cloneNode(node.children[i], data, name);
                    node.children[i] += name;
                }
            }
            if (node.parent != "")
                node.parent += name;
            if (node.inEdges && node.inEdges.length > 0) {
                for (var e in node.inEdges) {
                    node.inEdges[e] += name;
                }
            }
            if (node.outEdges && node.outEdges.length > 0) {
                for (var e in node.outEdges) {
                    node.outEdges[e] += name;
                }
            }
            node.name += name;
            this.nameTable[node.name] = node;
        },

        _cloneSwimlane: function (node, data, name) {
            node.name += name;
            if (node.children && node.children.length > 0) {
                for (var i in node.children) {
                    this._cloneNode(node.children[i], data, name);
                    node.children[i] += name;
                }
            }
            this.nameTable[node.name] = node;
        },

        _updateChildName: function (node, name) {
            if (node && name) {
                var children = node.children;
                for (var i = 0; i < children.length; i++) {
                    children[i] = children[i] + name;
                }
            }
        },

        _pasteChildren: function (childTable, group) {
            var child, names, name;
            var childNames = [];
            names = group.children;
            for (var i = 0; i < names.length; i++) {
                name = this._getChild(names[i]);
                child = childTable[name];
                if (child) {
                    name = name + ej.datavisualization.Diagram.Util.randomId();
                    delete (childTable[child.name]);
                    child.name = name;
                    childTable[child.name] = child;
                    this._preserveConnection(childTable, child);
                    child.parent = group.name;
                    childNames.push(name);
                    if (child.type == "group") {
                        this._pasteChildren(childTable, child);
                    }
                    this.add(child);
                }
            }
            group.children = childNames;
            this._preserveConnection(childTable, group);
        },

        _preserveConnections: function (childTable, group) {
            var child, names;
            names = this._getChildren(group.children);
            for (var i = 0; i < names.length; i++) {
                child = childTable[names[i]];
                if (child) {
                    this._preserveConnection(childTable, child);
                    if (child.type == "group")
                        this._preserveConnections(childTable, group);
                }
            }
        },

        _preserveConnection: function (childTable, child) {
            var i, connection, len;
            if (!child.segments) {
                len = child.inEdges.length;
                if (len > 0) {
                    for (i = 0; i < len; i++) {
                        connection = childTable[child.inEdges[i]];
                        if (connection) {
                            connection.targetNode = child.name;
                        }
                    }
                    child.inEdges = [];
                }
                len = child.outEdges.length;
                if (len > 0) {
                    for (i = 0; i < child.outEdges.length; i++) {
                        connection = childTable[child.outEdges[i]];
                        if (connection) {
                            connection.sourceNode = child.name;
                        }
                    }
                    child.outEdges = [];
                }
            } else {
                var node;
                if (child.targetNode) {
                    node = childTable[child.targetNode];
                    if (node)
                        node.inEdges.push(child.name);
                    //else
                    //    child.targetNode = null;
                }
                if (child.sourceNode) {
                    node = childTable[child.sourceNode];
                    if (node)
                        node.outEdges.push(child.name);
                    //else
                    //    child.sourceNode = null;
                }
            }
        },

        _expandChildren: function (node) {
            for (var i = 0; i < node.outEdges.length; i++) {
                var conn = this.nameTable[node.outEdges[i]];
                conn.visible = true;
                var target = this.nameTable[conn.targetNode];
                if (target.isExpanded)
                    this._expandChildren(target);
                target.visible = true;
                target.excludeFromLayout = false;
            }
        },

        _collapseChildren: function (node) {
            for (var i = 0; i < node.outEdges.length; i++) {
                var conn = this.nameTable[node.outEdges[i]];
                conn.visible = false;
                var target = this.nameTable[conn.targetNode];
                if (target.isExpanded)
                    this._collapseChildren(target);
                target.visible = false;
                target.excludeFromLayout = true;
            }
        },
        /**
        *Used to zoomIn/zoomOut diagram
        *@return jQuery
        *@param {Object} zoom pass zoom commands of the diagram
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *var zoom =  ej.datavisualization.Diagram.Zoom();
        *zoom.zoomFactor = .1;
        *zoom.zoomCommand = ej.datavisualization.Diagram.ZoomCommand.ZoomIn;
        *diagram.zoomTo(zoom);
        *&lt;/script&gt;
        *@memberof ejDiagram
*@instance
        */
        zoomTo: function (zoom) {
            if (!zoom) {
                zoom = new ej.datavisualization.Diagram.Zoom();
            }
            if (zoom.zoomCommand & ej.datavisualization.Diagram.ZoomCommand.ZoomIn) {
                ej.datavisualization.Diagram.ZoomUtil.zoomPan(this, (1 + zoom.zoomFactor), 0, 0, zoom.focusPoint, true);
            } else {
                ej.datavisualization.Diagram.ZoomUtil.zoomPan(this, (1 / (1 + zoom.zoomFactor)), 0, 0, zoom.focusPoint, true);
            }
        },
        /**
        *Removes either given node/connector or the selected element from diagram
        *@return jQuery
        *@param {Object} node pass node/connector to be removed
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.remove(); 
        *&lt;/script&gt;
        *@memberof ejDiagram
*@instance
        */
        remove: function (node) {
            if (node && this.nameTable[node.name] && ej.datavisualization.Diagram.Util.isPageEditable(this)) {
                this._remove(node);
            }
            else
                this._delete();
        },
        /**
               *Remove all the elements from diagram
               *@return jQuery
               *@example
               
               *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
               *&lt;script&gt;
               *var diagram=$("#diagramcontent").ejDiagram("instance");
               *diagram.clear(); 
               *&lt;/script&gt;
               *@memberof ejDiagram
               *@instance
               */
        clear: function () {
            this._clearSelection();
            var i;
            for (i = this.connectors().length - 1; i >= 0; i--) {
                this._remove(this.connectors()[i]);
            }
            for (i = this.nodes().length - 1; i >= 0; i--) {
                this._remove(this.nodes()[i]);
            }
            this.clearHistory();
            $("#" + this._canvas.id + "_hScrollbar").ejScrollbar({ width: 0 });
            $("#" + this._canvas.id + "_vScrollbar").ejScrollbar({ height: 0 });
        },

        _add: function (node, render, arg) {
            var success = false;
            if (node.length > 0) {
                for (var i = 0; i < node.length; i++) {
                    this.add(node[i]);
                }
            } else {
                if (node.segments) var type = "connector"; else type = "node";
                var args = { changeType: "insert", element: node, cancel: false };
                this._raiseEvent(type + "CollectionChange", args);
                if (!args.cancel) {
                    this._setZorder(node);
                    if (!(node.isLane || node.isSwimlane)) {
                        if (!node.segments) {
                            if (node.type == "group") {
                                node = ej.datavisualization.Diagram.Group(node);
                                this._initGroupNode(node);
                            }
                            else {
                                //if (!(this.activeTool && this.activeTool.name === "textTool"))
                                node = this._getNewNode(node);
                            }
                            success = this.nodes().push(node);
                            this.nameTable[node.name] = node;
                            if (success) {

                                if (node.type == "group") {
                                    this._updateParent(node);
                                    if (node.offsetX == 0 && node.offsetY == 0)
                                        ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);
                                    this._updateChildrenEdges(node);
                                    if (render)
                                        ej.datavisualization.Diagram.DiagramContext.renderGroup(node, this);
                                } else {
                                    ej.datavisualization.Diagram.SpatialUtil._updateQuad(this, this._spatialSearch, node);
                                    if (render) {
                                        var parent = null;
                                        if (node.parent) {
                                            var parent = this._svg.document.getElementById(node.parent)
                                            var parentObj = this.nameTable[node.parent];
                                            if (parentObj) {
                                                parentObj.children.push(node.name);
                                                ej.datavisualization.Diagram.Util._updateGroupBounds(parentObj, this);
                                                ej.datavisualization.Diagram.DiagramContext.update(parentObj, this);
                                            }
                                        }
                                        ej.datavisualization.Diagram.DiagramContext.renderNode(node, this, parent);
                                    }
                                }
                                this.nameTable[node.name] = node;
                                if (render) {
                                    this._clearSelection();
                                    this._addSelection(node);
                                }
                            }
                        }
                        else {
                            node = this._getNewConnector(node);
                            success = this.model.connectors.push(node);
                            if (success) {
                                ej.datavisualization.Diagram.SpatialUtil._updateQuad(this, this._spatialSearch, node);
                                this._updateEdges(node);
                                this._dock(node, this.nameTable);
                                ej.datavisualization.Diagram.Util.updateBridging(node, this);
                                if (!node.parent) {
                                    if (render)
                                        ej.datavisualization.Diagram.DiagramContext.renderConnector(node, this);
                                }
                                this.nameTable[node.name] = node;
                                if (render) {
                                    this._clearSelection();
                                    this._addSelection(node);
                                }
                            }
                        }
                    }
                    else {
                        success = this.nodes().push(node);
                        this.nameTable[node.name] = node;
                        if (success) {
                            if (node.type == "group") {
                                if (render) {
                                    ej.datavisualization.Diagram.DiagramContext.renderGroup(node, this);
                                    this._clearSelection();
                                    this._addSelection(node);
                                }
                            }
                        }
                    }
                }
            }
            if (!this._isUndo && !this._selectedSymbol) {
                if (node.parent == "") {
                    var childTable = {};
                    if (this.selectionList && this.selectionList.length > 0)
                        childTable = this._getChildTable(this.selectionList[0], childTable);
                    var entry = { type: "collectionchanged", object: jQuery.extend(true, {}, node), childTable: jQuery.extend(true, {}, childTable), changeType: "insert" };
                    this.addHistoryEntry(entry);
                }
            }
            return success;
        },
        /**
              *Add node/connector
              *@return jQuery
              *@param {Object} node pass node/connector to be added
              *@example
              
              *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
              *&lt;script&gt;
              *var diagram=$("#diagramcontent").ejDiagram("instance");
              *var node = [];
              *node=[{ name: "node", width: 175, height: 60, offsetX: 400, offsetY: 60, shape: { type: "Rectangle"}];
              *diagram.add(node);
              *&lt;/script&gt;
              *@memberof ejDiagram
              *@instance
              */
        add: function (node, args) {
            if (ej.datavisualization.Diagram.Util.isPageEditable(this)) {
                return this._add(node, true, args);
            }
        },
        /**
           *Update userhandles of given node
           *@return jQuery
            *@param {Object} node pass node/connector 
           *@example
          
           *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
           *&lt;script&gt;
           *var diagram=$("#diagramcontent").ejDiagram("instance");
           * var node = diagram.selectionList[0];
           * diagram.updateUSerHandles(node); 
           *&lt;/script&gt;
           *@memberof ejDiagram
*@instance
           */
        updateUserHandles: function (node) {
            ej.datavisualization.Diagram.SvgContext.updateUserHandles(this.model.selectedItems.userHandles, node, this._svg, false, false, this._currZoom);
        },
        /**
           *Update offsetX of given node
           *@return jQuery
            *@param {Object} node pass node/connector to be added
           *@example
          
           *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
           *&lt;script&gt;
           *var diagram=$("#diagramcontent").ejDiagram("instance");
           * var node = diagram.selectionList[0];
           * diagram.scrollToNode(node); 
           *&lt;/script&gt;
           *@memberof ejDiagram
*@instance
           */
        scrollToNode: function (node) {
            var nodeX, nodeY;
            var curZoomfactor = this._currZoom;
            var elementBounds = this.element[0].getBoundingClientRect();
            var nodeBounds = ej.datavisualization.Diagram.Util.bounds(node);
            nodeX = (nodeBounds.x + nodeBounds.width / 2) * curZoomfactor;
            nodeY = (nodeBounds.y + nodeBounds.height / 2) * curZoomfactor;
            var hScrollOffset = this._hScrollOffset, vScrollOffset = this._vScrollOffset;
            if (elementBounds.width + this._hScrollOffset < nodeX + nodeBounds.width / 2) {
                hScrollOffset = (nodeX + (nodeBounds.width * curZoomfactor) - elementBounds.width);
            }
            if (elementBounds.height + this._vScrollOffset < nodeY + nodeBounds.height / 2) {
                vScrollOffset = (nodeY + (nodeBounds.height * curZoomfactor) - elementBounds.height);
            }
            this._updateScrollOffset(hScrollOffset, vScrollOffset);
        },

        findNode: function (id) {
            return this._findNode(id);
        },
        //#endregion

        //#region support methods

        _getElementType: function (element) {
            if (element) {
                if (element.isSwimlane)
                    return "swimlane";
                else if (element.type == "group")
                    return "group";
                else if (element.segments)
                    return "connector";
                else if (element.shape)
                    return "node";
                else return null;
            }
            return null;
        },

        _registerDrawingTools: function () {
            for (var toolname in this.model.drawingTools) {
                var tool = this.model.drawingTools[toolname];
                tool.diagram = this;
                this.tools[tool.name] = tool;
            }
        },

        _sortByXvalue: function (nodes) {
            var temp, i, j;
            var fNode, lNode;
            for (i = 0; i < nodes.length; i++) {
                for (j = i + 1; j < nodes.length; j++) {
                    var nodei = this.nameTable[nodes[i]];
                    var nodej = this.nameTable[nodes[j]];
                    fNode = ej.datavisualization.Diagram.Util.bounds(nodei);
                    lNode = ej.datavisualization.Diagram.Util.bounds(nodej);
                    if (fNode.x > lNode.x) {
                        temp = nodes[i];
                        nodes[i] = nodes[j];
                        nodes[j] = temp;
                    }
                }
            }
            return nodes;
        },

        _sortByYvalue: function (nodes) {
            var temp, i, j;
            var fNode, lNode;
            for (i = 0; i < nodes.length; i++) {
                for (j = i + 1; j < nodes.length; j++) {
                    var nodei = this.nameTable[nodes[i]];
                    var nodej = this.nameTable[nodes[j]];
                    fNode = ej.datavisualization.Diagram.Util.bounds(nodei);
                    lNode = ej.datavisualization.Diagram.Util.bounds(nodej);
                    if (fNode.y > lNode.y) {
                        temp = nodes[i];
                        nodes[i] = nodes[j];
                        nodes[j] = temp;
                    }
                }
            }
            return nodes;
        },

        _sortByZIndex: function (nodes, asc) {
            var temp, i, j;
            if (!asc) {
                for (i = 0; i < nodes.length; i++) {
                    for (j = i + 1; j < nodes.length; j++) {
                        if (nodes[i].zOrder < nodes[j].zOrder) {
                            temp = nodes[i];
                            nodes[i] = nodes[j];
                            nodes[j] = temp;
                        }
                    }

                }
            }
            else {
                for (i = 0; i < nodes.length; i++) {
                    for (j = i + 1; j < nodes.length; j++) {
                        if (nodes[i].zOrder > nodes[j].zOrder) {
                            temp = nodes[i];
                            nodes[i] = nodes[j];
                            nodes[j] = temp;
                        }
                    }

                }
            }
            return nodes;
        },

        _findCornerNodes: function () {
            var lNode, rNode, tNode, bNode, i, nBounds;
            var list = this.selectionList[0].children;
            var fnode = this.nameTable[this.selectionList[0].children[0]];
            lNode = fnode, rNode = fnode, tNode = fnode, bNode = fnode;

            if (list.length > 1) {
                for (i = 0; i < list.length; i++) {
                    var node = this.nameTable[list[i]];
                    nBounds = ej.datavisualization.Diagram.Util.bounds(node);

                    var rNodeBounds = ej.datavisualization.Diagram.Util.bounds(rNode);    //Right Node
                    if ((nBounds.x + nBounds.width) > (rNodeBounds.x + rNodeBounds.width))
                        rNode = node;

                    var bNodeBounds = ej.datavisualization.Diagram.Util.bounds(bNode);    //Bottom Node
                    if ((nBounds.y + nBounds.height) > (bNodeBounds.y + bNodeBounds.height))
                        bNode = node;

                    var lNodeBounds = ej.datavisualization.Diagram.Util.bounds(lNode);    //Left Node
                    if (nBounds.x < lNodeBounds.x)
                        lNode = node;

                    var tNodeBounds = ej.datavisualization.Diagram.Util.bounds(tNode);    //top Node
                    if (nBounds.y < tNodeBounds.y)
                        tNode = node;

                }
            }
            return { left: lNode, right: rNode, top: tNode, bottom: bNode };
        },

        _moveNode: function (diffX, diffY, node) {
            this._translate(node, diffX, diffY, this.nameTable);
            this._updateNodeMargin(node);
            ej.datavisualization.Diagram.DiagramContext.update(node, this);
        },

        _nudge: function (node, x, y) {
            this.activateTool("move");
            this.activeTool.inAction = true;
            this._translate(node, x, y, this.nameTable);
            this._updateNodeMargin(node);
            ej.datavisualization.Diagram.DiagramContext.update(node, this);
            this._updateSelectionHandle(true);
            //ej.datavisualization.Diagram.SvgContext.updateSelector(node, this._svg, this._currZoom, this, this.model.selectedItems.constraints);
        },

        _findObjectByName: function (name) {
            var node = null;
            if (this._findNode(name))
                node = this._findNode(name);
            if (this._findConnector(name))
                node = this._findConnector(name);
            return node;
        },

        _findObjectByIndex: function (index, group) {
            var nodes, findNode = null, node, m, k;
            if (group) {
                var parent = this.nameTable[this.selectionList[0].parent];
                if (parent) {
                    nodes = this._getChildren(parent.children);
                    for (k = 0; k < nodes.length; k++) {
                        node = this.nameTable[nodes[k]];
                        if (node.zOrder === index)
                            findNode = nodes[k];
                    }
                }
            } else {
                for (m = 0; m < this.nodes().length; m++) {
                    node = this.nodes()[m];
                    if (node.zOrder === index)
                        findNode = node;
                }
                for (m = 0; m < this.connectors().length; m++) {
                    node = this.connectors()[m];
                    if (node.zOrder === index)
                        findNode = node;
                }
            }

            return findNode;
        },

        _findOverlapNode: function (node) {
            var oNodes = [], m, i, rNodes = [];
            if (!node.parent) {
                for (m = 0; m < this.nodes().length; m++) {
                    oNodes.push(this.nodes()[m]);
                }
                for (m = 0; m < this.connectors().length; m++) {
                    oNodes.push(this.connectors()[m]);
                }
                var nBound = ej.datavisualization.Diagram.Util.bounds(node);
                if (node) {
                    for (i = 0; i < oNodes.length; i++) {
                        var chBound = ej.datavisualization.Diagram.Util.bounds(oNodes[i]);
                        if (node.name !== oNodes[i].name) {
                            if (this._intersect(nBound, chBound))
                                rNodes.push(oNodes[i]);
                        }
                    }
                }
            } else {
                var parent = this.nameTable[node.parent], child;
                if (parent) {
                    var children = this._getChildren(parent.children);
                    for (m = 0; m < children.length; m++) {
                        if (children[m] !== node.name) {
                            child = this.nameTable[children[m]];
                            if (child)
                                rNodes.push(child);
                        }
                    }
                }
            }
            return rNodes;
        },

        _intersect: function (a, b) {
            return (a.x <= (b.x + b.width) &&
                b.x <= (a.x + a.width) &&
                a.y <= (b.y + b.height) &&
                b.y <= (a.y + a.height));
        },
        //#endregion 

        //#region Rendering
        _createTooltipDiv: function () {
            var div = document.createElement("div");
            var attr = {
                "id": this.element[0].id + "_tooltipDiv",
                "class": "e-diagram-tooltip-default", "style": "padding-top:3px; height: 24px;pointer-events:none;",
            };
            ej.datavisualization.Diagram.Util.attr(div, attr);
            this._canvas.appendChild(div);
            return div;
        },

        _renderTooltip: function (object) {
            if (!(object.parent && this.nameTable[object.parent] && this.nameTable[object.parent].container)) {
                if (this.showTooltip() && $.templates) {
                    var tooltipDiv = $("#" + this.element[0].id + "_tooltipDiv")[0];
                    if (!tooltipDiv) {
                        tooltipDiv = this._createTooltipDiv();
                    }
                    var template;
                    var objectValues;
                    var html;

                    var curZoomfactor = this._currZoom;
                    if (!this.model.tooltipTemplateId) {
                        template = $.templates("#" + this.element[0].id + "_defaultTooltip");
                        if (this.activeTool instanceof ej.datavisualization.Diagram.MoveTool) {
                            tooltipDiv.style.width = "150px";
                            if (!object.segments)
                                objectValues = [{ type: "X : ", type1: "Y : ", x: Math.round((object.offsetX - object.width / 2)) + "px  ", y: Math.round((object.offsetY - object.height / 2)) + "px" }];
                        } else if (this.activeTool instanceof ej.datavisualization.Diagram.ResizeTool) {
                            tooltipDiv.style.width = "150px";
                            objectValues = [{ type: "W : ", type1: "H : ", x: Math.round(object.width) + "px  ", y: Math.round(object.height) + "px" }];
                        } else if (this.activeTool instanceof ej.datavisualization.Diagram.RotateTool) {
                            tooltipDiv.style.width = "50px";
                            objectValues = [{ type: "", type1: "", x: Math.round(object.rotateAngle) + "&deg; ", y: "" }];
                        }
                        if (objectValues) {
                            tooltipDiv.style.top = -this._vScrollOffset + ((object.offsetY * curZoomfactor - (object.height / 2) * curZoomfactor) + (object.height * curZoomfactor) + 15) + "px";
                            tooltipDiv.style.left = -this._hScrollOffset + ((object.offsetX * curZoomfactor - (object.width / 2) * curZoomfactor)) + (object.width / 2 * curZoomfactor - $(tooltipDiv).width() / 2) + "px";
                            html = template.render(objectValues);
                            $(tooltipDiv).html(html);
                        } else {
                            this._removeTooltip();
                        }
                    } else {
                        if (!object.segments) {
                            tooltipDiv.style.top = -this._vScrollOffset + ((object.offsetY * curZoomfactor - (object.height / 2) * curZoomfactor) + (object.height * curZoomfactor) + 15) + "px";
                            tooltipDiv.style.left = -this._hScrollOffset + ((object.offsetX * curZoomfactor - (object.width / 2) * curZoomfactor)) + (object.width / 2 * curZoomfactor - $(tooltipDiv).width() / 2) + "px";
                            template = $.templates("#" + this.model.tooltipTemplateId);
                            objectValues = [{ name: this.activeTool.selectedObject.name, x: (object.offsetX - object.width / 2) + "px", y: (object.offsetY - object.height / 2) + "px", width: object.width + "px", height: object.height + "px", rotationAngle: object.rotateAngle }];
                            html = template.render(objectValues);
                            $(tooltipDiv).html(html);
                        }
                    }
                }
            }
        },

        _removeTooltip: function () {
            var tooltipDiv = document.getElementById(this.element[0].id + "_tooltipDiv");
            if (tooltipDiv) {
                tooltipDiv.parentNode.removeChild(tooltipDiv);
            }
        },

        _renderCanvas: function () {
            this._canvas = document.createElement("div");
            this._canvas.setAttribute("id", this.element[0].id + "_canvas");
            this._canvas.setAttribute("class", "drawing");
            this._canvas.setAttribute("style", "position:relative; height:" + this.model.height + "; width:" + this.model.width + ";");
            this.element.css({
                overflow: "hidden", outline: "none", display: "block", height: this.model.height, width: this.model.width
            });
            this._views[this._id].canvas = this._canvas;
            this.element[0].setAttribute("tabindex", 0);
            this.element.append(this._canvas);
            this._renderDiagram();
        },

        _getDigramBounds: function () {
            var left, top, right, bottom;
            left = Math.min(0, this._spatialSearch.pageLeft);
            top = Math.min(0, this._spatialSearch.pageTop);
            if (!this._pageWidth()) {
                right = this._spatialSearch.pageRight - Math.min(0, this._spatialSearch.pageLeft);
            }
            if (!this._pageHeight()) {
                bottom = this._spatialSearch.pageBottom - Math.min(0, this._spatialSearch.pageTop);
            }
            if (this.model.pageSettings && this._multiplePage()) {
                left = Math.min(0, this._spatialSearch.pageLeft);
                top = Math.min(0, this._spatialSearch.pageTop);
                if (this._pageWidth()) {
                    left = Math.floor(left / this._pageWidth()) * this._pageWidth();
                    right = Math.ceil(this._spatialSearch.pageRight / this._pageWidth()) * this._pageWidth() - left;
                }
                if (this._pageHeight()) {
                    top = Math.floor(top / this._pageHeight()) * this._pageHeight();
                    bottom = Math.ceil(this._spatialSearch.pageBottom / this._pageHeight()) * this._pageHeight() - top;
                }
                if (this._spatialSearch.pageRight === null) {
                    if (this._pageWidth() !== 0) {
                        right = this._pageWidth();
                    }
                }
                if (this._spatialSearch.pageBottom === null) {
                    if (this._pageHeight() !== 0) {
                        bottom = this._pageHeight();
                    }
                }
            }
            else {
                if (this._pageWidth()) {
                    left = Math.min(0, this._spatialSearch.pageLeft);
                    right = this._pageWidth();
                }
                if (this._pageHeight()) {
                    top = Math.min(0, this._spatialSearch.pageTop);

                    bottom = this._pageHeight();
                }
            }
            var svgBounds = new ej.datavisualization.Diagram.Rectangle();
            svgBounds.x = left;
            svgBounds.y = top;
            svgBounds.width = right;
            svgBounds.height = bottom;
            return svgBounds;
        },

        _initContextMenu: function () {
            if (this.enableContextMenu()) {
                this._renderContextMenu();
            }
            else {
                $("#" + this.element[0].id + "_contextMenu").remove();
            }
        },

        _renderContextMenuItem: function (item) {
            var li = document.createElement("li");
            var a = document.createElement("a");
            var menu = ej.datavisualization.Diagram.Locale[this.locale()];
            $.each(menu, function (otext, ntext) {
                if (item.name === otext) {
                    a.innerHTML = ntext;
                    item.text = ntext;
                }
            });
            li.setAttribute("id", this.element[0].id + "_contextMenu_" + item.name);

            var div = document.createElement("span");
            div.setAttribute("id", item.text + "_image");
            div.setAttribute("style", "display:table-cell; vertical-align:middle; text-align:center");
            div.setAttribute("class", "sf-d-menuitem " + item.name);
            a.appendChild(div);
            if (item.subItems && item.subItems.length > 0) {
                var subUl = document.createElement("ul");
                var i = 0, subli;
                for (i; i < item.subItems.length; i++) {
                    subli = this._renderContextMenuItem(item.subItems[i], subUl);
                    subUl.appendChild(subli);
                }
                li.appendChild(subUl);
            }
            li.appendChild(a);
            return li;
        },

        _renderContextMenu: function () {
            if (!this.model.contextMenu.showCustomMenuItemsOnly) {
                for (var i = this._defaultContextMenuItems.length - 1; i >= 0; i--) {
                    this.model.contextMenu.items.splice(0, 0, this._defaultContextMenuItems[i]);
                }
            }
            var menuCollection = this.model.contextMenu.items;
            var i = 0, item, mItem;
            var ul = document.createElement("ul");
            ul.setAttribute("id", this.element[0].id + "_contextMenu");
            for (i; i < menuCollection.length; i++) {
                item = menuCollection[i];
                mItem = this._renderContextMenuItem(item, ul);
                ul.appendChild(mItem);
            }
            this._canvas.appendChild(ul);
            $("#" + this.element[0].id + "_contextMenu").ejMenu({
                menuType: ej.MenuType.ContextMenu,
                contextMenuTarget: "#" + this.element[0].id + "_canvas_svg",
                click: $.proxy(this._onMenuItemClick, this),
                beforeOpen: $.proxy(this._onContextMenuOpen, this),
                mouseover: $.proxy(this._onMenuItemMouseOver, this),
                mouseout: $.proxy(this._onMenuItemMouseOut, this),
                close: $.proxy(this._onContextMenuClose, this),
            });
        },

        _onContextMenuClose: function () {
            this.element[0].focus();
        },

        _onContextMenuOpen: function (args) {
            var _id = this.element[0].id;
            if (this.enableContextMenu()) {
                if ($("#" + _id + "_contextMenu_cut")[0])
                    $("#" + _id + "_contextMenu_cut")[0].style.display = "block";
                if ($("#" + _id + "_contextMenu_copy")[0])
                    $("#" + _id + "_contextMenu_copy")[0].style.display = "block";
                if ($("#" + _id + "_contextMenu_paste")[0])
                    $("#" + _id + "_contextMenu_paste")[0].style.display = "block";
                if ($("#" + _id + "_contextMenu_undo")[0])
                    $("#" + _id + "_contextMenu_undo")[0].style.display = "block";
                if ($("#" + _id + "_contextMenu_redo")[0])
                    $("#" + _id + "_contextMenu_redo")[0].style.display = "block";
                if ($("#" + _id + "_contextMenu_selectAll")[0])
                    $("#" + _id + "_contextMenu_selectAll")[0].style.display = "block";
                if ($("#" + _id + "_contextMenu_cut")[0])
                    $("#" + _id + "_contextMenu_cut")[0].style.display = "block";
                if ($("#" + _id + "_contextMenu_grouping")[0])
                    $("#" + _id + "_contextMenu_grouping")[0].style.display = "block";
                if ($("#" + _id + "_contextMenu_order")[0])
                    $("#" + _id + "_contextMenu_order")[0].style.display = "block";
                if (this.selectionList.length == 0) {
                    if ($("#" + _id + "_contextMenu_cut")[0])
                        $("#" + _id + "_contextMenu_cut")[0].style.display = "none";
                    if ($("#" + _id + "_contextMenu_copy")[0])
                        $("#" + _id + "_contextMenu_copy")[0].style.display = "none";
                    if ($("#" + _id + "_contextMenu_cut")[0])
                        $("#" + _id + "_contextMenu_cut")[0].style.display = "none";
                    if ($("#" + _id + "_contextMenu_grouping")[0])
                        $("#" + _id + "_contextMenu_grouping")[0].style.display = "none";
                    if ($("#" + _id + "_contextMenu_order")[0])
                        $("#" + _id + "_contextMenu_order")[0].style.display = "none";
                }
            }
            var obj = ({ diagram: this, contextmenu: args });
            this._trigger("contextMenuBeforeOpen", obj);
        },

        _onMenuItemClick: function (args) {
            var menuId = args.events.ID.replace(this._id + "_" + "contextMenu_", "");
            switch (menuId) {
                case "cut":
                    this.cut();
                    break;
                case "copy":
                    this.copy();
                    break;
                case "paste":
                    this.paste();
                    break;
                case "undo":
                    this.undo();
                    break;
                case "redo":
                    this.redo();
                    break;
                case "selectAll":
                    this.selectAll();
                    break;
                case "group":
                    this.group();
                    break;
                case "ungroup":
                    this.ungroup();
                    break;
                case "bringToFront":
                    this.bringToFront();
                    break;
                case "sendToBack":
                    this.sendToBack();
                    break;
                case "moveForward":
                    this.moveForward();
                    break;
                case "sendBackward":
                    this.sendBackward();
                    break;
                default:
                    break;
            }
            this._trigger("contextMenuClick", args);
        },

        _onMenuItemMouseOver: function (args) {
            var t = args.events.element.lastChild.childNodes[1];
            $(t).addClass("hover");
        },

        _onMenuItemMouseOut: function (args) {
            var t = args.events.element.lastChild.childNodes[1];
            $(t).removeClass("hover");
        },

        _renderDiagram: function () {
            var diagram = this;
            this._views.forEach(function (viewid) {
                var view = diagram._views[viewid];
                view.context._renderDocument(view, diagram); if (view.type == "mainview" && view.context == ej.datavisualization.Diagram.SvgContext) {
                    diagram._createScrollbar(diagram._canvas);
                    ej.datavisualization.Diagram.ScrollUtil._initScrollbar(diagram);
                    ej.datavisualization.Diagram.PageUtil._updatePageSize(diagram);
                }
                //if (diagram.model.layout && diagram.model.layout.type !== ej.datavisualization.Diagram.LayoutTypes.None) {
                //    diagram._doLayout();
                //};
                diagram._renderNodes(view);
                diagram._renderConnectors(view);
                diagram._renderphases(view);
            });
            $(this._svg.document).pinchDiagram(this._view, this);
        },

        _createScrollbar: function (canvas) {
            var hScrollbar = document.createElement("div");
            hScrollbar.setAttribute("id", canvas.id + "_hScrollbar");
            canvas.appendChild(hScrollbar);
            var vScrollbar = document.createElement("div");
            vScrollbar.setAttribute("id", canvas.id + "_vScrollbar");
            canvas.appendChild(vScrollbar);
        },

        _doLayout: function () {
            if (this.model.layout)// && this.model.layout.type !== ej.datavisualization.Diagram.LayoutTypes.None)
            {
                //this.model.layout = new ej.datavisualization.Diagram.HierarchicalLayout(this.model.layout);
                //this.model.layout._setModel(this);
                this._updateEdgeCollection();
                ej.datavisualization.Diagram.Layout.doLayout(this);
                //this.model.layout.doLayout(this);
            }
        },

        _updateNodes: function () {
            var nodes = this.nodes();
            for (var i = 0; i < nodes.length; i++) {
                ej.datavisualization.Diagram.DiagramContext.update(nodes[i], this);
            }
        },

        _updateConnectors: function () {
            var connections = this.connectors();
            for (var i = 0; i < connections.length; i++) {
                ej.datavisualization.Diagram.DiagramContext.update(connections[i], this);
            }
        },

        _updateEdgeCollection: function () {
            for (var i = 0; i < this.connectors().length; i++) {
                this._updateEdges(this.connectors()[i]);
            }
        },
        /**
        *To update viewport when window resize
        *@return jQuery
        *@example
        
        *&lt;div id="diagramcontent"&gt;&lt;/div&gt;
        *&lt;script&gt;
        *var diagram=$("#diagramcontent").ejDiagram("instance");
        *diagram.updateViewPort();
        *&lt;/script&gt;
        *@memberof ejDiagram
*@instance
        */

        updateViewPort: function () {
            ej.datavisualization.Diagram.DiagramContext.updateViewPort(this);
        },

        _setZorder: function (node) {
            if (node) {
                node.zOrder = this._zOrder;
                this._zOrder++;
                if (node.type == "group") {
                    var i = 0;
                    if (node.children > 0) {
                        var children = this._getChildren(node.children);
                        for (i; i < children.length; i++) {
                            this.nameTable[children[i]].zOrder = i;
                        }
                    }
                }
            }
        },

        _union: function (rect1, rect2) {
            var x = Math.min(rect1.x, rect2.x);
            var y = Math.min(rect1.y, rect2.y);
            var overWidth = Math.max(rect1.x + rect1.width, rect2.x + rect2.width);
            var overheight = Math.max(rect1.y + rect1.height, rect2.y + rect2.height);
            return new ej.datavisualization.Diagram.Rectangle(x, y, overWidth - x, overheight - y);
        },
        _getSeperetor: function (id) {
            var phases = this.model.phases;
            if (phases) {
                for (var i = 0, len = phases.length; i < len; i++) {
                    if (phases[i].name == id) {
                        return phases[i];
                    }
                }
            }
        },
        _renderphases: function () {
            var phases = this.model.phases;
            if (phases) {
                for (var i = 0, len = phases.length; i < len; i++) {
                    if (phases[i].type == "phase") {
                        ej.datavisualization.Diagram.SvgContext.renderphase(phases[i], this._svg, this._diagramLayer, this);
                    }
                }
            }
        },
        _renderNodes: function (view, isLoad, isoverView) {
            if (this.nodes()) {
                var nodes = this.nodes();
                for (var i = 0, len = nodes.length; i < len; ++i) {
                    var node = this.nameTable[nodes[i].name];
                    this._setZorder(node);
                    var panel = view.svg || view._canvas;
                    if (node.type == "group" && !node.parent) {
                        if (!node.container) {
                            ej.datavisualization.Diagram.Util._updateGroupBounds(node, this, true);
                        }
                        view.context.renderGroup(node, panel, view.diagramLayer, this.nameTable, this, isLoad, isoverView);
                        ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);
                        ej.datavisualization.Diagram.DiagramContext.update(node, this);
                    }
                    else {
                        if (!node.parent)
                            view.context.renderNode(node, panel, view.diagramLayer, this);
                    }
                }
            }
        },

        _renderConnectors: function (view) {
            if (this.connectors()) {
                var connectors = this.connectors();
                var panel = view.svg || view._canvas;
                var connector;
                for (var i = 0, len = connectors.length; i < len; ++i) {
                    connector = connectors[i];
                    this._setZorder(connector);
                }
                for (var i = 0, len = connectors.length; i < len; ++i) {
                    connector = connectors[i];
                    ej.datavisualization.Diagram.Util.updateBridging(connector, this);
                    if (connector.parent && connector.parent != "") {
                        var parent = this._svg.document.getElementById(connector.parent)
                        if (parent)
                            view.context.renderConnector(connector, panel, parent, this);
                    }
                    else
                        view.context.renderConnector(connector, panel, view.diagramLayer, this);
                }
            }
        },

        //#endregion

        //#region Events
        _wireEvents: function () {
            //svg document events
            var svgDocument = $(this._canvas);
            this._on(svgDocument, ej.eventType.mouseDown, this._mousedown);
            this._on(svgDocument, ej.eventType.mouseMove, this._mousemove);
            this._on(svgDocument, ej.eventType.mouseUp, this._mouseup);
            this._on(svgDocument, ej.eventType.mouseLeave, this._documentmouseup);
            this._on(svgDocument, "dblclick", this._doubleclick);
            this._on(svgDocument, "doubletap", this._doubleclick);

            this._on(this.element, "keydown", this._keydown);
            this._on(this.element, "keyup", this._keyup);
            //this._on(this.element, "contextmenu", this._contextmenu);
            this._on(svgDocument, "pinchin", this._pinchin);
            this._on(svgDocument, "pinchout", this._pinchout);
            this._on(this.element, "touchstart", this._handleTouchStart);
            if (ej.browserInfo().name === "mozilla") {
                this._on(this.element, "DOMMouseScroll", this._handleMouseWheel);
            }
            else
                this._on(this.element, "mousewheel", this._handleMouseWheel);
            //window document event
            this._on($(document), "mouseup", this._documentmouseup);

            if (window) {
                this._on($(window), "resize", this.updateViewPort);
            }
            var obj = this;
            $(svgDocument).ejDroppable({
                drop: function (event, ui) {
                    obj._svgdrop(event, ui);
                    obj._isDropped = true;
                }
            });
        },

        _mousePosition: function (evt, exOffset) {
            var e = this._isTouchEvent(evt);
            var scrollLeft = this._canvas.scrollLeft;
            var scrollTop = this._canvas.scrollTop;
            var controlBBox = this._canvas.getBoundingClientRect();
            var layerx = (e.clientX + scrollLeft) - controlBBox.left;
            var layery = (scrollTop + e.clientY) - controlBBox.top;
            if (!exOffset) {
                layerx = (layerx + this._hScrollOffset) / this._currZoom;
                layery = (layery + this._vScrollOffset) / this._currZoom;
            }
            return new ej.datavisualization.Diagram.Point(Math.round(layerx * 100) / 100, Math.round(layery * 100) / 100);
        },

        _contextmenu: function (evt) {
            evt.preventDefault();
            evt.stopPropagation();
        },

        _pinchin: function (evt) {
            evt.preventDefault();
        },

        _pinchout: function (evt) {
            evt.preventDefault();
        },

        _handleTouchStart: function (evt) {
            evt.preventDefault();
        },

        _mousedown: function (evt) {
            this._isPinching = false;
            if (this._invoke(evt)) {
                if (!this._isForeignObject(evt.originalEvent.target))
                    evt.preventDefault();
                if (this.model.contextMenu && $("#" + this.element[0].id + "_contextMenu").css("display") !== "none") {
                    evt.cancel = true;
                }
                if (this._isEditing)
                    this._endEdit();
                if (evt.which === 1 || (evt.which === 0 && evt.originalEvent.changedTouches)) {
                    if (evt.which === 0 && evt.originalEvent.changedTouches) {
                        var node = null;
                        var point = this._mousePosition(evt);
                        var isUserHandle = this._isUserHandle(evt);
                        if ((this._isInternalTool(this.activeTool) && !this.activeTool.inAction)) {
                            if (!isUserHandle) {
                                node = this._findNodeUnderMouse(evt);
                                this._raiseMouseEvents(node);
                            }
                            if (!node && this.selectionList[0]) {
                                node = this.selectionList[0];
                            }
                            this._checkToolToActivate(evt, node, point);
                        }
                    }
                    if (evt.ctrlKey && evt.shiftKey) {
                        node = this._findNodeUnderMouse(evt);
                        if (!node && this.selectionList[0]) {
                            node = this.selectionList[0];
                        }
                        this._checkToolToActivate(evt, node, point);
                    }
                    if (this._toolToActivate === "panTool") {
                        this.activeTool = this.tools[this._toolToActivate];
                    }
                    else {
                        this.activateTool(this._toolToActivate);
                    }
                    this.activeTool.mousedown(evt);
                }
            }
        },

        _invoke: function (evt) {
            var className = evt.originalEvent.target.className;
            if (evt.originalEvent.target && (className == "edit" || className == "editBox" || className == "e-hhandle" || className == "e-hhandlespace" || className == "e-vhandle" || className == "e-vhandlespace")) {
                return false;
            }

            return true;
        },

        _handleMouseWheel: function (evt) {
            if (evt.originalEvent.preventDefault)
                evt.originalEvent.preventDefault();
            var position = new ej.datavisualization.Diagram.Point(0, 0);
            //this.deactivateTool();
            if (evt.ctrlKey) {
                position.x = (evt.originalEvent.layerX + this._hScrollOffset) / this._currZoom;
                position.y = (evt.originalEvent.layerY + this._vScrollOffset) / this._currZoom;
                if (evt.originalEvent.wheelDelta > 0 || -40 * evt.originalEvent.detail > 0) {
                    ej.datavisualization.Diagram.ZoomUtil.zoomPan(this, (1 + Number(this.zoomFactor())), 0, 0, position, true);
                }
                else {
                    ej.datavisualization.Diagram.ZoomUtil.zoomPan(this, (1 / (1 + Number(this.zoomFactor()))), 0, 0, position, true);
                }
            }
            else {
                var offsetY = 0;
                if (evt.originalEvent.wheelDelta > 0 || -40 * evt.originalEvent.detail > 0) {
                    var top = this._vScrollbar.model.minimum;
                    if ((this._vScrollOffset - this._scrollPixel) >= top || this._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Infinity) {
                        this._updateScrollOffset(this._hScrollOffset, (this._vScrollOffset - this._scrollPixel));
                        offsetY = -this._scrollPixel;
                    }
                    else {
                        this._updateScrollOffset(this._hScrollOffset, top);
                        offsetY = 0;
                    }
                }
                else {

                    var cHeight = this._vScrollbar.model.maximum;
                    var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this);
                    if ((cHeight) >= (this._vScrollOffset + this._scrollPixel) || this._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Infinity) {
                        this._updateScrollOffset(this._hScrollOffset, (this._vScrollOffset + this._scrollPixel));
                        offsetY = this._scrollPixel;
                    }
                    else {
                        this._updateScrollOffset(this._hScrollOffset, cHeight);
                        offsetY = 0;
                    }

                }
                this._updateEditBox(0, offsetY);
            }
        },

        _mousemove: function (evt) {
            if (evt.type == "touchmove" && evt.originalEvent.touches.length > 1) {
                this._isPinching = true;
            }
            else {
                this._isPinching = false;
                var node = null;
                var point = this._mousePosition(evt);
                var isUserHandle = this._isUserHandle(evt);
                if ((this.activeTool.inAction === false) && (this._selectedSymbol)) {
                    var scale = this._currZoom;
                    var offset = $("#" + this.element[0].id).offset();
                    var coor = this._isTouchEvent(evt);
                    var pageX;
                    var pageY;
                    if (coor) {
                        pageX = coor.pageX;
                        pageY = coor.pageY;
                    }
                    else {
                        pageX = evt.pageX;
                        pageY = evt.pageY;
                    }
                    var x = pageX + this._hScrollOffset - offset.left;
                    var y = pageY + this._vScrollOffset - offset.top;

                    {
                        var paletteItem = $.extend(true, {}, this._selectedSymbol);
                        if (this._selectedSymbol) {
                            var paletteItem = $.extend(true, {}, this._selectedSymbol);
                            paletteItem.name += ej.datavisualization.Diagram.Util.randomId();
                            if (paletteItem.segments) {
                                ej.datavisualization.Diagram.Util._translateLine(paletteItem, x / scale, y / scale);
                                args = { element: paletteItem };
                                if (!args.cancel) {
                                    this.add(paletteItem);
                                }
                            }
                            else {
                                var palNameTable = this._palNameTable;
                                var args = { element: paletteItem };
                                if (!args.cancel) {
                                    var randomId = ej.datavisualization.Diagram.Util.randomId();
                                    this._cloneGroupNode(paletteItem, randomId);
                                    //paletteItem.name = randomId;
                                    if (paletteItem.type == "group") {
                                        var cBound = ej.datavisualization.Diagram.Util._getChildrenBounds(paletteItem, this);
                                        this._translate(paletteItem, (x / scale - cBound.x - cBound.height / 2), (y / scale - cBound.y - cBound.width / 2), this.nameTable);
                                    } else {
                                        paletteItem.offsetX = x / scale;
                                        paletteItem.offsetY = y / scale;
                                    }
                                    if (paletteItem.isLane) {
                                        var obj = ej.datavisualization.Diagram.SwimLaneHelper._createDiagramLane(paletteItem, this.nameTable);
                                        obj.isLane = paletteItem.isLane;
                                        obj.orientation = paletteItem.orientation;
                                        this.add(obj);
                                        ej.datavisualization.Diagram.SvgContext._hideNode(obj, this._svg);

                                    }
                                    else
                                        this.add(paletteItem);

                                }
                            }
                            this.scrollToNode(paletteItem);
                            this.element[0].focus();
                            this._toolToActivate = "move";
                            this.activateTool("move");
                            var displays = document.getElementsByClassName("dragClone")[0];
                            if (displays) {
                                displays.style.display = "none";
                            }
                            this.activateTool("move", true);
                            this.activeTool.mousedown(evt);
                            this.activeTool.mousemove(evt);

                        }
                    }
                }
                else {
                    if ((this._isInternalTool(this.activeTool) && !this.activeTool.inAction)) {
                        if (!isUserHandle) {
                            var node = this._findNodeUnderMouse(evt);
                            if (node) {
                                if (this._nodeToHit && this._nodeToHit != node && !this._nodeToHit.segments) {
                                    this.activeTool._showPort(this._nodeToHit, true);
                                }
                                if (!node.segments) {
                                    this.activeTool._showPort(node);
                                }
                            }
                            this._raiseMouseEvents(node);
                        }
                        if (!node && this.selectionList[0]) {
                            node = this.selectionList[0];
                        }
                        if (ej.datavisualization.Diagram.Util.isPageEditable(this)) {
                            this._checkToolToActivate(evt, node, point);
                        }
                    } else {
                        if (!this.activeTool.inAction) {
                            this._toolToActivate = this.activeTool.name;
                            this._currentCursor = this.activeTool.cursor;
                        }

                        node = this._findNodeUnderMouse(evt);
                        if (node) {
                            this._raiseMouseEvents(node);
                        }

                    }
                    this._updateCursor();
                    this.activeTool.mousemove(evt);
                    if (this.activeTool.inAction && this.enableAutoScroll()) {
                        var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this);
                        var pt = this._mousePosition(evt, true);
                        var autoScrollBorder = this.model.pageSettings.autoScrollBorder;
                        if (pt.x + autoScrollBorder.right >= viewPort.width - 18) {
                            this._beginAutoScroll("right", evt);
                            this._canAutoScroll = true;
                        }
                        else if (pt.x <= autoScrollBorder.left) {
                            this._beginAutoScroll("left", evt);
                            this._canAutoScroll = true;
                        }
                        else if (pt.y + autoScrollBorder.bottom >= viewPort.height - 18) {
                            this._beginAutoScroll("bottom", evt);
                            this._canAutoScroll = true;
                        }
                        else if (pt.y <= autoScrollBorder.top) {
                            this._beginAutoScroll("top", evt);
                            this._canAutoScroll = true;
                        }
                        else {
                            this._canAutoScroll = false;
                        }
                    }
                }
            }
        },

        _cloneGroupNode: function (node, id, nameTable) {
            var child = null, clnObj;
            var children = node.children = this._getChildren(node.children);
            if (node.type == "group") {
                for (var i = 0; i < children.length; i++) {
                    if (nameTable)
                        child = nameTable[children[i]];
                    else {
                        if (this._paletteTable)
                            child = this._paletteTable[children[i]];
                    }
                    if (child) {
                        child = $.extend(true, {}, child);
                        if (child.type == "group")
                            this._cloneGroupNode(child, id);
                        clnObj = $.extend(true, {}, child);
                        clnObj.name += id;
                        children[i] = clnObj.name;
                        this.nameTable[clnObj.name] = clnObj;
                    }
                }
            }
        },
        _setActiveTool: function (evt) {
            var point = this._mousePosition(evt);
            if (!this.activeTool.inAction && (this._isUserHandleActive(this.activeTool.name) || !this.model.selectedItems.userHandles || !this.model.selectedItems.userHandles.length)) {
                if (this._isInternalTool(this.activeTool) || this.activeTool.singleAction) {
                    var node;
                    var success = false;
                    //var handle = this._isHandle(evt);
                    if (this.selectionList[0]) {
                        node = this.selectionList[0];
                        success = this._checkToolToActivate(evt, node, point);
                    }
                    if (!success) {
                        node = this._findNodeUnderMouse(evt);
                        if (this._isUserHandle(evt)) {
                            var handleName = $(evt.target).parents("g").first().context.id.split("_")[0];
                            this._checkToolToActivate(evt, node, point, handleName);
                            this.activeTool = this.tools[this._toolToActivate];
                        }
                        else {
                            this._checkToolToActivate(evt, node, point);
                            this._raiseMouseEvents(node);
                            if (this._isUserHandleActive(this.activateTool.name) && !this._drawingTool)
                                this.activeTool = this.tools[this._toolToActivate];
                        }
                    }
                }
            }
        },

        _beginAutoScroll: function (option, evt) {
            var delay = 100;
            var callBack = this;
            var left = 0, top = 0;
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this);
            var cWidth = this._hScrollbar.model.maximum + viewPort.width;
            var cHeight = this._vScrollbar.model.maximum + viewPort.height;
            if (this._canAutoScroll) {
                switch (option) {
                    case "right":
                        if ((this._hScrollOffset + viewPort.width + 10) < cWidth || this._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Infinity) {
                            left = 10;
                        }
                        break;
                    case "left":
                        if (this._hScrollOffset - 10 > this._hScrollbar.model.minimum || this._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Infinity) {
                            left = -10;
                        }
                        break;
                    case "bottom":
                        if (this._vScrollOffset + viewPort.height + 10 < cHeight || this._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Infinity) {
                            top = 10;
                        }
                        break;
                    case "top":
                        if (this._vScrollOffset - 10 > this._vScrollbar.model.minimum || this._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Infinity) {
                            top = -10;
                        }
                        break;
                }
                setTimeout(function () {
                    callBack._raiseEvent("autoScrollChange", { delay: delay })
                    callBack._updateScrollBar(left, top, option, evt);
                }, delay);
            }
        },

        _updateScrollBar: function (x, y, option, evt) {
            if (x === 0 && y === 0) {
                this._canAutoScroll = false;
            }
            else if (this.activeTool.inAction) {
                var hScrollOffset = this._hScrollOffset + (x * this._currZoom);
                var vScrollOffset = this._vScrollOffset + (y * this._currZoom);
                this._updateSelectionOnScroll(x, y);
                this._updateScrollOffset(hScrollOffset, vScrollOffset);
                this._beginAutoScroll(option, evt);
            }
        },

        _updateSelectionOnScroll: function (x, y) {
            var tool = this.activeTool;
            if (tool.name === "select") {
                tool.currentPoint = new ej.datavisualization.Diagram.Point(tool.currentPoint.x + x, tool.currentPoint.y + y);
                tool._updateHelper();
            }
            else if (tool.name === "orthogonalLine" || tool.name === "straightLine") {
                tool.currentPoint = new ej.datavisualization.Diagram.Point(tool.currentPoint.x + x, tool.currentPoint.y + y);
                tool._targetPossibleConnection = tool._currentPossibleConnection;
                tool._targetPort = tool._possibleConnectionPort;
                tool._updateHelper();
            }
            else if (this.selectionList.length > 0) {
                var node = this.selectionList[0];
                tool.currentPoint = ej.datavisualization.Diagram.Point(tool.currentPoint.x + x, tool.currentPoint.y + y);
                if (tool.name === "move") {
                    if (tool.activeLabel)
                        this._translateLabel(node, tool.activeLabel, x, y);
                    else
                        this._translate(node, x, y, this.nameTable);
                }
                else if (tool.name === "resize") {
                    ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this);
                    tool._updateSize(node, tool.previousPoint, tool.currentPoint);
                }
                else if (tool.name === "endPoint") {
                    if (tool.selectedSegment && tool._endPoint == "segmentEnd") {
                        var difx = tool.currentPoint.x - tool.previousPoint.x;
                        var dify = tool.currentPoint.y - tool.previousPoint.y;
                        tool._updateAdjacentSegments(difx, dify);

                    }
                    else {
                        var updateSelection = tool._updatePoints(node);
                        tool._disconnect(node);
                        tool._updateConnection(node, updateSelection);
                    }
                }
                tool.previousPoint = ej.datavisualization.Diagram.Point(tool.currentPoint.x, tool.currentPoint.y);
                if (!tool.activeLabel) {
                    ej.datavisualization.Diagram.DiagramContext.update(node, this);
                    this._updateSelectionHandle();
                    this._renderTooltip(node);
                }
            }
        },

        _isUserHandle: function (evt) {
            if (evt.target.parentNode.className.animVal === "userHandle") {
                return true;
            }
            else {
                return false;
            }
        },

        _isUserHandleActive: function (name) {
            var userHandleActive = false;
            if (this.model.selectedItems.userHandles && this.model.selectedItems.userHandles.length > 0) {
                var i = 0;
                var length = this.model.selectedItems.userHandles.length;
                for (i; i < length; i++) {
                    if (this.model.selectedItems.userHandles[i].name === name) {
                        userHandleActive = true;
                        break;
                    }
                    else
                        userHandleActive = true;
                }
            }
            return userHandleActive;
        },

        _raiseMouseEvents: function (node) {
            if (!node && this._nodeToHit) {
                this._raiseEvent("mouseLeave", { element: this._nodeToHit });

                if (this._nodeToHit != null && (this._nodeToHit.shape) && !(this.activeTool instanceof ej.datavisualization.Diagram.LineTool)) {
                    this.activeTool._showPort(this._nodeToHit, true);

                }
            }
            if (node) {
                if (this._nodeToHit !== node) {
                    this._nodeToHit = node;
                    this._raiseEvent("mouseEnter", { element: node });
                }
            }
            else {
                this._nodeToHit = null;
            }
            if (node) {
                this._raiseEvent("mouseOver", { element: node });
            }
        },

        _isHandle: function (evt) {
            var handle = $(evt.target).parent("g.handle");
            if (handle.length > 0) {
                return true;
            }
            return false;
        },

        _findNodeUnderMouse: function (evt) {
            var node = null;
            var type;
            var parent = $(evt.target).parents(".ej-d-node,.ej-d-connector,.ej-d-group");
            if (parent) {
                type = parent.attr("class");
                if (type === "ej-d-node" || type === "ej-d-group") {
                    node = this._findNode(parent.attr("id"));
                }
                else if (type === "ej-d-connector") {
                    node = this._findConnector(parent.attr("id"));
                }
            }
            return node;
        },

        _isForeignObject: function (target) {
            var foreignObj = target.parentNode;
            if (foreignObj) {
                while (foreignObj.parentNode != null) {
                    if (foreignObj.className === "foreignObject") {
                        return foreignObj;
                    }
                    else {
                        foreignObj = foreignObj.parentNode;
                    }
                }
            }
            return null;
        },

        _mouseup: function (evt) {
            if (!this._isPinching) {
                if (this._invoke(evt)) {
                    var foreignObject = this._isForeignObject(evt.originalEvent.target);
                    if (!foreignObject)
                        evt.preventDefault();
                    if (evt.target.id === this._id + "_canvas_svg")
                        this._raiseEvent("click", { element: this });
                    this.activeTool.mouseup(evt);
                    if (this.activeTool instanceof ej.datavisualization.Diagram.PanTool) {
                        document.onmousemove = null;
                        document.onmouseup = null;
                    }

                    if (this._selectedSymbol) {
                        var args;
                        args = { element: this.selectionList[0], cancel: false };

                        if (args.cancel === true) {
                            this._remove(args.element);
                        }
                        var node = this.selectionList[0];
                        if (node) {
                            if ((node.labels.length > 0 && node.labels[0].mode === "edit")) {
                                this._isEditing = true;
                                this.startLabelEdit(node, node.labels[0]);
                            }

                            else {
                                this.element[0].focus();
                            }

                            this._raiseDropEvent(args);
                            this._raiseEvent("selectionChange", args);

                        }
                        var childTable = {};
                        if (this.selectionList && this.selectionList.length > 0)
                            childTable = this._getChildTable(this.selectionList[0], childTable);
                        var entry = { type: "collectionchanged", object: jQuery.extend(true, {}, node), childTable: jQuery.extend(true, {}, childTable), changeType: "insert" };
                        this.addHistoryEntry(entry);
                        this._selectedSymbol = null;
                    }
                    if ((!(this.activeTool instanceof ej.datavisualization.Diagram.PolygonTool) && !(this.activeTool instanceof ej.datavisualization.Diagram.TextTool)) && document.activeElement && document.activeElement.id !== this.element[0].id)
                        if (!this._isEditing && !foreignObject)
                            this.element[0].focus();
                    this._currentCursor = this.activeTool.cursor;
                    this._updateCursor();
                }
            }
        },

        _doubleclick: function (evt) {
            if (this.activeTool.name != "panTool") {
                var args;
                args = { element: this._nodeToHit, cancel: false, actualObject: this.activeTool.actualObject }
                if (!this._isEditing)
                    this._raiseEvent("doubleClick", args);
                if (this._nodeToHit)
                    this.activeTool._doubleClick(this._nodeToHit);
                if (!this.activeTool.inAction && ((this.selectionList.length > 0) || this.activeTool.selectedObject) && !args.cancel) {

                    if (this.activeTool.selectedObject)
                        var obj = this.activeTool.selectedObject;
                    else
                        var obj = this.selectionList[0];
                    if (!this._isEditing && !(obj.type == "pseudoGroup") && !args.cancel) {
                        if (!this._isEditing && obj.shape && obj.shape.type === "text" && this._setLabelEditing(obj.shape.textBlock)) {
                            this.scrollToNode(obj);
                            this._startEdit(obj);
                        }
                        else if (!this._isEditing && ((obj.labels.length === 0 || typeof obj.labels.length === "undefined") || (obj.labels.length > 0 && this._setLabelEditing(obj.labels[0])))) {
                            this.scrollToNode(obj);
                            this._startEdit(obj);
                        }
                    }
                }
                else if (this.activeTool instanceof ej.datavisualization.Diagram.PolygonTool) {
                    this.activeTool.doubleclick(evt);
                }
            }
        },

        _keydown: function (evt) {
            var keycode = evt.keyCode ? evt.keyCode : evt.which;
            if (keycode === 113) {
                if (this.selectionList.length > 0) {
                    var shape = this.selectionList[0];
                    if (!(shape.type == "pseudoGroup")) {
                        if (shape.shape.type === "text" && this._setLabelEditing(shape.shape.textBlock))
                            this._startEdit(shape);
                        else if (shape.labels.length > 0 && this._setLabelEditing(shape.labels[0]))
                            this._startEdit(shape);
                    }
                }
            }
            else if (this._isEditing && keycode === 27) {
                this._endEdit();
            }
            else if (!this._isEditing && keycode === 46) {
                this._delete();
            }
            else if (!this._isEditing && evt.ctrlKey && keycode === 88) {
                this.cut();
            }
            else if (!this._isEditing && evt.ctrlKey && keycode === 67) {
                this.copy();
            }
            else if (!this._isEditing && evt.ctrlKey && keycode === 86) {
                this.paste();
            }
            else if (evt.ctrlKey && keycode === 65) {
                if (this._isEditing)
                    this._endEdit();
                evt.preventDefault();
                this.selectAll();
            }
            else if (!this._isEditing && evt.ctrlKey && keycode === 89) {
                this.redo();
            }
            else if (!this._isEditing && evt.ctrlKey && keycode === 90) {
                this.undo();
            }
            if (!this._isEditing && (keycode === 37 || keycode === 38 || keycode === 39 || keycode === 40)) {
                evt.preventDefault();
                if (keycode === 37) { //left
                    !evt.shiftKey ? this.nudge("left") : this.nudge("left", 5);
                } else if (keycode === 38) { //up
                    !evt.shiftKey ? this.nudge("up") : this.nudge("up", 5);
                } else if (keycode === 39) { //right
                    !evt.shiftKey ? this.nudge("right") : this.nudge("right", 5);
                } else if (keycode === 40) { //down
                    !evt.shiftKey ? this.nudge("down") : this.nudge("down", 5);
                }
            }
            this.activeTool.keydown(evt);
        },

        _keyup: function (evt) {
            var keycode = evt.keyCode ? evt.keyCode : evt.which;
            if (!this._isEditing && (keycode === 37 || keycode === 38 || keycode === 39 || keycode === 40)) {
                evt.preventDefault();
                this.activeTool.inAction = false;
                this._updateSelectionHandle();
            }
        },

        _registerHistoryEvents: function () {
            this.historyManager.addEventHandler("collectionchanged", $.proxy(this._recordCollectionChanged, this));
            this.historyManager.addEventHandler("positionchanged", $.proxy(this._recordPinPointChanged, this));
            this.historyManager.addEventHandler("sizechanged", $.proxy(this._recordResizeChanged, this));
            this.historyManager.addEventHandler("rotationchanged", $.proxy(this._recordRotationChanged, this));
            this.historyManager.addEventHandler("endpointchanged", $.proxy(this._recordEndPointChanged, this));
            this.historyManager.addEventHandler("labelchanged", $.proxy(this._recordLabelChanged, this));
            this.historyManager.addEventHandler("groupingchanged", $.proxy(this._recordGroupChanged, this));
        },

        _updatePoints: function (helper, startPoint, endPoint, isTarget) {
            var offset = new ej.datavisualization.Diagram.Point(endPoint.x - startPoint.x, endPoint.y - startPoint.y);
            if (!ej.datavisualization.Diagram.Geometry.isEmptyPoint(offset)) {
                helper._updateEndPoint(offset.x, offset.y, isTarget);
            }
        },

        _recordCollectionChanged: function (args) {
            this._clearSelection();
            this._isUndo = true;
            var i;
            var changeType = args.changeType;
            if (args.isUndo) {
                if (args.changeType == "insert")
                    changeType = "remove";
                else
                    changeType = "insert";
            }
            if (changeType == "insert") {
                if (!args.object.container) {
                    if (args.object.type != "pseudoGroup") {
                        if (!args.object.segments) {
                            var port = null;
                            if (args.object.inEdges.length > 0) {
                                for (i = 0; i < args.object.inEdges.length; i++) {
                                    if (this.nameTable[args.object.inEdges[i]])
                                        this.nameTable[args.object.inEdges[i]].targetNode = args.object.name;
                                    port = args.targetPorts[args.object.inEdges[i]];
                                    if (port)
                                        if (this.nameTable[args.object.inEdges[i]])
                                            this.nameTable[args.object.inEdges[i]].targetPort = port;
                                }
                            }
                            if (args.object.outEdges.length > 0) {
                                for (i = 0; i < args.object.outEdges.length; i++) {
                                    if (this.nameTable[args.object.outEdges[i]])
                                        this.nameTable[args.object.outEdges[i]].sourceNode = args.object.name;
                                    port = args.sourcePorts[args.object.outEdges[i]];
                                    if (port)
                                        if (this.nameTable[args.object.outEdges[i]])
                                            this.nameTable[args.object.outEdges[i]].sourcePort = port;
                                }
                            }
                        }
                        if (args.object.type == "group")
                            this._addChildren(args.object, args.childTable);
                        this.add(args.object, args);
                        if (args.object.type == "group") {
                            this._addConnector(args.object, args);
                            this._addGroupConnector(args.object, args)
                        }
                        else {
                            this._addConnector(args.object, args);
                        }
                        this._clearSelection();
                        this.addSelection(this.nameTable[args.object.name]);
                    } else {
                        delete this.nameTable["multipleSelection"];
                        var node, j;
                        var pseudoGroup = ej.datavisualization.Diagram.Group({ "name": "multipleSelection", type: "pseudoGroup" });
                        for (i = 0; i < args.object.children.length; i++) {
                            pseudoGroup.children.push(args.object.children[i]);
                            node = args.childTable[args.object.children[i]];
                            node.parent = "";
                            if (node.type == "group")
                                this._addChildren(node, args.childTable);
                            this.add(args.childTable[args.object.children[i]], args);
                        }
                        this._addGroupConnector(args.object, args);
                        for (i = 0; i < pseudoGroup.children.length; i++) {
                            node = this.nameTable[pseudoGroup.children[i]];
                            if (!node.segments) {
                                if (node.inEdges.length > 0) {
                                    for (j = 0; j < node.inEdges.length; j++)
                                        this.nameTable[node.inEdges[j]].targetNode = node.name;
                                }
                                if (node.outEdges.length > 0) {
                                    for (j = 0; j < node.outEdges.length; j++)
                                        this.nameTable[node.outEdges[j]].sourceNode = node.name;
                                }
                            }
                        }
                        this._clearSelection();
                        this.nodes().push(pseudoGroup);
                        pseudoGroup.offsetX = args.object.offsetX;
                        pseudoGroup.offsetY = args.object.offsetY;
                        pseudoGroup.height = args.object.height;
                        pseudoGroup.width = args.object.width;
                        pseudoGroup.rotateAngle = args.object.rotateAngle;
                        this.addSelection(pseudoGroup);
                        this.nameTable[pseudoGroup.name] = pseudoGroup;
                    }
                } else {
                    if (!args.object.container) {
                        var child;
                        for (var i in args.childTable) {
                            child = args.childTable[i];
                            this.nameTable[i] = child;
                        }
                        node = args.object;
                        if (node.isSwimlane) {
                            node.width = 0;
                            node.height = 0;
                            this.add(node);
                        } else if (node.isLane) {
                            var swimlane = ej.datavisualization.Diagram.SwimLaneHelper._createSwimlane(node, this);
                            if (swimlane) {
                                swimlane.width = 0;
                                swimlane.height = 0;
                                this.add(swimlane);
                            }
                        }
                    }
                }

            }
            else if (changeType == "remove") {
                if (args.object.type != "pseudoGroup") {
                    this._remove(args.object);
                }
                else {
                    for (i = 0; i < args.object.children.length; i++) {
                        this._remove(this.nameTable[args.object.children[i]]);
                    }
                }
            }
            this._isUndo = false;
        },

        _addGroupConnector: function (group, arg) {
            var edges;
            var connector;
            var k, j, len, l;
            if (!group.segments) {
                var children = this._getChildren(group.children);
                for (k = 0; k < children.length; k++) {
                    var child = this.nameTable[children[k]];
                    if (child.inEdges && child.inEdges.length > 0) {
                        edges = child.inEdges;
                        for (j = 0, len = edges.length; j < len; j++) {
                            if (arg.edgeTable)
                                connector = arg.edgeTable[edges[j]];
                            else
                                connector = arg.childTable[edges[j]];
                            if (connector)
                                this.add(connector);
                        }
                    }
                    if (child.outEdges && child.outEdges.length > 0) {
                        edges = child.outEdges;
                        for (j = 0, len = edges.length; j < len; j++) {
                            if (arg.edgeTable)
                                connector = arg.edgeTable[edges[j]];
                            else
                                connector = arg.childTable[edges[j]];
                            if (connector)
                                this.add(connector);
                        }
                    }
                }
            }
        },

        _addConnector: function (node, arg) {
            var edges;
            var connector;
            var k, j, len, l;
            if (!node.segments) {
                if (node.inEdges && node.inEdges.length > 0) {
                    edges = node.inEdges;
                    for (j = 0, len = edges.length; j < len; j++) {
                        connector = arg.edgeTable[edges[j]];
                        this.add(connector);
                    }
                }
                if (node.outEdges && node.outEdges.length > 0) {
                    edges = node.outEdges;
                    for (j = 0, len = edges.length; j < len; j++) {
                        connector = arg.edgeTable[edges[j]];
                        this.add(connector);
                    }
                }
            }
        },

        _addChildren: function (group, childTable) {
            var children = this._getChildren(group.children);
            for (var i = 0; i < children.length; i++) {
                var node = childTable[children[i]];
                if (node.type == "group")
                    this._addChildren(node, childTable);
                else
                    this.nameTable[children[i]] = node;
            }
        },

        _updateRecordPinPoint: function (node, childTable, isMultipleSelection) {
            var object, i, item, objNode;
            // this._clearSelection();
            if (node.type == "pseudoGroup") {
                var undoObj = node;
                var children = this._getChildren(node.children);
                for (i = 0; i < children.length; i++) {
                    item = this.nameTable[children[i]];
                    objNode = childTable[children[i]];
                    if (objNode) {
                        if (!item.segments) {
                            this._translate(item, objNode.offsetX - item.offsetX, objNode.offsetY - item.offsetY, this.nameTable);
                        } else {
                            var objLine = childTable[item.name];
                            item.sourcePoint = objLine.sourcePoint;
                            item.targetPoint = objLine.targetPoint;
                            item.segments = objLine.segments;
                        }
                        ej.datavisualization.Diagram.DiagramContext.update(item, this);
                    }
                }
                if (this.selectionList[0]) {
                    if (this.selectionList[0].name === undoObj.name) {
                        this.selectionList[0].offsetX = undoObj.offsetX;
                        this.selectionList[0].offsetY = undoObj.offsetY;
                    }
                }
                ej.datavisualization.Diagram.SvgContext.updateSelector(undoObj, this._svg, this._currZoom, this, this.model.selectedItems.constraints);
            } else {
                if (node.segments) {
                    if (isMultipleSelection) {
                        object = childTable[node.name];
                        node.sourcePoint = object.sourcePoint;
                        node.targetPoint = object.targetPoint;
                        node.segments = object.segments;
                        ej.datavisualization.Diagram.DiagramContext.update(node, this);
                    } else {
                        this._clearSelection();
                        object = this._findConnector(node.name);
                        var obj;

                        if (node.targetNode) {
                            obj = this.nameTable[node.targetNode];
                            ej.datavisualization.Diagram.Util.removeItem(obj.inEdges, node);
                        }
                        if (node.sourceNode) {
                            obj = this.nameTable[node.sourceNode];
                            ej.datavisualization.Diagram.Util.removeItem(obj.outEdges, node);
                        }
                        if (node.targetNode) {
                            obj = this.nameTable[node.targetNode];
                            obj.inEdges.push(node.name);
                        }
                        if (node.sourceNode) {
                            obj = this.nameTable[node.sourceNode];
                            obj.outEdges.push(node.name);
                        }
                        object.targetNode = node.targetNode;
                        object.sourceNode = node.sourceNode;
                        object.targetPort = node.targetPort;
                        object.sourcePort = node.sourcePort;

                        object.sourcePoint = node.sourcePoint;
                        object.targetPoint = node.targetPoint;
                        object.segments = node.segments;
                        this._updateLabels(object, node.labels);
                        ej.datavisualization.Diagram.DiagramContext.update(object, this);
                        ej.datavisualization.Diagram.SvgContext.updateSelector(node, this._svg, this._currZoom, this, this.model.selectedItems.constraints);
                        this.addSelection(node);
                    }
                } else {
                    if (isMultipleSelection) {
                        object = childTable[node.name];
                        this._translate(node, object.offsetX - node.offsetX, object.offsetY - node.offsetY, childTable);
                        ej.datavisualization.Diagram.DiagramContext.update(object, this);
                    } else {
                        this._clearSelection();
                        object = this._findNode(node.name);
                        this._translate(object, node.offsetX - object.offsetX, node.offsetY - object.offsetY, this.nameTable);
                        this._updateLabels(object, node.labels);
                        if (node.parent) {
                            ej.datavisualization.Diagram.Util._updateGroupBounds(this.nameTable[object.parent], this);
                        }
                        if (object.parent) {
                            var parent = this.nameTable[object.parent];
                            if (parent && parent.container) {
                                if (parent.container.type == "canvas") {
                                    ej.datavisualization.Diagram.SvgContext._alignOnCanvas1(parent, this);
                                }
                                else if (parent.container.type == "stack") {

                                    ej.datavisualization.Diagram.SvgContext._alignOnStack(parent, this);
                                }

                            }
                        }
                        ej.datavisualization.Diagram.DiagramContext.update(object, this);
                        this.addSelection(object);
                    }
                }
            }
        },
        _updateLabels: function (node, labels) {
            node.labels = labels;
            for (var i = 0; i < node.labels.length; i++)
                ej.datavisualization.Diagram.DiagramContext.updateLabel(node, node.labels[i], this);
        },
        _recordPinPointChanged: function (args) {
            var node = args.object.node;
            var childTable = args.object.childTable;
            if (!node.container)
                this._updateRecordPinPoint(node, childTable);
        },
        _updateRecordRotation: function (object, childTable) {
            var node, i, item, objNodeChild;
            if (object.type == "pseudoGroup") {
                node = this.nameTable[object.name];
                var children = object.children;
                for (i = 0; i < children.length; i++) {
                    item = this.nameTable[children[i]];
                    objNodeChild = childTable[children[i]];
                    if (item) {
                        if (!item.segments) {
                            if (objNodeChild) {
                                this._translate(item, objNodeChild.offsetX - item.offsetX, objNodeChild.offsetY - item.offsetY, this.nameTable);
                                this._rotate(item, objNodeChild.rotateAngle - item.rotateAngle, this.nameTable);
                            }
                        } else {
                            var objLine = childTable[item.name];
                            item.sourcePoint = objLine.sourcePoint;
                            item.targetPoint = objLine.targetPoint;
                            item.segments = objLine.segments;
                        }
                        ej.datavisualization.Diagram.DiagramContext.update(item, this);
                    }
                }
                if (node) {
                    var newangle = object.rotateAngle - node.rotateAngle;
                    node.rotateAngle += newangle;
                    if (this.selectionList[0])
                        this.selectionList[0].rotateAngle = node.rotateAngle;
                }
                ej.datavisualization.Diagram.SvgContext.updateSelector(object, this._svg, this._currZoom, this, this.model.selectedItems.constraints);
            }
            else {
                var parent = null;
                if (object.parent) {
                    parent = this.nameTable[object.parent];
                }
                if (parent && parent.container) {
                    if (parent.container.type == "canvas") {
                        ej.datavisualization.Diagram.SvgContext._alignOnCanvas1(parent, this);
                    }
                    else if (parent.container.type == "stack") {

                        ej.datavisualization.Diagram.SvgContext._alignOnStack(parent, this);
                    }

                }
                else if (object) {
                    this._clearSelection();
                    node = this._findNode(object.name);
                    this._rotate(node, object.rotateAngle - node.rotateAngle, this.nameTable);
                    ej.datavisualization.Diagram.DiagramContext.update(node, this);
                    this.addSelection(node);
                }
            }
        },
        _recordSizeChanged: function (args) {
            var node = args.object.node;
            var childTable = args.object.childTable;
            if (!node.container)
                this._updateRecordSize(node, childTable);
        },
        _updateRecordSize: function (object, childTable) {
            var node, i, childObj;
            if (object.type == "group" || object.type == "pseudoGroup") {
                if (object.type == "pseudoGroup")
                    this.nameTable[object.name] = object;
                node = this._findNode(object.name);
                var nodeChildren = this._getChildren(node.children);
                var objChildren = this._getChildren(object.children);
                for (i = 0; i < nodeChildren.length; i++) {
                    var item = this.nameTable[objChildren[i]];
                    childObj = childTable[objChildren[i]];
                    if (childObj) {
                        if (!item.segments) {
                            this._translate(item, childObj.offsetX - item.offsetX, childObj.offsetY - item.offsetY, this.nameTable);
                            this.scale(item, (childObj.width / item.width), (childObj.height / item.height), ej.datavisualization.Diagram.Point(item.offsetX, item.offsetY), this.nameTable);
                            ej.datavisualization.Diagram.DiagramContext.update(item, this);
                        } else {
                            var kk = childTable[item.name];
                            item.sourcePoint = kk.sourcePoint;
                            item.targetPoint = kk.targetPoint;
                            item.segments = kk.segments;
                            ej.datavisualization.Diagram.DiagramContext.update(item, this);
                        }
                    }
                }
                //if (node.name === object.name) {
                node.offsetX = object.offsetX;
                node.offsetY = object.offsetY;
                node.width = object.width;
                node.height = object.height;
                //}
                ej.datavisualization.Diagram.SvgContext.updateSelector(node, this._svg, this._currZoom, this, this.model.selectedItems.constraints);
            }
            else {
                var parent = null;
                if (object.parent) {
                    parent = this.nameTable[object.parent];
                }
                if (parent && parent.container) {
                    if (parent.container.type == "canvas") {
                        ej.datavisualization.Diagram.SvgContext._alignOnCanvas1(parent, this);
                    }
                    else if (parent.container.type == "stack") {

                        ej.datavisualization.Diagram.SvgContext._alignOnStack(parent, this);
                    }

                }
                else if (!object.segments) {
                    node = this._findNode(object.name);
                    this._translate(node, object.offsetX - node.offsetX, object.offsetY - node.offsetY, this.nameTable);
                    this.scale(node, object.width / node.width, object.height / node.height, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY), this.nameTable);
                    ej.datavisualization.Diagram.DiagramContext.update(node, this);
                    ej.datavisualization.Diagram.SvgContext.updateSelector(node, this._svg, this._currZoom, this, this.model.selectedItems.constraints);
                }
                else {

                }
            }

        },
        _recordRotationChanged: function (args) {
            var node = args.object.node;
            var childTable = args.object.childTable;
            if (!node.container)
                this._updateRecordRotation(node, childTable);
        },
        _recordEndPointChanged: function (args) {

            var connector, currentObject, previousObject, obj;
            if (args._isUndo) {
                connector = currentObject = args.undoObject;
                previousObject = args.redoObject;
            }
            else {
                connector = currentObject = args.redoObject;
                previousObject = args.undoObject;
            }
            if (connector.parent) {

                connector = this._findChildren(connector.parent, connector.name);
            }
            else
                connector = this._findConnector(connector.name);

            if (previousObject.targetNode) {
                obj = this.nameTable[previousObject.targetNode];
                ej.datavisualization.Diagram.Util.removeItem(obj.inEdges, previousObject);
            }
            if (previousObject.sourceNode) {
                obj = this.nameTable[previousObject.sourceNode];
                ej.datavisualization.Diagram.Util.removeItem(obj.outEdges, previousObject);
            }
            if (currentObject.targetNode) {
                obj = this.nameTable[currentObject.targetNode];
                obj.inEdges.push(currentObject.name);
            }
            if (currentObject.sourceNode) {
                obj = this.nameTable[currentObject.sourceNode];
                obj.outEdges.push(currentObject.name);
            }
            connector.targetNode = currentObject.targetNode;
            connector.sourceNode = currentObject.sourceNode;
            connector.targetPort = currentObject.targetPort;
            connector.sourcePort = currentObject.sourcePort;
            connector.sourcePoint = currentObject.sourcePoint;
            connector.targetPoint = currentObject.targetPoint;
            connector.segments = currentObject.segments;
            this._updateEdges(connector);
            this._dock(connector, this.nameTable);
            ej.datavisualization.Diagram.Util._updateConnectorSegments(connector, connector.sourcePort, connector.targetPort, this);
            ej.datavisualization.Diagram.DiagramContext._refreshSegments(connector, this);
            ej.datavisualization.Diagram.Util.updateBridging(connector, this);
            ej.datavisualization.Diagram.DiagramContext.update(connector, this);
            this._updateConnectorBridging(connector);
            this._updateSelectionHandle();
            if (this.selectionList[0])
                ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.selectionList[0], this._svg, this.model.zoomFactor);
            ej.datavisualization.Diagram.SvgContext.updateSelector(connector, this._svg, this._currZoom, this, this.model.selectedItems.constraints);
        },

        _recordLabelChanged: function (args) {
            var node = this.nameTable[args.object.name];
            if (args.object.shape && args.object.shape.type === "text") {
                node.shape.textBlock.text = args.label;
                ej.datavisualization.Diagram.DiagramContext.updateTextBlock(node, node.shape.textBlock, this);
            } else {
                node.labels[0].text = args.label;
                ej.datavisualization.Diagram.DiagramContext.updateLabel(node, node.labels[0], this);
            }
        },

        _recordGroupChanged: function (args) {
            this._clearSelection();
            var actionType = args.actionType;
            if (args.isUndo) {
                if (args.actionType === "group")
                    actionType = "ungroup";
                if (args.actionType === "ungroup")
                    actionType = "group";
            }
            var selectionList = this._getChildren(args.object.children);
            if (actionType === "group") {
                var group = new ej.datavisualization.Diagram.Group({ name: args.object.name });
                for (i = 0; i < selectionList.length; i++) {
                    group.children.push(selectionList[i]);
                    this.nameTable[selectionList[i]].parent = group.name;
                    var groupElement = this._svg.document.getElementById(selectionList[i]);
                    if (groupElement)
                        groupElement.parentNode.removeChild(groupElement);
                }
                //group.name = args.object.name;
                this.add(group);
                this._addSelection(group);
            }
            else {
                var i, node;
                node = args.object;
                var groupElement = this._svg.document.getElementById(node.name);
                if (groupElement)
                    groupElement.parentNode.removeChild(groupElement);
                var nodeChildren = this._getChildren(node.children);
                for (i = 0; i < nodeChildren.length; i++) {
                    var childNode = this.nameTable[nodeChildren[i]];
                    childNode.parent = "";
                    this._isUndo = true;
                    if (childNode.segments) {
                        ej.datavisualization.Diagram.DiagramContext.renderConnector(childNode, this);
                    }
                    else if (childNode.type != "group") {
                        ej.datavisualization.Diagram.DiagramContext.renderNode(childNode, this);
                    }
                    else {
                        ej.datavisualization.Diagram.DiagramContext.renderGroup(childNode, this);
                    }
                    this._isUndo = false;
                }
                ej.datavisualization.Diagram.Util.removeItem(this.nodes(), this._findNode(node.name));
            }
        },

        _svgdrop: function (evt, ui) {
            var args = {};
            var e = evt.originalEvent;
            if (e.preventDefault)
                e.preventDefault();
            else
                e.returnValue = false;
            var scale = this._currZoom;
            var offset = $("#" + this.element[0].id).offset();
            var coor = this._isTouchEvent(evt);
            var pageX;
            var pageY;
            if (coor) {
                pageX = coor.pageX;
                pageY = coor.pageY;
            }
            else {
                pageX = evt.pageX;
                pageY = evt.pageY;
            }
            var x = pageX + this._hScrollOffset - offset.left;
            var y = pageY + this._vScrollOffset - offset.top;
            var symbolPaletteId = ui.helper[0].getAttribute("paletteId");
            var symbolPalette = $("#" + symbolPaletteId).ejSymbolPalette("instance");
            if (symbolPaletteId) {
                var paletteItem = $.extend(true, {}, this._selectedSymbol);
                this._selectedSymbol = null;
                paletteItem.name += ej.datavisualization.Diagram.Util.randomId();
                if (paletteItem.segments) {
                    if (paletteItem.segments) {
                        ej.datavisualization.Diagram.Util._translateLine(paletteItem, x, y);
                    }
                    args = { element: paletteItem };
                    this._raiseDropEvent(args);
                    if (!args.cancel) {
                        this.add(paletteItem);
                    }
                    paletteItem = this.selectionList[0];
                }
                else {

                    var palNameTable = $.extend(true, {}, symbolPalette.nameTable);
                    paletteItem.offsetX = x / scale;
                    paletteItem.offsetY = y / scale;
                    if (paletteItem.type == "group") {
                        var children = this._getChildren(paletteItem.children);
                        for (var j = 0; j < children.length; j++) {
                            var newObj = $.extend(true, {}, palNameTable[children[j]]);
                            newObj.parent = paletteItem.name;
                            newObj.name = paletteItem.name + newObj.name;
                            children[j] = newObj.name;
                            this.nameTable[newObj.name] = newObj;
                            this.nodes().push(newObj);
                            ej.datavisualization.Diagram.SpatialUtil._updateQuad(this, this._spatialSearch, newObj);
                        }
                        paletteItem.height = paletteItem.width = 0;
                        this._updateChildBounds(paletteItem, this.nameTable);
                    }
                    args = { element: paletteItem };
                    this._raiseDropEvent(args);
                    if (!args.cancel) {
                        this.add(paletteItem);
                    }
                    paletteItem = this.selectionList[0];
                }
                this.scrollToNode(paletteItem);
                if (paletteItem.labels.length > 0 && paletteItem.labels[0].mode === "edit") {
                    this._isEditing = true;
                    this.startLabelEdit(paletteItem, paletteItem.labels[0]);
                }
                else
                    this.element[0].focus();

            }
            else {
                var node = null;
                node = this._findNodeUnderMouse(evt);
                args = { element: ui.helper, e: evt, draggable: ui.draggable, targetNode: node };
                this._raiseDropEvent(args);
            }
        },

        _isTouchEvent: function (evt) {
            if (evt.type == "touchmove" || evt.type == "touchstart" || evt.type == "touchend") {
                return evt.originalEvent ? evt.originalEvent.changedTouches[0] : evt.changedTouches[0];
            }
            return evt;
        },

        _raiseDropEvent: function (args) {
            this._raiseEvent("drop", args);
        },

        _documentmouseup: function (evt) {
            if (this.activeTool && this.activeTool.inAction && !(this.activeTool instanceof ej.datavisualization.Diagram.PolygonTool) && !(this.activeTool instanceof ej.datavisualization.Diagram.TextTool)) {
                this.activeTool.mouseup(evt, true);
            }

            if (this._selectedSymbol) {
                var displays = document.getElementsByClassName("dragClone")[0];
                if (displays != null) {
                    displays.style.display = "block";
                }
                this._remove(this.selectionList[0]);

            }

        },
        //#endregion

        //#region Helper methods
        _updateEdges: function (connector) {
            var node;
            if (ej.datavisualization.Diagram.Util.isTargetConnected(connector)) {
                node = this.nameTable[connector.targetNode];
                if (node && node.inEdges.indexOf(connector.name) == -1)
                    node.inEdges.push(connector.name);
            }
            if (ej.datavisualization.Diagram.Util.isSourceConnected(connector)) {
                node = this.nameTable[connector.sourceNode];
                if (node && node.outEdges.indexOf(connector.name) == -1)
                    node.outEdges.push(connector.name);
            }
        },

        _updateChildrenEdges: function (object) {
            var children = this._getChildren(object.children);
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child.segments) {
                    this._updateEdges(child);
                    this._dock(child, this.nameTable);
                }
                else if (child.type == "group") {
                    this._updateChildrenEdges(child);
                }
            }
        },
        _updateParent: function (object) {
            var children = this._getChildren(object.children);
            for (var i = 0; i < children.length; i++) {
                var index = this.nodes().indexOf(this.nameTable[children[i]]);
                var child = this._getNewNode(this.nameTable[children[i]]);
                if (child && child.type == "group") {
                    this._updateParent(child);
                }
                else if (child) {
                    child.parent = object.name;
                    this.nameTable[child.name] = child;
                    if (index != -1) {
                        this.nodes()[index] = child;
                    }
                }
            }
        },
        _findPortAtPoint: function (point, node) {
            var ports;
            var port;
            var location;
            var size, pt, x, y;
            var bounds;
            if (node) {
                bounds = ej.datavisualization.Diagram.Util.bounds(node, true);
                ports = node.ports;
                var matrix;
                for (var i = 0, len = ports.length; i < len; ++i) {
                    port = ports[i];
                    size = ej.datavisualization.Diagram.Size(port.size, port.size);
                    pt = ej.datavisualization.Diagram.Util._getPortPosition(port, bounds);
                    matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, node.rotateAngle, node.offsetX, node.offsetY);
                    pt = ej.Matrix.transform(matrix, pt);
                    x = pt.x - port.size / 2;
                    y = pt.y - port.size / 2;
                    location = ej.datavisualization.Diagram.Rectangle(x, y, size.width, size.height);
                    if (ej.datavisualization.Diagram.Geometry.containsPoint(location, point)) {
                        return port;
                    }
                }

            }
            return null;
        },

        _findLabelAtPoint: function (point, node) {
            var labels, label = null;
            var location;
            var size, pt, x, y, width, height;
            var bounds, textBounds, matrix;
            if (node) {
                bounds = ej.datavisualization.Diagram.Util.bounds(node);
                labels = node.labels;
                if (labels.length > 0) {
                    label = labels[0];
                    for (var i = 0, len = labels.length; i < len; i++) {
                        label = labels[i];
                        textBounds = this._svg.getElementById(node.name + "_" + label.name).getBBox();
                        width = textBounds.width == 0 ? bounds.width : textBounds.width;
                        height = textBounds.height == 0 ? label.fontSize : textBounds.height;
                        size = ej.datavisualization.Diagram.Size(width, height);
                        pt = ej.datavisualization.Diagram.Util._getLabelPosition(label, bounds);
                        pt.x = bounds.x + pt.x;
                        pt.y = bounds.y + pt.y;
                        matrix = ej.Matrix.identity();
                        if (!node.segments)
                            ej.Matrix.rotate(matrix, node.rotateAngle, node.offsetX, node.offsetY);
                        else
                            ej.Matrix.rotate(matrix, 0, bounds.x + bounds.width / 2, bounds.y + bounds.height / 2);
                        pt = ej.Matrix.transform(matrix, pt);
                        x = pt.x - size.width / 2;
                        y = pt.y - size.height / 2;
                        location = ej.datavisualization.Diagram.Rectangle(x, y, size.width, size.height);
                        if (ej.datavisualization.Diagram.Geometry.containsPoint(location, point)) {
                            break;
                        }
                    }
                }
            }
            return label;
        },

        _getCurrentZoom: function () {
            return this._currZoom;
        },

        _findNode: function (id) {
            return this.nameTable[id];
        },
        _findPort: function (node, portId) {
            var ports = node.ports;
            for (var i = 0, len = ports.length; i < len; i++) {
                if (ports[i].name === portId) {
                    return ports[i];
                }
            }
            return null;
        },

        _findConnector: function (id) {
            return this.nameTable[id];
        },

        _findChildren: function (group, name) {
            var child, innerchild;
            var children = this._getChildren(group.children);
            for (var i = 0; i < children.length; i++) {
                child = this.nameTable[children[i]];
                if (child) {
                    if (name == child.name) {
                        return child;
                    }
                    if (child.type == "group") {
                        innerchild = this._findChildren(child, name);
                        if (innerchild) return innerchild;
                    }
                }
            }
            return null;
        },

        _delete: function () {
            if (this.selectionList[0]) {
                var childTable = {};
                var edgeTable = {};
                childTable = this._getChildTable(this.selectionList[0], childTable);
                edgeTable = this._getEdgeTable(this.selectionList[0], edgeTable);
                if (!this._isUndo) {
                    var sourcePorts = {}, targetPorts = {}, connector, count, i;
                    if (!this.selectionList[0].segments) {
                        if (this.selectionList[0].outEdges.length > 0) {
                            count = this.selectionList[0].outEdges.length;
                            for (i = 0; i < count; i++) {
                                connector = this.nameTable[this.selectionList[0].outEdges[i]];
                                if (connector.sourcePort)
                                    sourcePorts[connector.name] = connector.sourcePort;
                            }

                        }
                        if (this.selectionList[0].inEdges.length > 0) {
                            count = this.selectionList[0].inEdges.length;
                            for (i = 0; i < count; i++) {
                                connector = this.nameTable[this.selectionList[0].inEdges[i]];
                                if (connector.targetPort)
                                    targetPorts[connector.name] = connector.targetPort;
                            }

                        }
                    }
                    var entry = { type: "collectionchanged", object: jQuery.extend(true, {}, this.selectionList[0]), childTable: jQuery.extend(true, {}, childTable), edgeTable: jQuery.extend(true, {}, edgeTable), sourcePorts: sourcePorts, targetPorts: targetPorts, changeType: "remove" };
                    this.addHistoryEntry(entry);
                }
                if (this.selectionList.length > 0) {
                    var obj = this.selectionList[0];
                    if (obj.type == "pseudoGroup") {
                        var children = this._getChildren(obj.children);
                        for (var i = children.length - 1; i >= 0; i--) {
                            this._remove(this.nameTable[children[i]]);
                            this._isUndo = true;
                        }
                        this._isUndo = false;
                    }
                    else {
                        if (this._nodeToHit === obj)
                            this._nodeToHit = null;
                        this._remove(obj);
                        if (obj.container && obj.parent) {
                            var parent = this.nameTable[obj.parent];
                            if (parent && parent.container) {
                                if (parent.container.type == "stack") {
                                    if (this._getChild(parent.children[0])) {
                                        this.tools.move._updateContainer(this.nameTable[this._getChild(parent.children[0])]);
                                        ej.datavisualization.Diagram.DiagramContext.update(parent, this);
                                    } else {
                                        var prePar = this.nameTable[parent.parent];
                                        if (prePar) {
                                            this._remove(prePar);
                                        }
                                    }
                                }

                            }
                        }
                    }
                }
                this._clearSelection();
            }
        },
        _getEdgeTable: function (group, edgeTable) {
            var edges, len, i, j, depend;
            if (!group.segments) {
                if (group.type == "group") {
                    var children = this._getChildren(group.children);
                    for (i = 0; i < children.length; i++) {
                        var node = this.nameTable[children[i]];
                        if (node.inEdges && node.inEdges.length > 0) {
                            edges = node.inEdges;
                            for (j = 0, len = edges.length; j < len; j++) {
                                depend = this.nameTable[edges[j]];
                                var table = edgeTable[depend.name] = $.extend(true, {}, depend);
                            }
                        }
                        if (node.outEdges && node.outEdges.length > 0) {
                            edges = node.outEdges;
                            for (j = 0, len = edges.length; j < len; j++) {
                                depend = this.nameTable[edges[j]];
                                var table = edgeTable[depend.name] = $.extend(true, {}, depend);
                            }
                        }
                    }
                }
                if (group.inEdges && group.inEdges.length > 0) {
                    edges = group.inEdges;
                    for (j = 0, len = edges.length; j < len; j++) {
                        depend = this.nameTable[edges[j]];
                        var table = edgeTable[depend.name] = $.extend(true, {}, depend);
                    }
                }
                if (group.outEdges && group.outEdges.length > 0) {
                    edges = group.outEdges;
                    for (j = 0, len = edges.length; j < len; j++) {
                        depend = this.nameTable[edges[j]];
                        var table = edgeTable[depend.name] = $.extend(true, {}, depend);
                    }
                }
            }
            return edgeTable;
        },
        _remove: function (obj, dependent) {
            if (obj) {
                if (obj.segments) var type = "connector";
                else type = "node";
                var dependent = dependent ? ej.datavisualization.Diagram.dependentconnector.dependent : ej.datavisualization.Diagram.dependentconnector.independent;
                var args = { changeType: "remove", element: obj, cancel: false, dependent: dependent };
                if (!obj.segments) { args.adjustDependent = true; args.deleteDependent = true; }
                this._raiseEvent(type + "CollectionChange", args);
                if (!args.cancel) {
                    if (ej.datavisualization.Diagram.Util.canDelete(obj)) {
                        var name = obj.name;
                        if (obj.type == "group" && obj.type != "pseudoGroup") {
                            var children = this._getChildren(obj.children);
                            for (var i = 0; i < children.length; i++) {
                                var child = this.nameTable[children[i]];
                                if (child && !ej.datavisualization.Diagram.Util.canDelete(child)) return;
                            }
                        }
                        if (!obj.segments) {
                            this._disConnect(obj, args);

                            //if (obj.type != "group")
                            this._removeConnector(obj, args);
                            ej.datavisualization.Diagram.Util.removeItem(this.nodes(), this.nameTable[obj.name]);
                        } else {
                            this._removeEdges(obj);
                            obj.sourceNode = obj.sourcePort = obj.targetNode = obj.targetPort = null;
                            ej.datavisualization.Diagram.Util.removeItem(this.connectors(), this.nameTable[obj.name]);
                        }
                        if (obj.shape || obj.segments) {
                            ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(this._spatialSearch, this._spatialSearch.quadTable[obj.name], obj);
                            ej.datavisualization.Diagram.SpatialUtil._updateBounds(this, this._spatialSearch, obj);
                            if (obj.segments)
                                this._updateConnectorBridging(obj);
                        }
                        if (obj.parent) {
                            var parent = this.nameTable[obj.parent];
                            if (parent && parent.type == "group") {
                                ej.datavisualization.Diagram.Util.removeItem(parent.children, obj.name);
                                ej.datavisualization.Diagram.Util._updateGroupBounds(parent, this);
                            }
                        }
                        delete this.nameTable[name];
                        var element = this._svg.getElementById(obj.name);
                        if (ej.browserInfo().name === "msie") {
                            if (obj.shape && obj.shape.html && element) {
                                var htmlelement = document.getElementById(obj.name + "_parentdiv");
                                htmlelement.parentNode.removeChild(htmlelement);
                            } else if (obj.type == "group")
                                this._checkForHtmlNode(obj);
                        }
                        if (obj.type == "group" && obj.type != "pseudoGroup") {
                            this._removeChildren(obj, args);
                        }
                        this._removeElement(obj);
                        if (obj.type == "group" && obj.container) {
                            ej.datavisualization.Diagram.SvgContext._removephases(obj, this);
                        }
                        if (element && element.parentNode)
                            element.parentNode.removeChild(element);
                        if (this.selectionList[0]) {
                            this._clearSelection();
                        }
                    }
                }
            }
        },

        _removeConnector: function (node, args) {
            var edges;
            var connector;
            var i, len;
            if (!node.segments) {
                //If adjustDependent is false all connector associated with Nodes get deleted.
                if (args.deleteDependent && !(args.adjustDependent)) {
                    if (node.inEdges && node.inEdges.length > 0) {
                        edges = node.inEdges;
                        for (i = edges.length - 1 ; i >= 0; i--) {
                            //Remove the Connector
                            this._updateConnection(this.nameTable[edges[i]], true);
                        }
                    }
                    if (node.outEdges && node.outEdges.length > 0) {
                        edges = node.outEdges;
                        for (i = 0, len = edges.length; i < len; i++) {
                            //Remove the Connector
                            this._updateConnection(this.nameTable[edges[i]], true);
                        }
                    }
                }
                //If both deleteDependent & adjustDependent are true changes to Visio behaviour
                if (args.deleteDependent && args.adjustDependent) {
                    if (node.inEdges && node.inEdges.length == 0 && node.outEdges.length > 0) {
                        edges = node.outEdges;
                        for (i = edges.length - 1 ; i >= 0; i--) {
                            //Remove the Connector
                            this._updateConnection(this.nameTable[edges[i]], true);
                        }
                    }
                    else if (node.outEdges && node.outEdges.length == 0 && node.inEdges.length > 0) {
                        edges = node.inEdges;
                        for (i = edges.length - 1 ; i >= 0; i--) {
                            //Remove the Connector
                            if (this.nameTable[edges[i]])
                                this._updateConnection(this.nameTable[edges[i]], true);
                        }
                    }
                    else if ((node.inEdges && node.inEdges.length == 1 || node.inEdges.length > 1) && (node.outEdges.length == 1)) {
                        edges = node.outEdges;
                        for (i = 0, len = edges.length; i < len; i++) {
                            //Remove the Connector
                            this._updateConnection(this.nameTable[edges[i]], true);
                        }
                    }
                    else if (!(node.inEdges && node.inEdges.length > 1 && node.outEdges.length > 1)) {
                        edges = node.inEdges;
                        for (i = 0, len = edges.length; i < len; i++) {
                            //Remove the Connector
                            this._updateConnection(this.nameTable[edges[i]], true);
                        }
                    }
                }
            }
        },

        _updateConnection: function (connector, args) {
            if (connector) {
                this._remove(connector, args);
                this.updateConnector(connector.name);
            }
        },
        _removeElement: function (element) {
            for (var i = 1; i < this._views.length; i++) {
                var view = this._views[i];
                this._views[view].context.removeChild(element, this._views[view]);
            }

        },
        _disConnect: function (node, args, isChild) {
            var edgesIn, edgesOut, connector, parentNode, targetNode, data;
            var i, j, leni, lenj;
            if (args.deleteDependent && args.adjustDependent && !isChild) {
                if (node.inEdges && node.inEdges.length > 0 && node.outEdges.length > 0) {
                    edgesIn = node.inEdges;
                    edgesOut = node.outEdges;
                    if ((node.inEdges.length > 1 || node.inEdges.length == 1) && node.outEdges.length == 1) {
                        for (i = 0, leni = edgesIn.length; i < leni; i++) {
                            if (this.nameTable[edgesIn[i]] && this.nameTable[edgesOut[0]]) {
                                if ((this.nameTable[edgesIn[i]].targetNode == this.nameTable[edgesOut[0]].sourceNode)) {
                                    targetNode = this.nameTable[this.nameTable[edgesOut[0]].targetNode];
                                    if (targetNode) {
                                        data = $.extend(true, {}, targetNode);
                                        this.nameTable[edgesIn[i]].targetNode = this.nameTable[edgesOut[0]].targetNode;
                                        this.nameTable[edgesIn[i]].targetPort = this.nameTable[edgesOut[0]].targetPort;
                                        targetNode.inEdges[i] = this.nameTable[edgesIn[i]].name;
                                    }
                                    //Updating the Connector Dock and Connector
                                    ej.datavisualization.Diagram.Util.dock(this.nameTable[edgesIn[i]], this.nameTable);
                                    ej.datavisualization.Diagram.DiagramContext.update(this.nameTable[edgesIn[i]], this);
                                }
                            }
                        }
                        if (this.nameTable[edgesOut[0]]) {
                            this.nameTable[edgesOut[0]].sourceNode = null;
                            this.nameTable[edgesOut[0]].sourcePort = null;
                        }
                    }
                    else if (!(node.inEdges.length > 1 && node.outEdges.length > 1)) {
                        // Need to code when many in and only one out 
                        for (i = 0, leni = edgesIn.length; i < leni; i++) {
                            if (node.outEdges.length > 0) {
                                parentNode = this.nameTable[this.nameTable[edgesIn[i]].sourceNode];
                                data = $.extend(true, {}, parentNode);
                                for (j = 0, lenj = edgesOut.length; j < lenj; j++) {
                                    if ((this.nameTable[edgesIn[i]].targetNode == this.nameTable[edgesOut[j]].sourceNode)) {
                                        this.nameTable[edgesOut[j]].sourceNode = this.nameTable[edgesIn[i]].sourceNode;
                                        this.nameTable[edgesOut[j]].sourcePort = this.nameTable[edgesIn[i]].sourcePort;
                                        parentNode.outEdges[data.outEdges.length + j] = this.nameTable[edgesOut[j]].name;
                                        //Updating the Connector Dock and Connector
                                        ej.datavisualization.Diagram.Util.dock(this.nameTable[edgesOut[j]], this.nameTable);
                                        ej.datavisualization.Diagram.DiagramContext.update(this.nameTable[edgesOut[j]], this);
                                    }
                                }
                                this.nameTable[edgesIn[i]].targetNode = null;
                                this.nameTable[edgesIn[i]].targetPort = null;
                            }
                        }
                    }
                } return;
            }
            if (node.inEdges && node.inEdges.length > 0) {
                edgesIn = node.inEdges;
                for (i = 0, leni = edgesIn.length; i < leni; i++) {
                    connector = this.nameTable[edgesIn[i]];
                    connector.targetNode = null;
                    connector.targetPort = null;
                }
            }
            if (node.outEdges && node.outEdges.length > 0) {
                edgesOut = node.outEdges;
                for (i = 0, leni = edgesOut.length; i < leni; i++) {
                    connector = this.nameTable[edgesOut[i]];
                    connector.sourceNode = null;
                    connector.sourcePort = null;
                }
            }
        },

        _removeEdges: function (connector) {
            if (connector.targetNode) {
                if (this.nameTable[connector.targetNode] && this.nameTable[connector.targetNode].inEdges)
                    ej.datavisualization.Diagram.Util.removeItem(this.nameTable[connector.targetNode].inEdges, connector.name);
            }
            if (connector.sourceNode) {
                if (this.nameTable[connector.sourceNode] && this.nameTable[connector.sourceNode].outEdges)
                    ej.datavisualization.Diagram.Util.removeItem(this.nameTable[connector.sourceNode].outEdges, connector.name);
            }
        },

        _selectionContains: function (node) {
            if (this._hasSelection() && node)
                for (var i = 0; i < this.selectionList.length; i++) {
                    if (node.name === this.selectionList[i].name)
                        return true;
                }
            return false;
        },

        _addSelection: function (selectedShape) {

            if (selectedShape && ej.datavisualization.Diagram.Util.canSelect(selectedShape)) {
                if (!this._selectionContains(selectedShape)) {
                    this.selectionList.push(selectedShape);
                    var args = { changeType: "insert", element: selectedShape, cancel: false };
                    if (!this._selectedSymbol)
                        this._raiseEvent("selectionChange", args);

                    if (!args.cancel) {
                        this._updateSelectorObject(selectedShape);
                        ej.datavisualization.Diagram.SvgContext.renderSelector(selectedShape, this._svg, this._adornerLayer, this._currZoom,
                            this.model.selectedItems.constraints);
                        if ((this.model.selectedItems.userHandles != null && this.model.selectedItems.userHandles.length > 0)) {
                            var isMultipleSelection = false;
                            if (selectedShape.type == "pseudoGroup")
                                isMultipleSelection = true;
                            if (this.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles)
                                ej.datavisualization.Diagram.SvgContext.renderUserHandles(this.model.selectedItems.userHandles, selectedShape, this._svg, isMultipleSelection, this._currZoom, this._adornerLayer);
                        }
                    }
                    else {
                        ej.datavisualization.Diagram.Util.removeItem(this.selectionList, selectedShape);
                    }
                }
            }
        },

        updateSelector: function (option) {
            if (this._selectedItem != "") {
                var options = {};
                if (option.offsetX)
                    options.offsetX = Number(typeof option.offsetX === 'function' ? option.offsetX() : option.offsetX);

                if (option.offsetY)
                    options.offsetY = Number(typeof option.offsetY === 'function' ? option.offsetY() : option.offsetY);

                if (option.width)
                    options.width = Number(typeof option.width === 'function' ? option.width() : option.width);

                if (option.height)
                    options.height = Number(typeof option.height === 'function' ? option.height() : option.height);

                if (option.rotateAngle)
                    options.rotateAngle = Number(typeof option.rotateAngle === 'function' ? option.rotateAngle() : option.rotateAngle);

                this.updateNode(this._selectedItem, options);
            }
            if (option.userHandles) {
                this.model.selectedItems.userHandles = option;
                this._initHandles();
            }
        },

        _updateSelectorObject: function (selectedShape) {
            if (!selectedShape.segments) {
                this._selectorOffsetX(selectedShape.offsetX);
                this._selectorOffsetY(selectedShape.offsetY);
                this._selectorWidth(selectedShape.width);
                this._selectorHeight(selectedShape.height);
                this._selectorRotateAngle(selectedShape.rotateAngle);
                this._selectedItem = selectedShape.name;
            }
            if (selectedShape.type == "pseudoGroup") {
                for (var i = 0; i < selectedShape.children.length; i++) {
                    var child = selectedShape.children[i];
                    if (typeof (child) === "object") {
                        this.model.selectedItems.children.push(child);
                    }
                    else if (typeof (child) === "string") {
                        this.model.selectedItems.children.push(this.nameTable[child]);
                    }
                }
            }
            else {
                this.model.selectedItems.children.push(selectedShape);
            }
        },

        _clearSelectorObject: function () {
            this._selectorOffsetX(0);
            this._selectorOffsetY(0);
            this._selectorWidth(0);
            this._selectorHeight(0);
            this._selectorRotateAngle(0);
            this._selectedItem = "";
            this.model.selectedItems.children = [];
        },

        _raiseEvent: function (type, args) {
            args.elementType = this._getElementType(args.element);
            return this._trigger(type, args);

        },
        _clearSelection: function () {
            if (this._isEditing && this.selectionList.length > 0) {
                this._endEdit();
            }
            var args = { changeType: "remove", element: this.selectionList, cancel: false };
            if (!this._selectedSymbol)
                this._raiseEvent("selectionChange", args);
            if (!args.cancel) {
                this._clearSelectorObject();
                if (this.selectionList[0] && this.selectionList[0].type == "pseudoGroup") {
                    ej.datavisualization.Diagram.Util.removeItem(this.nodes(), this.selectionList[0]);
                    delete this.nameTable[this.selectionList[0].name];
                }
                ej.datavisualization.Diagram.Util.clear(this.selectionList);
                ej.datavisualization.Diagram.SvgContext.clearSelector(this._svg, this._adornerLayer);

            }
        },

        _updateSelectionHandle: function (isDragging) {
            if (this.selectionList.length > 0) {
                var shape = this.nameTable[this.selectionList[0].name];
                var constraints = this.model.selectedItems.constraints;
                if (isDragging && (this.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles))
                    constraints = constraints & ~ej.datavisualization.Diagram.SelectorConstraints.UserHandles;
                this._updateSelectorObject(shape);
                ej.datavisualization.Diagram.SvgContext.updateSelector(shape, this._svg, this._currZoom, this, constraints);
                if ((this.model.selectedItems.userHandles != null && this.model.selectedItems.userHandles.length > 0)) {
                    var isMultipleSelection = false;
                    if (shape.type == "pseudoGroup")
                        isMultipleSelection = true;
                    if (this.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles)
                        ej.datavisualization.Diagram.SvgContext.updateUserHandles(this.model.selectedItems.userHandles, shape, this._svg, isMultipleSelection, isDragging, this._currZoom);
                }
            }
        },

        _hasSelection: function () {
            return this.selectionList.length > 0;
        },

        _checkToolToActivate: function (evt, node, point) {
            var success = false;
            if (node) {
                if (node.segments && (evt.ctrlKey && evt.shiftKey) || (evt.ctrlKey && evt.altKey)) {
                    this._toolToActivate = "endPoint";
                    this._currentCursor = "move";
                    success = true;
                }
                if (!success) {
                    if (this._selectionContains(node)) {
                        if (node.segments) {
                            success = this._canActivateEndPointTool(evt, node, point);
                        }
                        else {
                            success = this._canActivateResizeTool(evt, node, point);
                            if (!success) {
                                success = this._canActivateRotateTool(evt, node, point);
                            }
                        }
                        if (!success) {
                            success = this._canActivateUserHandle(evt, node, point);
                        }
                        if (!success) {
                            success = this._canActivateMoveTool(evt, node, point);
                        }
                        if (!success) {
                            success = this._canActivatephaseTool(evt, point);
                        }
                    }
                    else {
                        success = this._canActivateMoveTool(evt, node, point);
                    }
                }
            }
            else {
                success = this._canActivatephaseTool(evt, point);
            }
            if (!success) {
                if (this.tool() & ej.datavisualization.Diagram.Tool.ZoomPan) {
                    this._toolToActivate = "panTool";
                    this._currentCursor = "pointer";
                }
                else {
                    this._toolToActivate = "select";
                    this._currentCursor = "default";
                }
            }
            if (this._toolToActivate != "rotate") {
                this._svg.document.removeAttribute("class");
            }
            return success;
        },

        _canActivatephaseTool: function (evt, point) {
            if ($(evt.target).parents("g").first()[0]) {
                var id = $(evt.target).parents("g").first()[0].id;
                var phase = this._getSeperetor(id);
                if (phase) {
                    if (phase.orientation == "horizontal")
                        this._currentCursor = "e-resize";
                    else
                        this._currentCursor = "n-resize";
                }
                else
                    this._currentCursor = "default";
                this._toolToActivate = "phase";

                return true;
            }
        },

        _canActivateUserHandle: function (evt) {
            if (this._isUserHandle(evt)) {
                var handleName = $(evt.target).parents("g").first().context.id.split("_")[0];
                this._toolToActivate = handleName;
                this._currentCursor = this.tools[this._toolToActivate].cursor;
                return true;
            }
            return false;
        },

        _canActivateEndPointTool: function (evt, connector) {
            if (connector) {
                var endPointHandle = evt.target.getAttribute("class");
                if (endPointHandle && ((endPointHandle === "targetEndPoint" && ej.datavisualization.Diagram.Util.canDragTargetEnd(connector)) ||
                    (endPointHandle === "sourceEndPoint" && ej.datavisualization.Diagram.Util.canDragSourceEnd(connector)) ||
                (endPointHandle.match("bezierpoint") && ej.datavisualization.Diagram.Util.canDragSegmentThumbs(connector)) ||
                    endPointHandle == "segmentEnd")) {
                    this._toolToActivate = "endPoint";
                    this._currentCursor = "move";
                    return true;
                }
            }
            return false;
        },

        _canActivateResizeTool: function (evt, node) {
            if (ej.datavisualization.Diagram.Util.canResize(node) && (this.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.Resizer)) {
                var dir = evt.target.getAttribute("class");
                if (dir === "nw-resize" || dir === "n-resize" || dir === "ne-resize" || dir === "w-resize" || dir === "e-resize" || dir === "sw-resize" || dir === "s-resize" || dir === "se-resize") {
                    this._toolToActivate = "resize";
                    if ((node.rotateAngle >= 0 && node.rotateAngle < 25) || (node.rotateAngle >= 160 && node.rotateAngle <= 200) || (node.rotateAngle >= 340 && node.rotateAngle <= 360)) {
                        this._currentCursor = dir;
                    }
                    else if ((node.rotateAngle >= 25 && node.rotateAngle <= 65) || (node.rotateAngle >= 205 && node.rotateAngle <= 240)) {

                        if (dir === "n-resize" || dir === "s-resize") {
                            this._currentCursor = "ne-resize";
                        }
                        else if (dir === "nw-resize" || dir === "se-resize") {
                            this._currentCursor = "n-resize";
                        }
                        else if (dir === "e-resize" || dir === "w-resize") {
                            this._currentCursor = "nw-resize";
                        }
                        else {
                            this._currentCursor = "e-resize";
                        }
                    }
                    else if ((node.rotateAngle >= 70 && node.rotateAngle <= 110) || (node.rotateAngle >= 250 && node.rotateAngle <= 290)) {
                        if (dir === "n-resize" || dir === "s-resize") {
                            this._currentCursor = "e-resize";
                        }
                        else if (dir === "nw-resize" || dir === "se-resize") {
                            this._currentCursor = "ne-resize";
                        }
                        else if (dir === "e-resize" || dir === "w-resize") {
                            this._currentCursor = "n-resize";
                        }
                        else {
                            this._currentCursor = "nw-resize";
                        }
                    }
                    else if ((node.rotateAngle >= 115 && node.rotateAngle <= 155) || (node.rotateAngle >= 295 && node.rotateAngle <= 335)) {
                        if (dir === "n-resize" || dir === "s-resize") {
                            this._currentCursor = "nw-resize";
                        }
                        else if (dir === "nw-resize" || dir === "se-resize") {
                            this._currentCursor = "e-resize";
                        }
                        else if (dir === "e-resize" || dir === "w-resize") {
                            this._currentCursor = "ne-resize";
                        }
                        else {
                            this._currentCursor = "n-resize";
                        }
                    }
                    return true;
                }
            }
            return false;
        },

        _canActivateMoveTool: function (evt, node) {
            var findNode = this._findNodeUnderMouse(evt);
            if (findNode && findNode.name === node.name) {
                var canMove = true;
                if (node.parent) {
                    if (this.selectionList.length > 0 && this._selectionContains(node))
                        canMove = true;
                    else
                        canMove = false;
                }
                if (canMove && ej.datavisualization.Diagram.Util.canMoveLabel(node)) {
                    var id = evt.target.id.split('_');
                    if (id[id.length - 1] == "lblbg") {
                        this._toolToActivate = "move";
                        this._currentCursor = "pointer";
                        return true;
                    }
                }

                if (ej.datavisualization.Diagram.Util.canMove(node)) {
                    this._toolToActivate = "move";
                    if (this.selectionList.length > 0 && (this._selectionContains(node) || (this.selectionList[0].children && this._findChildren(this.selectionList[0], node.name)))) {
                        this._currentCursor = "move";
                    }
                    else {
                        this._currentCursor = "default";
                    }
                    return true;
                }
            }
            return false;
        },

        _canActivateRotateTool: function (evt, node) {
            if (ej.datavisualization.Diagram.Util.canRotate(node) && (this.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.Rotator)) {
                var rotateHandle = evt.target.getAttribute("class");
                if (rotateHandle === "rotate") {
                    this._toolToActivate = "rotate";
                    this._svg.document.setAttribute("class", "svg-rotate");
                    this._currentCursor = "";
                    return true;
                }
            }
            return false;
        },

        _canActivatePivotTool: function (evt) {
            var pivotHandle = evt.target.getAttribute("class");
            if (pivotHandle === "pivot") {
                this._toolToActivate = "pivot";
                this._currentCursor = "default";
                return true;
            }

            return false;
        },

        _updateCursor: function () {
            this._svg.document.style.cursor = this._currentCursor;
        },

        _getResizeCursor: function (resizeDirection) {
            var cursor = "default";
            switch (resizeDirection) {
                case "topleft": cursor = "nw-resize";
                    break;
                case "topcenter": cursor = "n-resize";
                    break;
                case "topright": cursor = "ne-resize";
                    break;
                case "middleleft": cursor = "w-resize";
                    break;
                case "middleright": cursor = "e-resize";
                    break;
                case "bottomleft": cursor = "sw-resize";
                    break;
                case "bottomcenter": cursor = "s-resize";
                    break;
                case "bottomright": cursor = "se-resize";
                    break;
            }
            return cursor;
        },

        _startEdit: function (shape) {
            var label;
            var centerX, centerY;
            var bbox;
            var nodeBounds;
            var bounds;
            var curZoomfactor;
            var matrix = ej.Matrix.identity();
            ej.Matrix.rotate(matrix, shape.rotateAngle, shape.width / 2, shape.height / 2);
            if (shape.shape && shape.shape.type === "text") {
                if (this._svg.getElementById(shape.name + "_shape") !== null)
                    bbox = this._svg.getElementById(shape.name + "_shape").getBBox();
                else
                    bbox = { x: shape.offsetX - shape.width / 2, y: shape.offsetY - shape.height / 2, width: shape.width, height: shape.height };
                label = shape.shape.textBlock;
                if (label) {
                    nodeBounds = ej.datavisualization.Diagram.Util.bounds(shape);
                    bounds = new ej.datavisualization.Diagram.Rectangle(bbox.x - label.fontSize, bbox.y - label.fontSize, bbox.width + label.fontSize / 2, bbox.height + label.fontSize / 2);
                    curZoomfactor = this._currZoom;
                    var diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Util._getLabelPosition(label, nodeBounds));
                    centerX = shape.offsetX - shape.width / 2 + diff.x;
                    centerY = shape.offsetY - shape.height / 2 + diff.y;
                    if (label.horizontalAlignment == "left")
                        centerX += bbox.width / 2;
                    else if (label.horizontalAlignment == "right")
                        centerX -= bbox.width / 2;
                    if (label.verticalAlignment == "top")
                        centerY += bbox.height / 2;
                    else if (label.verticalAlignment == "bottom")
                        centerY -= bbox.height / 2;
                    if (bbox.width === 0 || bbox.height === 0) {
                        bbox = ej.datavisualization.Diagram.Util.bounds(shape);
                        bounds.width = bbox.width == 0 ? 50 : nodeBounds.width * curZoomfactor;
                        bounds.x = (centerX * curZoomfactor - bounds.width / 2 * curZoomfactor) - this._hScrollOffset;

                        bounds.height = label.fontSize;
                        bounds.y = (centerY * curZoomfactor - bounds.height / 2 * curZoomfactor) - this._vScrollOffset;
                    }
                    else {
                        bounds.width = 50;
                        bounds.height = label.fontSize;
                        bounds.x = (centerX * curZoomfactor - (bounds.width / 2 * curZoomfactor)) - this._hScrollOffset;
                        bounds.y = (centerY * curZoomfactor - (bounds.height / 2 * curZoomfactor)) - this._vScrollOffset;
                    }
                    this._boundingBox = bounds;
                    this._createEditBox(label, bounds.x, bounds.y, bounds.width, bounds.height, shape);
                    this._isEditing = true;
                }
            }
            else {
                if (shape.labels.length > 0) {
                    if (this.activeTool.name === "textTool") {
                        label = this.activeTool.getLabelUnderMouse();
                        if (label)
                            label = shape.labels[0];
                    }
                    else
                        label = shape.labels[0];
                }
                else {
                    var mNode = this._findNode(shape.name);
                    label = new ej.datavisualization.Diagram.Label({ "name": "label" + ej.datavisualization.Diagram.Util.randomId() });
                    shape.labels.push(label);
                    var parent = (mNode !== shape) ? mNode : null;
                    ej.datavisualization.Diagram.DiagramContext.addNodeLabel(shape, label, parent, this);
                    if (this.activeTool.name === "textTool")
                        this.activateTool.activeLabel = label;
                }
                if (label && !label.readOnly) {
                    bbox = this._svg.getElementById(shape.name + "_" + label.name).getBBox();
                    nodeBounds = ej.datavisualization.Diagram.Util.bounds(shape);
                    bounds = new ej.datavisualization.Diagram.Rectangle(bbox.x, bbox.y, bbox.width, bbox.height);
                    curZoomfactor = this._currZoom;
                    var position = ej.datavisualization.Diagram.Util._getLabelPosition(label, nodeBounds);
                    if (shape.segments) {
                        centerX = nodeBounds.x + position.x;
                        centerY = nodeBounds.y + position.y;
                    }
                    else {
                        var diff = ej.Matrix.transform(matrix, position);
                        centerX = shape.offsetX - shape.width / 2 + diff.x;
                        centerY = shape.offsetY - shape.height / 2 + diff.y;
                        if (label.horizontalAlignment == "left")
                            centerX += bbox.width / 2;
                        else if (label.horizontalAlignment == "right")
                            centerX -= bbox.width / 2;
                        if (label.verticalAlignment == "top")
                            centerY += bbox.height / 2;
                        else if (label.verticalAlignment == "bottom")
                            centerY -= bbox.height / 2;
                    }
                    if (bbox.width === 0 || bbox.height === 0) {
                        bbox = ej.datavisualization.Diagram.Util.bounds(shape);
                        if (!shape.shape) {
                            bounds.width = bbox.width < 50 ? 50 : nodeBounds.width * curZoomfactor;
                            bounds.x = (centerX * curZoomfactor - bounds.width / 2 * curZoomfactor) - this._hScrollOffset;
                        }
                        else {
                            bounds.width = bbox.width < 50 ? 50 : (nodeBounds.width * curZoomfactor);
                            bounds.x = (centerX * curZoomfactor - bounds.width / 2) - this._hScrollOffset;
                        }
                        bounds.height = label.fontSize;
                        bounds.y = (centerY * curZoomfactor - bounds.height / 2 * curZoomfactor) - this._vScrollOffset;
                    }
                    else {
                        bounds.x = (centerX * curZoomfactor - (bounds.width / 2 * curZoomfactor)) - this._hScrollOffset;
                        bounds.y = (centerY * curZoomfactor - (bounds.height / 2 * curZoomfactor)) - this._vScrollOffset;
                    }
                    this._boundingBox = bounds;
                    this._createEditBox(label, bounds.x, bounds.y, bounds.width, bounds.height, shape);
                    this._isEditing = true;
                }
            }
        },

        _createEditBox: function (label, x, y, width, height, shape) {
            var nodeBounds = ej.datavisualization.Diagram.Util.bounds(shape);
            var div = document.createElement("div");

            var attr = {
                "id": this.element[0].id + "_editBoxDiv",
                "class": "edit",
                "style": "top:" + y + "px;left:" + x + "px;width:" + width + "px;height:" + height + "px;" +
                    "font-family:" + label.fontFamily + ";font-size:" + label.fontSize + "px;min-width: 50px;min-height:" + label.fontSize + "px;",
            };
            ej.datavisualization.Diagram.Util.attr(div, attr);
            var textBox = document.createElement("textarea");
            attr = {
                "id": this.element[0].id + "_editBox",
                "class": "editBox",
                "style": "font-size:" + label.fontSize + "px;font-family:" + label.fontFamily + ";min-height:" + label.fontSize + "px;line-height:" + label.fontSize + "px;",
                "nodeWidth": nodeBounds.width, "nodeHeight": nodeBounds.height, "fontSize": label.fontSize, "nodeOffsetX": shape.offsetX, "nodeOffsetY": shape.offsetY, "containerName": shape.name
            };
            ej.datavisualization.Diagram.Util.attr(textBox, attr);
            textBox.value = label.text;
            div.appendChild(textBox);
            $(this._canvas).append(div);

            if (label.text !== "") {
                this._updateEditor(null, div, textBox, nodeBounds.width, label.fontSize);
            }
            this._on($(textBox), "focusout", this._editboxfocusout);
            this._on($(textBox), "keyup", this._editBoxKeyUp);
            this._on($(textBox), "input", this._editBoxTextChange);
            textBox.focus();
            textBox.select();
        },

        _editBoxKeyUp: function (evt) {
            this._updateLabelPosition(evt);
        },

        _editBoxTextChange: function (evt) {
            this._updateLabelPosition(evt);
        },

        _updateEditBox: function (x, y) {
            var editBox = document.getElementById(this.element[0].id + "_editBoxDiv");
            if (editBox) {
                editBox.style.left = editBox.offsetLeft - x + "px";
                editBox.style.top = editBox.offsetTop - y + "px";
            }
        },

        _editboxfocusout: function () {
            this._endEdit();
        },

        _updateLabelPosition: function (evt) {
            var minWidth = 50;
            var curZoomfactor = this._currZoom;
            var parentBoundary = this._boundingBox;
            var fontSize = Number(evt.target.getAttribute("fontSize"));
            var nodeWidth = Number(evt.target.getAttribute("nodeWidth"));
            var conCenterX = parentBoundary.x + (parentBoundary.width / 2);
            var conCenterY = parentBoundary.y + (parentBoundary.height / 2);
            var bounds = this._textLength(evt);

            var width;
            if (bounds.width === 0) {
                width = parentBoundary.width < minWidth ? minWidth : parentBoundary.width;
                evt.target.parentNode.style.width = width + "px";
                evt.target.parentNode.style.left = conCenterX - width / 2 + "px";
            }
            else {
                if (bounds.width <= (nodeWidth * curZoomfactor))
                    width = bounds.width < minWidth ? minWidth : bounds.width;
                else
                    width = nodeWidth < minWidth ? minWidth : (nodeWidth * curZoomfactor);
                evt.target.parentNode.style.width = width + "px";
                evt.target.parentNode.style.left = conCenterX - (width / 2) + "px";
            }
            if (bounds.height === 0) {
                evt.target.style.height = fontSize + "px";
                evt.target.parentNode.style.top = conCenterY - fontSize / 2 + 'px';
            }
            else {
                this._updateEditor(evt, evt.target.parentNode, evt.target, nodeWidth, fontSize);
            }
        },

        _updateEditor: function (evt, div, textBox, nodeWidth, fontSize) {
            var offsetX, offsetY;
            var elHeight;
            var bounds = this._textLength(evt);
            var curZoomfactor = this._currZoom;
            var minWidth = 50;
            var x = this._boundingBox.x;
            var y = this._boundingBox.y;
            var width = this._boundingBox.width;
            var height = this._boundingBox.height;

            var str = textBox.value;
            var line = str.split('\n');

            var temp = (nodeWidth * curZoomfactor) < bounds.width ? (nodeWidth * curZoomfactor) : bounds.width;
            var elWidth = temp < minWidth ? minWidth : temp;
            div.style.width = elWidth + "px";
            if (evt)
                offsetX = (elWidth - width) / 2;
            else
                offsetX = (elWidth - width * curZoomfactor) / 2;
            div.style.left = x - offsetX - fontSize / 4 + "px";

            if (line.length > 1 || bounds.width >= nodeWidth) {
                if (ej.browserInfo().name === "mozilla")
                    elHeight = textBox.scrollHeight - 5;
                else
                    elHeight = textBox.scrollHeight - 4;
                textBox.style.height = 'auto';
            }
            else
                elHeight = fontSize;

            textBox.style.height = elHeight + "px";
            if (evt)
                offsetY = (elHeight - height) / 2;
            else
                offsetY = (elHeight - height * curZoomfactor) / 2;
            this._boundingBox = new ej.datavisualization.Diagram.Rectangle(x - offsetX, y - offsetY, elWidth, elHeight);
            div.style.top = y - offsetY - fontSize / 4 + "px";
        },

        _textLength: function (evt) {
            var temp = document.createElement("div");
            var textElement = document.getElementById(this.element[0].id + "_editBox");
            var attr = {
                "id": this.element[0].id + "_editBoxHiddenDiv",
                "style": "position:absolute; width:" + textElement.width + "px;height:" + textElement.height + "px;" +
                         "font-size:" + textElement.style.fontSize + "px;font-family:" + textElement.style.fontFamily + ";padding: 4px;word-wrap: break-word;white-space:pre-wrap;",
            };
            ej.datavisualization.Diagram.Util.attr(temp, attr);
            if (evt) {
                temp.innerHTML = evt.target.value;
            } else {
                temp.innerHTML = textElement.value;
            }
            document.body.appendChild(temp);
            var bounds = temp.getBoundingClientRect();
            document.body.removeChild(temp);
            return bounds;
        },

        _endEdit: function () {
            var args, entry;
            var editBox = document.getElementById(this.element[0].id + "_editBox");
            if (editBox) {
                var shape = this._findNode(editBox.getAttribute("containerName"));;
                if (this.activeTool.name === "textTool")
                    shape = this.activeTool.selectedObject;
                else if (!shape) {
                    for (var i = 0; i < this.selectionList.length; i++) {
                        var mNode = this.selectionList[i];
                        if (typeof mNode.labels.length != "undefined" && mNode.labels.length > 0 && mNode.labels[0].mode === ej.datavisualization.Diagram.LabelEditMode.Edit)
                            shape = this.selectionList[i];
                    }
                }

                if (shape) {
                    this._isEditing = false;
                    args = this._raiseEvent("textChange", { element: shape, value: editBox.value });

                    if (!args) {
                        if (shape && shape.shape !== undefined && shape.shape.type === "text") {
                            var oldText = shape.shape.textBlock.text;
                            shape.shape.textBlock.text = editBox.value;
                            shape.shape.textBlock.mode = ej.datavisualization.Diagram.LabelEditMode.View;
                            if (!this._findNode(shape.name)) {
                                if (editBox.value !== "") {
                                    var height = Number(editBox.style.height.substring(0, editBox.style.height.length - 2));
                                    if (shape.height < height) {
                                        shape.offsetY = (shape.offsetY - (shape.height / 2)) + (height / 2);
                                        shape.height = height;
                                    }
                                    if (this.selectionList.length > 0)
                                        this._clearSelection();
                                    this.add(shape);
                                }
                                this.activeTool.selectedObject = null;
                            } else {
                                ej.datavisualization.Diagram.DiagramContext.update(shape, this);

                                entry = { type: "labelchanged", shape: shape, previousLabelValue: oldText, updatedLabelValue: editBox.value };
                                this.addHistoryEntry(entry);
                                //entry = new ej.datavisualization.Diagram.HistoryEntry(new ej.datavisualization.Diagram.TextChangeCmd(shape, shape.shape.textBlock.text, editBox.value));
                                //this.historyManager.addHistoryEntry(entry);
                            }
                        } else if (shape != undefined && !(shape.type == "pseudoGroup")) {
                            var label;
                            if (this.activeTool.name === "textTool")
                                label = this.activeTool.getLabelUnderMouse();
                            else
                                label = shape.labels[0];
                            if (label != undefined) {
                                if (label.text != editBox.value) {

                                    entry = { type: "labelchanged", shape: shape, previousLabelValue: label.text, updatedLabelValue: editBox.value };
                                    this.addHistoryEntry(entry);
                                    //entry = new ej.datavisualization.Diagram.HistoryEntry(new ej.datavisualization.Diagram.LabelChangeCmd(shape, label.text, editBox.value));
                                    //this.historyManager.addHistoryEntry(entry);
                                }
                                label.text = editBox.value;
                                label.mode = ej.datavisualization.Diagram.LabelEditMode.View;
                                ej.datavisualization.Diagram.DiagramContext.updateLabel(shape, label, this);
                            }
                            else if (shape.labels.length == 0) {
                                label = ej.datavisualization.Diagram.Label();
                                label.text = editBox.value;
                                label.mode = ej.datavisualization.Diagram.LabelEditMode.View;
                                shape.labels.push(label);
                                ej.datavisualization.Diagram.DiagramContext.addNodeLabel(shape, label, null, this);
                            }
                        }
                    }
                }

                this._off($(editBox), "focusout", this._editboxfocusout);
                this._off($(editBox), "keyup", this._editBoxKeyUp);
                this._off($(editBox), "input", this._editBoxTextChange);
                var element = $("#" + this.element[0].id + "_editBoxDiv")[0];
                if (element)
                    element.parentNode.removeChild(element);
            }
        },

        _setLabelEditing: function (label) {
            var success;
            if (label) {
                if (label.readOnly) {
                    label.mode = ej.datavisualization.Diagram.LabelEditMode.View;
                    success = false;
                }
                else {
                    if (this._currentLabel)
                        this._currentLabel.mode = ej.datavisualization.Diagram.LabelEditMode.View;
                    label.mode = ej.datavisualization.Diagram.LabelEditMode.Edit;
                    this._currentLabel = label;
                    success = true;
                }
                return success;
            }
        },

        _isInternalTool: function (tool) {
            if (tool instanceof ej.datavisualization.Diagram.SelectTool || tool instanceof ej.datavisualization.Diagram.ConnectionEditTool || tool instanceof ej.datavisualization.Diagram.MoveTool || tool instanceof ej.datavisualization.Diagram.ResizeTool
                  || tool instanceof ej.datavisualization.Diagram.PhaseTool || tool instanceof ej.datavisualization.Diagram.RotateTool || (tool instanceof ej.datavisualization.Diagram.PanTool && (this.tool() & ej.datavisualization.Diagram.Tool.SingleSelect) && (this.tool() & ej.datavisualization.Diagram.Tool.ZoomPan)))
                return true;
            else
                return false;
        },
        _updateNodeMargin: function (node) {
            if (node.parent != "") {
                var group = this.nameTable[node.parent];
                if (group && group.container && group.container.type == "canvas") {
                    var groupBounds = ej.datavisualization.Diagram.Util.bounds(group);
                    var bounds1 = ej.datavisualization.Diagram.Util.bounds(node);
                    var bounds = ej.datavisualization.Diagram.Geometry.rect([bounds1.topLeft, bounds1.topRight, bounds1.bottomRight, bounds1.bottomLeft]);
                    node.marginLeft = bounds.x - (groupBounds.x + group.paddingLeft);
                    node.marginRight = (groupBounds.x + group.width) - (bounds.x + bounds.width) - group.paddingRight;
                    node.marginTop = bounds.y - (groupBounds.y + group.paddingTop);
                    node.marginBottom = groupBounds.bottom - (bounds.y + bounds.height) - group.paddingBottom;
                }
            }
            if ((node.type == "pseudoGroup" || node.name == "multipleSelection") && node.children.length > 0) {
                var child;
                for (var i = 0; i < node.children.length; i++) {
                    child = this.nameTable[this._getChild(node.children[i])];
                    if (child) {
                        this._updateNodeMargin(child);
                    }
                }
            }
        },
        _translate: function (node, dx, dy, nameTable, isContainer, layout) {
            if (ej.datavisualization.Diagram.Util.canMove(node) || layout) {
                if ((node.type == "group" || node.type == "pseudoGroup") && !layout) {
                    var children = this._getChildren(node.children);
                    for (var i = 0; i < children.length; i++) {
                        var child = this.nameTable[children[i]];
                        if (child && !ej.datavisualization.Diagram.Util.canMove(child)) return;
                    }
                }
                if (!node.segments) {
                    node.offsetX += dx;
                    node.offsetY += dy;
                    if ((node.type == "group" || node.type == "pseudoGroup") && !isContainer) {
                        var nodes = this._getChildren(node.children);
                        var child;
                        for (var i = 0; i < nodes.length; i++) {
                            child = nameTable[nodes[i]];
                            if (child) {
                                this._translate(child, dx, dy, nameTable);
                                if (child.parent && (child.parent != node.name && node.type != "pseudoGroup"))
                                    ej.datavisualization.Diagram.Util._updateGroupBounds(nameTable[child.parent], this);
                            }
                        }
                        if (node.type != "group" && node.container)
                            ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);
                    }
                    this._updateAssociatedConnectorEnds(node, nameTable);
                } else {
                    ej.datavisualization.Diagram.Util._translateLine(node, dx, dy, node);
                    this._dock(node, nameTable);
                    ej.datavisualization.Diagram.Util.updateBridging(node, this);
                    this._updateConnectorBridging(node);
                }
                this._updateQuad(node);
            }
        },
        _translateLabel: function (node, label, dx, dy) {
            label.margin["left"] += dx;
            label.margin["top"] += dy;
            label.margin["right"] -= dx;
            label.margin["bottom"] -= dy;
            ej.datavisualization.Diagram.DiagramContext.updateLabel(node, label, this);
        },
        _rotate: function (node, angle, nameTable) {
            if (ej.datavisualization.Diagram.Util.canRotate(node)) {
                if (node.type == "group" || node.type == "pseudoGroup") {
                    var children = this._getChildren(node.children);
                    for (var i = 0; i < children.length; i++) {
                        var child = this.nameTable[children[i]];
                        if (child && !child.segments && !ej.datavisualization.Diagram.Util.canRotate(child)) return;
                    }
                }
                if (!node.segments) {
                    node.rotateAngle += angle;
                    node.rotateAngle %= 360;
                    if (node.rotateAngle < 0) node.rotateAngle += 360;
                    if ((node.type == "group" || node.type == "pseudoGroup")) {
                        var matrix = ej.Matrix.identity();
                        var child, pinx, piny;
                        ej.Matrix.rotate(matrix, angle, node.offsetX, node.offsetY);
                        var nodes = this._getChildren(node.children);
                        for (var i = 0; i < nodes.length; i++) {
                            child = nameTable[nodes[i]];
                            if (child) {
                                if (!(child.segments)) {
                                    this._rotate(child, angle, nameTable);
                                    pinx = child.offsetX;
                                    piny = child.offsetY;
                                    var actualpt = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(pinx, piny));
                                    this._translate(child, actualpt.x - pinx, actualpt.y - piny, nameTable);
                                    this._updateAssociatedConnectorEnds(child, nameTable);
                                } else {
                                    if (!child.sourceNode)
                                        this._setEndPoint(child, ej.Matrix.transform(matrix, child.sourcePoint), false);
                                    if (!child.targetNode)
                                        this._setEndPoint(child, ej.Matrix.transform(matrix, child.targetPoint), true);
                                }
                                if (child.parent && (child.parent != node.name && node.type != "pseudoGroup"))
                                    ej.datavisualization.Diagram.Util._updateGroupBounds(nameTable[child.parent], this);
                            }
                        }

                        ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);
                    }
                    if (node.parent) {
                        this._updateParentBounds(node.parent);
                    }
                    this._updateQuad(node);
                    this._updateAssociatedConnectorEnds(node, nameTable);
                }
            }
        },

        scale: function (node, sw, sh, pivot, nameTable, skipScalOnChild, updateMinMax, isHelper) {
            if (!node.container) {
                if (ej.datavisualization.Diagram.Util.canResize(node)) {
                    if (node.type == "group" || node.type == "pseudoGroup") {
                        var children = this._getChildren(node.children);
                        for (var i = 0; i < children.length; i++) {
                            var child = this.nameTable[children[i]];
                            if (!ej.datavisualization.Diagram.Util.canResize(child)) return;
                        }
                    }
                    var matrix = ej.Matrix.identity();
                    if (!node.segments) {
                        if ((node.type == "group" || node.type == "pseudoGroup")) {
                            var nodes = this._getChildren(node.children);
                            var child;
                            for (var i = 0; i < nodes.length; i++) {
                                child = nameTable[nodes[i]];
                                if (child) {
                                    this.scale(child, sw, sh, pivot, nameTable);
                                    if (child.parent && (child.parent != node.name && node.type != "pseudoGroup"))
                                        ej.datavisualization.Diagram.Util._updateGroupBounds(nameTable[child.parent], this);
                                }
                            }

                            if (node.children.length <= 0) {
                                ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                                ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                                ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                                var newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY));
                                var width = node.width * sw;
                                var height = node.height * sh;
                                if (width > 1) {
                                    node.width = width;
                                    node.offsetX = newPosition.x;
                                }
                                if (height > 1) {
                                    node.height = height;
                                    node.offsetY = newPosition.y;
                                }
                            }
                            ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);

                        } else {
                            ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                            ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                            ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                            var newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY));
                            var width = node.width * sw;
                            var height = node.height * sh;
                            if (width > 1) {
                                node.width = width;
                                node.offsetX = newPosition.x;
                            }
                            if (height > 1) {
                                node.height = height;
                                node.offsetY = newPosition.y;
                            }
                        }
                        if (node.parent) {
                            this._updateParentBounds(node.parent);
                        }
                        this._updateAssociatedConnectorEnds(node, nameTable);
                    } else {
                        ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                        for (var i = 0; i < node.segments.length; i++) {
                            var segment = node.segments[i];
                            for (var j = 0; j < segment.points.length; j++) {
                                segment.points[j] = ej.Matrix.transform(matrix, segment.points[j]);
                                if (i == 0 && j == 0 && !node.sourceNode) {
                                    segment._startPoint = segment.points[0];
                                    segment._endPoint = segment.points[segment.points.length - 1];
                                    ej.datavisualization.Diagram.Util._setLineEndPoint(node, ej.Matrix.transform(matrix, node.sourcePoint), false);
                                }
                                if (i == node.segments.length - 1 && j == segment.points.length - 1 && !node.targetNode) {
                                    segment._startPoint = segment.points[0];
                                    segment._endPoint = segment.points[segment.points.length - 1];
                                    node.targetPoint = segment._endPoint;
                                    //ej.datavisualization.Diagram.Util._setLineEndPoint(node, ej.Matrix.transform(matrix, node.targetPoint), true);
                                }
                            }
                            segment._startPoint = segment.points[0];
                            segment._endPoint = segment.points[segment.points.length - 1];
                            if (segment.type == "orthogonal") {
                                if (segment.length || segment.length === 0)
                                    segment.length = segment._length = ej.datavisualization.Diagram.Geometry.distance(segment._startPoint, segment._endPoint);
                                else
                                    ej.datavisualization.Diagram.Util._addOrthogonalPoints(segment, node.segments[i - 1], node.segments[i + 1], node.sourcePoint, node.targetPoint);
                            } else {
                                segment.point = segment._endPoint;
                            }

                        }
                        if (node.sourceNode || node.targetNode)
                            this._dock(node, nameTable);
                    }
                    this._updateQuad(node);
                }
            }
            else {
                switch (node.container.type) {
                    case "canvas":
                        var newSize = {};
                        var matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                        ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                        ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                        newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY));
                        width = node.width * sw;
                        height = node.height * sh;

                        if (updateMinMax) {
                            node.minHeight = height;
                            node.minWidth = width;
                        }
                        if (isHelper != true)
                            newSize = this._getMinMaxSize(node, width, height);
                        else {
                            newSize.width = width;
                            newSize.height = height;

                        }
                        if (newSize && newSize.width > 1) {
                            var x = node.offsetX - node.width / 2;
                            node.width = newSize.width;
                            node.offsetX = x + node.width / 2;
                        }
                        if (newSize && newSize.height > 1) {
                            var y = node.offsetY - node.height / 2;
                            node.height = newSize.height;
                            node.offsetY = y + node.height / 2;
                        }
                        if (!skipScalOnChild)
                            ej.datavisualization.Diagram.SvgContext._alignOnCanvas1(node, this, true);
                        break;
                    case "stack":
                        var matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                        ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                        ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                        newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY));
                        width = (node.width * sw) - (node.marginLeft + node.marginRight);
                        height = (node.height * sh) - (node.marginTop + node.marginBottom);


                        newSize = this._getMinMaxSize(node, width, height);
                        if (newSize.width > 1) {
                            x = node.offsetX - node.width / 2;
                            node.width = newSize.width - node.marginLeft;
                            node.offsetX = x + node.width / 2 + (node.marginLeft);
                        }
                        if (newSize.height > 1) {
                            y = node.offsetY - node.height / 2;
                            node.height = newSize.height - node.marginTop;
                            node.offsetY = y + node.height / 2 + (node.marginTop);
                        }
                        ej.datavisualization.Diagram.SvgContext._alignOnStack(node, this);
                        break;
                }
            }
            ej.datavisualization.Diagram.DiagramContext.update(node, this);
        },
        _updateParentBounds: function (node) {
            node = this.nameTable[this._getChild(node)];
            if (node && !node.container) {
                ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);
                ej.datavisualization.Diagram.DiagramContext.update(node, this);
                if (node.parent) {
                    this._updateParentBounds(node.parent);
                }
            }
        },
        _dock: function (connector, nameTable, updateSelection) {
            var length = connector.segments.length;
            var srcPointslength = connector.segments[0].points.length;
            var targetPointslength = connector.segments[connector.segments.length - 1].points.length;
            ej.datavisualization.Diagram.Util.dock(connector, nameTable);
            if (length != connector.segments.length) {
                ej.datavisualization.Diagram.Util._updateConnectorSegments(connector, connector.sourcePort, connector.targetPort, this);
                ej.datavisualization.Diagram.DiagramContext._refreshSegments(connector, this);
            }
            if (this.selectionList[0] == connector) {
                if (updateSelection || srcPointslength != connector.segments[0].points.length || targetPointslength != connector.segments[connector.segments.length - 1].points.length) {
                    ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.selectionList[0], this._svg, this._currZoom);
                }
            }
            this._updateQuad(connector);
        },

        _setEndPoint: function (connector, point, isTarget) {
            ej.datavisualization.Diagram.Util._setLineEndPoint(connector, point, isTarget);
            this._updateQuad(connector);
        },

        _updateAssociatedConnectorEnds: function (node, nameTable) {
            var i, len;
            var connector;
            for (i = 0, len = node.inEdges.length; i < len; i++) {
                connector = nameTable[node.inEdges[i]];
                if (connector)
                    this._dock(connector, nameTable);
            }
            for (i = 0, len = node.outEdges.length; i < len; i++) {
                connector = nameTable[node.outEdges[i]];
                if (connector)
                    this._dock(connector, nameTable);
            }
        },
        _updateChildBounds: function (node, nameTable) {
            var offX, offY;
            if (node.width == 0 && node.height == 0) {
                offX = node.offsetX;
                offY = node.offsetY;
                ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);
                this._translate(node, offX - node.offsetX, offY - node.offsetY, nameTable);
            }
            else {
                offX = node.offsetX;
                offY = node.offsetY;
                var childBounds = ej.datavisualization.Diagram.Util._getChildrenBounds(node, this);
                node.offsetX = (childBounds.x + childBounds.width / 2);
                node.offsetY = (childBounds.y + childBounds.height / 2);
                var dx = offX - node.offsetX;
                var dy = offX - node.offsetY;
                this._translate(node, dx, dy, nameTable);
                var deltaWidth = node.width / childBounds.width;
                var deltaHeight = node.height / childBounds.height;
                this._scale(node, deltaWidth, deltaHeight, node.pivot, nameTable);;
                this._translate(node, offX - node.offsetX, offY - node.offsetY, nameTable);
            }
        },
        _updateQuad: function (object) {
            if (this._spatialSearch && this._spatialSearch.quadTable[object.name])
                if (object.segments || object.shape)
                    ej.datavisualization.Diagram.SpatialUtil._updateQuad(this, this._spatialSearch, object);
        }
        //#endregion
    });
    ej.datavisualization.Diagram.Locale = {};
    ej.datavisualization.Diagram.Locale["en-US"] = {
        cut: "Cut",
        copy: "Copy",
        paste: "Paste",
        undo: "Undo",
        redo: "Redo",
        selectAll: "SelectAll",
        grouping: "Grouping",
        group: "Group",
        ungroup: "Ungroup",
        order: "Order",
        bringToFront: "BringToFront",
        moveForward: "MoveForward",
        sendBackward: "SendBackward",
        sendToBack: "SendToBack"
    }

    $.fn.pinchDiagram = function (rootgroup, map) {

        var startTouches = [],

        handleTouchStart = function (evt) {
            var touches = evt.touches;
            if (touches.length >= 2) {
                for (var i = 0; i < touches.length; i++) {
                    var touch = touches[i]
                      , found = false;
                    for (var j = 0; j < startTouches.length; j++) {
                        var startTouch = startTouches[j];
                        if (touch.identifier === startTouch.identifier) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        var touchCopy = $.extend({}, touch);
                        startTouches.push(touchCopy);
                    }
                }
            }

            evt.preventDefault();
        },
        getDistance = function (touch1, touch2) {
            var x = touch2.pageX - touch1.pageX,
                y = touch2.pageY - touch1.pageY;
            return Math.sqrt((x * x) + (y * y));
        },

        handleTouchEnd = function (evt) {
            var changedTouches = evt.changedTouches;
            for (var i = 0; i < changedTouches.length; i++) {
                var changedTouch = changedTouches[i];
                for (var j = 0; j < startTouches.length; j++) {
                    var startTouch = startTouches[j];
                    if (startTouch.identifier === changedTouch.identifier) {
                        var idx = startTouches.indexOf(startTouch);
                        startTouches.splice(idx, 1);
                    }
                }
            }
            evt.preventDefault();
        },

        updateTouch = function (dstTouch, srcTouch) {
            dstTouch.pageX = srcTouch.pageX;
            dstTouch.pageY = srcTouch.pageY;
        },

        handleTouchMove = function (evt) {
            evt.preventDefault();
            var touches = evt.touches, z;
            if (touches.length >= 2) {
                var touch0 = touches[0]
                  , touch1 = touches[1]
                  , startTouch0 = startTouches[0]
                  , startTouch1 = startTouches[1];
                z = getDistance(touch0, touch1) / getDistance(startTouch0, startTouch1);
                var focusPoint = map._mousePosition(evt, false);
                ej.datavisualization.Diagram.ZoomUtil.zoomPan(map, z, 0, 0, focusPoint, true, true);
                updateTouch(startTouch0, touch0);
                updateTouch(startTouch1, touch1);
            }
        };
        this[0].addEventListener('touchstart', handleTouchStart, false);
        this[0].addEventListener('touchend', handleTouchEnd, false);
        this[0].addEventListener('touchmove', handleTouchMove, false);


    };
    //#endregion

})(jQuery, Syncfusion);;
(function ($, ej) {
    "use strict";
    ej.MatrixTypes = { Identity: 0, Translation: 1, Scaling: 2, Unknown: 4 };
    ej.MatrixDefaults = { m11: 1, m12: 0, m21: 0, m22: 1, offsetX: 0, offsetY: 0, type: ej.MatrixTypes.Identity };
    ej.Matrix = {
        identity: function () {
            return $.extend(true, {}, ej.MatrixDefaults);
        },
        multiply: function (matrix1, matrix2) {
            var type = matrix1.type;
            var type2 = matrix2.type;
            if (type2 == ej.MatrixTypes.Identity) {
                return;
            }
            if (type == ej.MatrixTypes.Identity) {
                matrix1.m11 = matrix2.m11;
                matrix1.m12 = matrix2.m12;
                matrix1.m21 = matrix2.m21;
                matrix1.m22 = matrix2.m22;
                matrix1.offsetX = matrix2.offsetX;
                matrix1.offsetY = matrix2.offsetY;
                matrix1.type = matrix2.type;
                return;
            }
            if (type2 == ej.MatrixTypes.Translation) {
                matrix1.offsetX += matrix2.offsetX;
                matrix1.offsetY += matrix2.offsetY;
                if (type != ej.MatrixTypes.Unknown) {
                    matrix1.type |= ej.MatrixTypes.Translation;
                }
                return;
            }
            if (type != ej.MatrixTypes.Translation) {
                var num = type << 4 | type2;
                switch (num) {
                    case 34:
                        matrix1.m11 *= matrix2.m11;
                        matrix1.m22 *= matrix2.m22;
                        return;
                    case 35:
                        matrix1.m11 *= matrix2.m11;
                        matrix1.m22 *= matrix2.m22;
                        matrix1.offsetX = matrix2.offsetX;
                        matrix1.offsetY = matrix2.offsetY;
                        matrix1.type = (ej.MatrixTypes.Translation | ej.MatrixTypes.Scaling);
                        return;
                    case 36: break;
                    default:
                        {
                            switch (num) {
                                case 50:
                                    matrix1.m11 *= matrix2.m11;
                                    matrix1.m22 *= matrix2.m22;
                                    matrix1.offsetX *= matrix2.m11;
                                    matrix1.offsetY *= matrix2.m22;
                                    return;
                                case 51:
                                    matrix1.m11 *= matrix2.m11;
                                    matrix1.m22 *= matrix2.m22;
                                    matrix1.offsetX = matrix2.m11 * matrix1.offsetX + matrix2.offsetX;
                                    matrix1.offsetY = matrix2.m22 * matrix1.offsetY + matrix2.offsetY;
                                    return;
                                case 52: break;
                                default:
                                    switch (num) {
                                        case 66:
                                        case 67:
                                        case 68: break;
                                        default: return;
                                    }
                                    break;
                            }
                            break;
                        }
                }
                var result = this.identity();
                this._setMatrix(result, matrix1.m11 * matrix2.m11 + matrix1.m12 * matrix2.m21,
                    matrix1.m11 * matrix2.m12 + matrix1.m12 * matrix2.m22, matrix1.m21 * matrix2.m11 + matrix1.m22 * matrix2.m21,
                    matrix1.m21 * matrix2.m12 + matrix1.m22 * matrix2.m22,
                    matrix1.offsetX * matrix2.m11 + matrix1.offsetY * matrix2.m21 + matrix2.offsetX, matrix1.offsetX * matrix2.m12 + matrix1.offsetY * matrix2.m22 + matrix2.offsetY);
                if (result.m21 || result.m12) {
                    result.type = ej.MatrixTypes.Unknown;
                }
                else {
                    if (result.m11 && result.m11 != 1.0 || result.m22 && result.m22 != 1.0) {
                        result.type = ej.MatrixTypes.Scaling;
                    }
                    if (result.offsetX || result.offsetY) {
                        result.type |= ej.MatrixTypes.Translation;
                    }
                    if ((result.type & (ej.MatrixTypes.Translation | ej.MatrixTypes.Scaling)) == ej.MatrixTypes.Identity) {
                        result.type = ej.MatrixTypes.Identity;
                    }
                }
                matrix1.m11 = result.m11;
                matrix1.m12 = result.m12;
                matrix1.m21 = result.m21;
                matrix1.m22 = result.m22;
                matrix1.offsetX = result.offsetX;
                matrix1.offsetY = result.offsetY;
                matrix1.type = result.type;
                return;
            }
            var offsetX = matrix1.offsetX;
            var offsetY = matrix1.offsetY;
            matrix1.m11 = matrix2.m11;
            matrix1.m12 = matrix2.m12;
            matrix1.m21 = matrix2.m21;
            matrix1.m22 = matrix2.m22;
            matrix1.offsetX = matrix2.offsetX;
            matrix1.offsetY = matrix2.offsetY;
            matrix1.type = matrix2.type;
            matrix1.offsetX = offsetX * matrix2.m11 + offsetY * matrix2.m21 + matrix2.offsetX;
            matrix1.offsetY = offsetX * matrix2.m12 + offsetY * matrix2.m22 + matrix2.offsetY;
            if (type2 == ej.MatrixTypes.Unknown) {
                matrix1.type = ej.MatrixTypes.Unknown;
                return;
            }
            matrix1.type = (ej.MatrixTypes.Translation | ej.MatrixTypes.Scaling);
        },
        transform: function (matrix, point) {
            var pt = this._multiplyPoint(matrix, point.x, point.y);
            return { x: Math.round(pt.x * 100) / 100, y: Math.round(pt.y * 100) / 100 };
        },
        rotate: function (matrix, angle, centerX, centerY) {
            angle %= 360.0;
            this.multiply(matrix, this._createRotationRadians(angle * 0.017453292519943295, centerX ? centerX : 0, centerY ? centerY : 0));
        },
        scale: function (matrix, scaleX, scaleY, centerX, centerY) {
            this.multiply(matrix, this._createScaling(scaleX, scaleY, centerX ? centerX : 0, centerY ? centerY : 0));
        },
        translate: function (matrix, offsetX, offsetY) {
            if (matrix.type & ej.MatrixTypes.Identity) {
                this._setMatrix(matrix, 1.0, 0.0, 0.0, 1.0, offsetX, offsetY, ej.MatrixTypes.Translation);
                return;
            }
            if (matrix.type & ej.MatrixTypes.Unknown) {
                matrix.offsetX += offsetX;
                matrix.offsetY += offsetY;
                return;
            }
            matrix.offsetX += offsetX;
            matrix.offsetY += offsetY;
            matrix.type |= ej.MatrixTypes.Translation;
        },
        _createScaling: function (scaleX, scaleY, centerX, centerY) {
            var result = this.identity();
            this._setMatrix(result, scaleX, 0.0, 0.0, scaleY, centerX - scaleX * centerX, centerY - scaleY * centerY,
                !(centerX || centerY) ? ej.MatrixTypes.Scaling : ej.MatrixTypes.Scaling | ej.MatrixTypes.Translation);
            return result;
        },
        _createRotationRadians: function (angle, centerX, centerY) {
            var result = this.identity();
            var num = Math.sin(angle);
            var num2 = Math.cos(angle);
            var offsetX = centerX * (1.0 - num2) + centerY * num;
            var offsetY = centerY * (1.0 - num2) - centerX * num;
            this._setMatrix(result, num2, num, -num, num2, offsetX, offsetY, ej.MatrixTypes.Unknown);
            return result;
        },
        _multiplyPoint: function (matrix, x, y) {
            switch (matrix.type) {
                case ej.MatrixTypes.Identity: break;
                case ej.MatrixTypes.Translation:
                    x += matrix.offsetX;
                    y += matrix.offsetY;
                    break;
                case ej.MatrixTypes.Scaling:
                    x *= matrix.m11;
                    y *= matrix.m22;
                    break;
                case ej.MatrixTypes.Translation | ej.MatrixTypes.Scaling:
                    x *= matrix.m11;
                    x += matrix.offsetX;
                    y *= matrix.m22;
                    y += matrix.offsetY;
                    break;
                default:
                    var num = y * matrix.m21 + matrix.offsetX;
                    var num2 = x * matrix.m12 + matrix.offsetY;
                    x *= matrix.m11;
                    x += num;
                    y *= matrix.m22;
                    y += num2;
                    break;
            }
            return { x: x, y: y };
        },
        _setMatrix: function (matrix, m11, m12, m21, m22, offsetX, offsetY, type) {
            matrix.m11 = m11;
            matrix.m12 = m12;
            matrix.m21 = m21;
            matrix.m22 = m22;
            matrix.offsetX = offsetX;
            matrix.offsetY = offsetY;
            matrix.type = type || ej.MatrixTypes.Identity;
        }
    };
})(jQuery, Syncfusion);;
/**
* @fileOverview Plugin to style the Html Button elements
* @copyright Copyright Syncfusion Inc. 2001 - 2013. All rights reserved.
*  Use of this code is subject to the terms of our license.
*  A copy of the current license can be obtained at any time by e-mailing
*  licensing@syncfusion.com. Any infringement will be prosecuted under
*  applicable laws. 
* @version 12.1 
* @author <a href="mailto:licensing@syncfusion.com">Syncfusion Inc</a>
*/
(function ($, ej) {

    "use strict";

    //#region HitTesting
    ej.datavisualization.Diagram.HitTesting = {
        _getResizeHandleCenter: function (shape, position, scale) {
            if (!scale) scale = 1;
            var corners = this.bounds(shape);
            var center = ej.datavisualization.Diagram.Point(0, 0);
            switch (position) {
                case "topleft":
                    center = corners.topLeft;
                    break;
                case "topcenter":
                    center = corners.top;
                    break;
                case "topright":
                    center = corners.topRight;
                    break;
                case "middleleft":
                    center = corners.left;
                    break;
                case "middleright":
                    center = corners.right;
                    break;
                case "bottomleft":
                    center = corners.bottomLeft;
                    break;
                case "bottomcenter":
                    center = corners.bottom;
                    break;
                case "bottomright":
                    center = corners.bottomRight;
                    break;
                case "pivot":
                    center = ej.datavisualization.Diagram.Point(shape.offsetX, shape.offsetY);
                    break;
                case "rotate":
                    var thumbHeight = 20;
                    var dist = 20 / scale; //distance between element top and rotator thumb
                    var pt = ej.datavisualization.Diagram.Point(shape.offsetX, (shape.offsetY - shape.height * shape.pivot.y) - thumbHeight / 2 - dist);
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, shape.rotateAngle, shape.offsetX, shape.offsetY);
                    center = ej.Matrix.transform(matrix, pt);
                    break;
            }
            return center;
        },
        findResizeHandleAtPoint: function (node, point) {
            var resizeDirection = null;
            if (node) {
                var center;
                var success;
                var directions = ["topleft", "topcenter", "topright", "middleleft", "middleright", "bottomleft", "bottomcenter", "bottomright"];
                for (var i = 0, len = directions.length; i < len; i++) {
                    center = this._getResizeHandleCenter(node, directions[i]);
                    if (center !== ej.datavisualization.Diagram.Point(0, 0)) {
                        success = ej.datavisualization.Diagram.Geometry.checkPointOnCircle(point, ej.datavisualization.Diagram.Point(center.x, center.y), 7); // right now 7 is default handle radius size, need to give as constant variable
                        if (success) {
                            resizeDirection = directions[i];
                            break;
                        }
                    }
                }
            }
            return resizeDirection;
        },
        findRotationHandleAtPoint: function (node, point, scale) {
            var center = this.xxx_getResizeHandleCenter(node, "rotate", scale);
            var success = ej.datavisualization.Diagram.Geometry.checkPointOnCircle(point, ej.datavisualization.Diagram.Point(center.x, center.y), 10); // right now 7 is default handle radius size, need to give as constant variable
            if (success) {
                return true;

            }
            return false;
        },
        findPivotHandleAtPoint: function (node, point) {
            var center = this._getResizeHandleCenter(node, "pivot");
            var success = ej.datavisualization.Diagram.Geometry.checkPointOnCircle(point, ej.datavisualization.Diagram.Point(center.x, center.y), 7); // right now 7 is default handle radius size, need to give as constant variable
            if (success) {
                return true;

            }
            return false;
        },
        findEndPointHandleAtPoint: function (connector, point) {
            var endPointHandle = null;
            if (connector) {
                var success;
                var points = connector.line.points;
                var pt = points[points.length - 1];
                success = ej.datavisualization.Diagram.Geometry.checkPointOnCircle(point, ej.datavisualization.Diagram.Point(pt.x, pt.y), 7); // right now 7 is default handle radius size, need to give as constant variable
                if (success) {
                    endPointHandle = "targetEndPoint";
                }
                if (!success) {
                    pt = points[0];
                    success = ej.datavisualization.Diagram.Geometry.checkPointOnCircle(point, ej.datavisualization.Diagram.Point(pt.x, pt.y), 7); // right now 7 is default handle radius size, need to give as constant variable
                    if (success) {
                        endPointHandle = "sourceEndPoint";
                    }
                }
                if (!success && connector.line.type === "bezier") {
                    pt = connector.line._point1;
                    success = ej.datavisualization.Diagram.Geometry.checkPointOnCircle(point, ej.datavisualization.Diagram.Point(pt.x, pt.y), 7); // right now 7 is default handle radius size, need to give as constant variable
                    if (success) {
                        endPointHandle = "bezierpoint1";
                    }
                    if (!success) {
                        var pt1 = connector.line._point2;
                        success = ej.datavisualization.Diagram.Geometry.checkPointOnCircle(point, ej.datavisualization.Diagram.Point(pt1.x, pt1.y), 7); // right now 7 is default handle radius size, need to give as constant variable
                        if (success) {
                            endPointHandle = "bezierpoint2";
                        }
                    }
                }
            }
            return endPointHandle;
        }
    };
    //#endregion

    //#region Util
    ej.datavisualization.Diagram.Util = {
        findPortByName: function (node, portName) {
            var port;
            if (node.ports)
                for (var i = 0, len = node.ports.length; i < len; i++) {
                    port = node.ports[i];
                    if (port.name === portName) {
                        return port;
                    }
                }
            return null;
        },
        attr: function (element, attributes) {
            for (var atr in attributes) {
                element.setAttribute(atr.toString(), attributes[atr]);
            }
        },
        removeItem: function (array, item) {
            var index = array.indexOf(item);
            if (index >= 0)
                array.splice(index, 1);
        },
        clear: function (array) {
            while (array.length > 0) {
                array.pop();
            }
        },
        randomId: function () {
            var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
            var id = "";
            //get 4 random chars
            for (var i = 0; i < 4; i++) {
                var num = Math.floor(Math.random() * chars.length);
                id += chars.substring(num, num + 1);
            }
            return id;
        },
        htmlEncode: function (html) {
            var str = html.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&apos;/g, '\'');
            return str;
        },
        canMove: function (node) {
            if (node.segments) {
                return node.constraints & ej.datavisualization.Diagram.ConnectorConstraints.Drag;
            } else
                return node.constraints & ej.datavisualization.Diagram.NodeConstraints.Drag;
        },
        canMoveLabel: function (node) {
            if (node.segments) {
                return node.constraints & ej.datavisualization.Diagram.ConnectorConstraints.DragLabel;
            } else
                return node.constraints & ej.datavisualization.Diagram.NodeConstraints.DragLabel;
        },
        canRotate: function (node) {
            if (node.segments) {
                return node.constraints & ej.datavisualization.Diagram.ConnectorConstraints.Rotate;

            } else
                return node.constraints & ej.datavisualization.Diagram.NodeConstraints.Rotate;
        },
        canSelect: function (node) {
            if (node.segments) {
                return node.constraints & ej.datavisualization.Diagram.ConnectorConstraints.Select;
            } else
                return node.constraints & ej.datavisualization.Diagram.NodeConstraints.Select;
        },
        canBridge: function (connector, diagram) {
            if (connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.Bridging) {
                return connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.Bridging;
            }
            else if (connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.InheritBridging) {
                return diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.Bridging;
            }
        },
        canAllowPan: function (node) {
            return node.constraints & ej.datavisualization.Diagram.NodeConstraints.AllowPan;
        },
        canDelete: function (node) {
            if (node.segments) {
                return node.constraints & ej.datavisualization.Diagram.ConnectorConstraints.Delete;
            } else
                return node.constraints & ej.datavisualization.Diagram.NodeConstraints.Delete;
        },
        isPageEditable: function (diagram) {
            if (diagram) {
                return diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.PageEditable;
            }

        },
        canDoMultipleSelection: function (diagram) {
            if (diagram) {
                return diagram.model.tool & ej.datavisualization.Diagram.Tool.MultipleSelect;
            }
        },
        canDoSingleSelection: function (diagram) {
            if (diagram) {
                return diagram.model.tool & ej.datavisualization.Diagram.Tool.SingleSelect;
            }
        },
        canPanning: function (diagram) {
            if (diagram) {
                return (diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.PannableX) || (diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.PannableY);
            }
        },
        canZooming: function (diagram) {
            if (diagram) {
                return (diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.Zoomable);
            }
        },
        canUndo: function (diagram) {
            if (diagram) {
                return (diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.Undoable);
            }
        },
        canDragSourceEnd: function (connector) {
            return connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.DragSourceEnd;
        },
        canDragTargetEnd: function (connector) {
            return connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.DragTargetEnd;
        },
        canDragSegmentThumbs: function (connector) {
            return connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.DragSegmentThumb;
        },
        isTargetConnected: function (connector) {
            return connector.targetNode ? true : false;
        },
        isSourceConnected: function (connector) {
            return connector.sourceNode ? true : false;
        },
        bounds: function (object, excludeRotation) {
            var rect;
            if (object.segments) {
                for (var i = 0; i < object.segments.length; i++) {
                    var segment = object.segments[i];
                    if (i == 0) {
                        if (segment.points)
                            rect = ej.datavisualization.Diagram.Geometry.rect(segment.points);
                    }
                    else
                        rect = ej.datavisualization.Diagram.Geometry.union(rect, ej.datavisualization.Diagram.Geometry.rect(segment.points));
                    rect.width = rect.width == 0 ? object.lineWidth : rect.width;
                    rect.height = rect.height == 0 ? object.lineWidth : rect.height;
                }
            }
            else if (object.shape || object.type == "group") {
                rect = ej.datavisualization.Diagram.Rectangle(object.offsetX - object.width * object.pivot.x, object.offsetY - object.height * object.pivot.y, object.width, object.height);
            }
            else
                rect = object;
            if (rect) {
                var bounds = {};
                rect.x = Math.round(rect.x * 100) / 100;
                rect.y = Math.round(rect.y * 100) / 100;
                rect.width = Math.round(rect.width * 100) / 100;
                rect.height = Math.round(rect.height * 100) / 100;
                bounds["width"] = rect.width;
                bounds["height"] = rect.height;
                bounds["x"] = bounds["left"] = rect.x;
                bounds["right"] = rect.x + rect.width;
                bounds["y"] = bounds["top"] = rect.y;
                bounds["bottom"] = rect.y + rect.height;
                bounds["center"] = ej.datavisualization.Diagram.Point(rect.x + rect.width / 2, rect.y + rect.height / 2);
                bounds["topLeft"] = ej.datavisualization.Diagram.Point(rect.x, rect.y);
                bounds["topCenter"] = ej.datavisualization.Diagram.Point(rect.x + rect.width / 2, rect.y);
                bounds["topRight"] = ej.datavisualization.Diagram.Point(rect.x + rect.width, rect.y);
                bounds["middleLeft"] = ej.datavisualization.Diagram.Point(rect.x, rect.y + rect.height / 2);
                bounds["middleRight"] = ej.datavisualization.Diagram.Point(rect.x + rect.width, rect.y + rect.height / 2);
                bounds["bottomLeft"] = ej.datavisualization.Diagram.Point(rect.x, rect.y + rect.height);
                bounds["bottomCenter"] = ej.datavisualization.Diagram.Point(rect.x + rect.width / 2, rect.y + rect.height);
                bounds["bottomRight"] = ej.datavisualization.Diagram.Point(rect.x + rect.width, rect.y + rect.height);
                if (object.rotateAngle && !excludeRotation) {
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, object.rotateAngle, object.offsetX, object.offsetY);
                    bounds.topLeft = ej.Matrix.transform(matrix, bounds.topLeft);
                    bounds.topCenter = ej.Matrix.transform(matrix, bounds.topCenter);
                    bounds.topRight = ej.Matrix.transform(matrix, bounds.topRight);
                    bounds.middleLeft = ej.Matrix.transform(matrix, bounds.middleLeft);
                    bounds.middleRight = ej.Matrix.transform(matrix, bounds.middleRight);
                    bounds.bottomLeft = ej.Matrix.transform(matrix, bounds.bottomLeft);
                    bounds.bottomCenter = ej.Matrix.transform(matrix, bounds.bottomCenter);
                    bounds.bottomRight = ej.Matrix.transform(matrix, bounds.bottomRight);
                    var rbounds = ej.datavisualization.Diagram.Geometry.rect([bounds.topLeft, bounds.topRight, bounds.bottomRight, bounds.bottomLeft]);
                    bounds.x = bounds.left = rbounds.x;
                    bounds.y = bounds.top = rbounds.y;
                    bounds.right = rbounds.x + rbounds.width;
                    bounds.bottom = rbounds.y + rbounds.height;
                    bounds.center = ej.datavisualization.Diagram.Point(rbounds.x + rbounds.width / 2, rbounds.y + rbounds.height / 2);
                }

                bounds["points"] = [bounds.topLeft, bounds.topRight, bounds.bottomRight, bounds.bottomLeft];
                return bounds;

            }

            return rect;
        },

        _swapBounds: function (object, bounds) {
            var object, bounds;
            bounds = bounds;
            if (object.rotateAngle) {
                if (object.rotateAngle < 45) { }
                else if (object.rotateAngle <= 135) {
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, object.rotateAngle, object.offsetX, object.offsetY);
                    var temp;
                    temp = bounds["topCenter"];
                    bounds["topCenter"] = bounds["middleLeft"];
                    bounds["middleLeft"] = bounds["bottomCenter"];
                    bounds["bottomCenter"] = bounds["middleRight"];
                    bounds["middleRight"] = temp;
                    temp = bounds["topLeft"];
                    bounds["topLeft"] = bounds["bottomLeft"];
                    bounds["bottomLeft"] = bounds["bottomRight"];
                    bounds["bottomRight"] = bounds["topRight"];
                    bounds["topRight"] = temp;
                }

                else if (object.rotateAngle <= 225) {
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, object.rotateAngle, object.offsetX, object.offsetY);
                    var temp;
                    temp = bounds["topCenter"];
                    bounds["topCenter"] = bounds["bottomCenter"];
                    bounds["bottomCenter"] = temp;
                    temp = bounds["middleLeft"];
                    bounds["middleLeft"] = bounds["middleRight"];
                    bounds["middleRight"] = temp;
                    temp = bounds["bottomLeft"];
                    bounds["bottomLeft"] = bounds["topLeft"];
                    bounds["topLeft"] = temp;
                    temp = bounds["bottomRight"];
                    bounds["bottomRight"] = bounds["topRight"];
                    bounds["topRight"] = temp;
                }

                else if (object.rotateAngle <= 315) {
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, object.rotateAngle, object.offsetX, object.offsetY);
                    var temp;
                    temp = bounds["topCenter"];
                    bounds["topCenter"] = bounds["middleRight"];
                    bounds["middleRight"] = bounds["bottomCenter"];
                    bounds["bottomCenter"] = bounds["middleLeft"];
                    bounds["middleLeft"] = temp;
                    temp = bounds["bottomRight"];
                    bounds["bottomRight"] = bounds["topRight"];
                    bounds["topRight"] = bounds["bottomLeft"];
                    bounds["bottomLeft"] = bounds["topLeft"];
                    bounds["topLeft"] = temp;
                }
                bounds["points"] = [bounds.topLeft, bounds.topRight, bounds.bottomRight, bounds.bottomLeft];
                return bounds;
            }
        },
        canResize: function (node) {
            return node.constraints & ej.datavisualization.Diagram.NodeConstraints.Resize;
        },
        canConnect: function (node, isPort) {
            var connect = null;
            if (isPort) {
                connect = node.constraints & ej.datavisualization.Diagram.PortConstraints.Connect;
            }
            else if (!node.segments)
                connect = node.constraints & ej.datavisualization.Diagram.NodeConstraints.Connect;
            return connect;
        },
        _initializeSegments: function (connector, defaultType) {
            if (connector.segments && connector.segments.length <= 1) {
                if (!connector.segments.length) {
                    connector.segments.push(ej.datavisualization.Diagram.Segment({ type: defaultType || "straight" }));
                }
                var first = connector.segments[0];
                switch (first.type) {
                    case "straight":
                        if (!first.point) { first._point = connector.targetPoint; }
                        else if (first.point.x != connector.targetPoint.x || first.point.y != connector.targetPoint.y) {
                            //Need to add a method
                            connector.segments.push({ type: defaultType || "straight" });
                        }
                        break;
                    case "orthogonal":
                        if (first.length && first.direction) {
                            ej.datavisualization.Diagram.Util._addOrthogonalPoints(first, null, null, connector.sourcePoint, connector.targetPoint);
                            if (first._endPoint.x != connector.targetPoint.x || first._endPoint.y != connector.targetPoint.y) {
                                connector.segments.push({ type: defaultType || "straight" });
                            }
                        }
                        else {
                            first._length = first.length || 20;
                            first._direction = first.direction || "auto";
                        }
                        break;
                    case "bezier":
                        if (!first.point) first._point = connector.targetPoint;
                        else if (first.point.x != connector.targetPoint.x || first.point.y != connector.targetPoint.y) {
                            //Need to add a method
                            connector.segments.push({ type: defaultType || "straight" });
                        }
                        break;
                }
            }
            var startPoint = connector.sourcePoint;
            var prev = null;
            var next = null;
            var runAngle;
            for (var i = 0; i < connector.segments.length; i++) {
                var segment = connector.segments[i];
                segment._startPoint = startPoint;
                next = connector.segments[i + 1];
                segment = connector.segments[i] = ej.datavisualization.Diagram.Segment(connector.segments[i]);
                if (segment.type == "orthogonal") {
                    segment._direction = segment.direction || "auto";
                    segment._length = segment.length || 20;
                    runAngle = ej.datavisualization.Diagram.Util._addOrthogonalPoints(connector.segments[i], prev, next, connector.sourcePoint, connector.targetPoint, runAngle);
                    startPoint = connector.segments[i]._endPoint;
                    if (!segment.length || !segment.direction) {
                        break;
                    }
                }
                else if (segment.type == "straight") {
                    segment.points.push(startPoint);
                    segment.points.push(connector.segments[i].point || connector.targetPoint);
                    segment._point = segment._endPoint = connector.segments[i].point || connector.targetPoint;
                    runAngle = ej.datavisualization.Diagram.Geometry.findAngle(startPoint, segment._endPoint);
                    startPoint = connector.segments[i]._endPoint;
                    if (!segment.point) {
                        break;
                    }
                }
                else if (segment.type == "bezier") {
                    segment._point = segment._endPoint = connector.segments[i].point || connector.targetPoint;
                    segment.points.push(startPoint);
                    segment.points.push(connector.segments[i].point || connector.targetPoint);
                    runAngle = ej.datavisualization.Diagram.Geometry.findAngle(startPoint, segment._endPoint);
                    ej.datavisualization.Diagram.Util._updateBezierPoints(segment);
                    startPoint = connector.segments[i]._endPoint;
                    if (!segment.point) {
                        break;
                    }
                }
                else {
                    var segment = ej.datavisualization.Diagram.Segment({ type: "orthogonal" });
                    segment._direction = "auto";
                    segment._length = 20;
                    segment._startPoint = startPoint;
                    segment._endPoint = connector.targetPoint;
                    connector.segments.push(segment);
                    ej.datavisualization.Diagram.Util._addOrthogonalPoints(segment, prev, null, connector.sourcePoint, connector.targetPoint, runAngle);
                    break;
                }
                prev = connector.segments[i];
            }
            if (startPoint.x != connector.targetPoint.x || startPoint.y != connector.targetPoint.y) {
                var segment = ej.datavisualization.Diagram.Segment({ type: defaultType || "straight", });
                segment._startPoint = startPoint;
                segment._endPoint = connector.targetPoint;
                if (segment.type == "orthogonal") {
                    ej.datavisualization.Diagram.Util._addOrthogonalPoints(segment, prev, null, connector.sourcePoint, connector.targetPoint, runAngle);
                }
                else {
                    segment._point = connector.targetPoint;
                    segment.points.push(startPoint);
                    segment.points.push(connector.targetPoint);
                    if (segment.type == "bezier") { this._updateBezierPoints(segment); }
                }
                connector.segments.push(segment);
            }
        },
        dock: function (connector, nameTable) {
            var targetNode, targetPort = null, sourceNode, sourcePort = null;
            targetNode = nameTable[connector.targetNode];
            if (targetNode)
                targetPort = this.findPortByName(targetNode, connector.targetPort);
            sourceNode = nameTable[connector.sourceNode];
            if (sourceNode)
                sourcePort = this.findPortByName(sourceNode, connector.sourcePort);
            var sourceConnected = this.isSourceConnected(connector);
            var targetConnected = this.isTargetConnected(connector);
            if (targetConnected && sourceConnected && targetPort && sourcePort) {
                this._dockPortToPort(connector, targetNode, targetPort, sourceNode, sourcePort);
            }
            else if (targetConnected && targetPort) {
                if (sourceConnected) {
                    if (connector.segments.length == 1) {
                        this._dockNode(connector, sourceNode, null, targetConnected, sourceConnected);
                        this._dockPortToNode(connector, targetNode, targetPort, sourceNode, sourcePort, true);
                    }
                    else {
                        this._dockNode(connector, sourceNode, null, targetConnected, sourceConnected);
                        this._updateIntermediateSegments(connector);
                        this._dockPortToPoint(connector, targetNode, targetPort, true);
                        this._updatePreviousSegment(connector);
                    }
                }
                else {
                    this._dockPortToPoint(connector, targetNode, targetPort, true);
                    this._updatePreviousSegment(connector);
                }
            }
            else if (sourceConnected && sourcePort) {
                if (targetConnected) {
                    if (connector.segments.length == 1) {
                        this._dockNode(connector, targetNode, null, targetConnected, sourceConnected);
                        this._dockPortToNode(connector, sourceNode, sourcePort, targetNode, targetPort, false);
                    }
                    else {
                        this._dockPortToPoint(connector, sourceNode, sourcePort, false);
                        this._updateIntermediateSegments(connector);
                        this._dockNode(connector, targetNode, null, targetConnected, sourceConnected);
                        this._updatePreviousSegment(connector);
                    }
                }
                else {
                    this._dockPortToPoint(connector, sourceNode, sourcePort, false);
                    this._updateIntermediateSegments(connector);
                }
            }
            else if (targetConnected && sourceConnected) {
                if (targetNode && sourceNode)
                    this._dockNode(connector, targetNode, sourceNode, targetConnected, sourceConnected);
            }
            else if (targetConnected) {
                this._dockNode(connector, targetNode, null, targetConnected, sourceConnected);

            }
            else if (sourceConnected) {
                this._dockNode(connector, sourceNode, null, targetConnected, sourceConnected);
            }
            this._adjustEndPoint(connector, sourceNode, sourcePort, targetNode, targetPort);
        },
        _dockPortToPort: function (connector, targetNode, targetPort, sourceNode, sourcePort) {
            if (connector.segments.length == 1) {
                var portLocation;
                if (targetNode)
                    var targetBounds = this.bounds(targetNode, true);
                if (sourceNode)
                    var sourceBounds = this.bounds(sourceNode, true);
                var matrix;
                var first = connector.segments[0];
                var last = connector.segments[connector.segments.length - 1];
                var segment = connector.segments[0];
                if (segment.type !== "orthogonal") {
                    if (targetPort) {
                        portLocation = this._getPortPosition(targetPort, targetBounds);
                        matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, targetNode.rotateAngle, targetNode.offsetX, targetNode.offsetY);
                        portLocation = ej.Matrix.transform(matrix, portLocation);
                        this._setLineEndPoint(connector, portLocation, true);
                    }
                    if (sourcePort) {
                        portLocation = this._getPortPosition(sourcePort, sourceBounds);
                        matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, sourceNode.rotateAngle, sourceNode.offsetX, sourceNode.offsetY);
                        portLocation = ej.Matrix.transform(matrix, portLocation);
                        this._setLineEndPoint(connector, portLocation, false);
                    }
                    if (segment.type === "bezier")
                        this._updateBezierPoints(segment, targetNode, targetPort, targetBounds, sourceNode, sourcePort, sourceBounds);
                }
                else {
                    var targetPortLocation = this._getPortPosition(targetPort, targetBounds);
                    var sourcePortLocation = this._getPortPosition(sourcePort, sourceBounds);
                    var targetDirection = this._swapDirection(targetNode.rotateAngle, this._getDirection(targetBounds, targetPortLocation));
                    var sourceDirection = this._swapDirection(sourceNode.rotateAngle, this._getDirection(sourceBounds, sourcePortLocation));
                    matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, sourceNode.rotateAngle, sourceNode.offsetX, sourceNode.offsetY);
                    sourcePortLocation = ej.Matrix.transform(matrix, sourcePortLocation);
                    matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, targetNode.rotateAngle, targetNode.offsetX, targetNode.offsetY);
                    targetPortLocation = ej.Matrix.transform(matrix, targetPortLocation);
                    targetBounds = this.bounds(targetNode);
                    sourceBounds = this.bounds(sourceNode);
                    this._constructSegements(connector, first, targetBounds, targetPortLocation, targetDirection, sourceBounds, sourcePortLocation, sourceDirection);
                    this._setLineEndPoint(connector, first.points[0], false);
                    this._setLineEndPoint(connector, first.points[first.points.length - 1], true);
                }
            }
            else {
                this._dockPortToPoint(connector, sourceNode, sourcePort, false);
                this._updateIntermediateSegments(connector);
                this._dockPortToPoint(connector, targetNode, targetPort, true);
                this._updatePreviousSegment(connector);
            }

        },
        _dockPortToNode: function (connector, targetNode, targetPort, sourceNode, sourcePort, isTarget) {
            var first = connector.segments[0];
            var last = connector.segments[connector.segments.length - 1];
            if (targetNode)
                var targetBounds = this.bounds(targetNode, true);
            if (sourceNode)
                var sourceBounds = this.bounds(sourceNode, true);
            var matrix;
            var segment = isTarget ? last : first;
            if (segment.type !== "orthogonal") {
                var portLocation = this._getPortPosition(targetPort, targetBounds);
                matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, targetNode.rotateAngle, targetNode.offsetX, targetNode.offsetY);
                portLocation = ej.Matrix.transform(matrix, portLocation);
                //segment._endPoint = portLocation;
                this._setLineEndPoint(connector, portLocation, isTarget);
            }
            else {
                var targetPortLocation = this._getPortPosition(targetPort, targetBounds);
                var targetDirection = this._swapDirection(targetNode.rotateAngle, this._getDirection(targetBounds, targetPortLocation));
                matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, targetNode.rotateAngle, targetNode.offsetX, targetNode.offsetY);
                targetPortLocation = ej.Matrix.transform(matrix, targetPortLocation);
                var sourcePortLocation;
                if (!isTarget) {
                    sourcePortLocation = connector.targetPoint;
                }
                else {
                    sourcePortLocation = connector.sourcePoint;
                }
                var sourceDirection;
                if (sourceNode) {
                    sourceDirection = this._getDirection(sourceBounds, sourcePortLocation);
                }
                else sourceDirection = "top";
                if (sourceDirection) {
                    targetBounds = this.bounds(targetNode);
                    if (sourceNode)
                        sourceBounds = this.bounds(sourceNode);
                    else sourceBounds = { left: sourcePortLocation.x, right: sourcePortLocation.x, top: sourcePortLocation.y, bottom: sourcePortLocation.y };
                    if (isTarget) {
                        this._setLineEndPoint(connector, targetPortLocation, true);
                        this._constructSegements(connector, last, targetBounds, targetPortLocation, targetDirection, sourceBounds, sourcePortLocation, sourceDirection);
                    }
                    else {
                        this._setLineEndPoint(connector, targetPortLocation, false);
                        this._constructSegements(connector, first, sourceBounds, sourcePortLocation, sourceDirection, targetBounds, targetPortLocation, targetDirection);
                    }
                }
            }
        },
        _dockPortToPoint: function (connector, targetNode, targetPort, isTarget) {
            var first = connector.segments[0];
            var last = connector.segments[connector.segments.length - 1];
            var segment = isTarget ? last : first;
            if (segment.type !== "orthogonal") {
                this._dockPortToNode(connector, targetNode, targetPort, null, null, isTarget);
            }
            else {
                var targetBounds = this.bounds(targetNode, true);
                var targetPortLocation = this._getPortPosition(targetPort, targetBounds);
                var targetDirection = this._swapDirection(targetNode.rotateAngle, this._getDirection(targetBounds, targetPortLocation));
                var matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, targetNode.rotateAngle, targetNode.offsetX, targetNode.offsetY);
                targetPortLocation = ej.Matrix.transform(matrix, targetPortLocation);
                var sourcePortLocation;
                var sourcePortLocation;
                if (!isTarget) {
                    sourcePortLocation = first._endPoint;
                }
                else {
                    sourcePortLocation = last._startPoint;
                }
                var sourceBounds = this.bounds(ej.datavisualization.Diagram.Rectangle(sourcePortLocation.x, sourcePortLocation.y, 0, 0));
                targetBounds = this.bounds(targetNode);
                var sourceDirection = "top";
                if (isTarget) {
                    this._setLineEndPoint(connector, targetPortLocation, true);
                    this._pointsFromNodeToPoint(connector, last, targetDirection, targetBounds, targetNode.rotateAngle, targetPortLocation, sourcePortLocation, true); //{(connector, last, targetBounds, targetPortLocation, targetDirection, sourceBounds, sourcePortLocation, sourceDirection);

                }
                else {
                    this._setLineEndPoint(connector, targetPortLocation, false);
                    this._pointsFromNodeToPoint(connector, first, targetDirection, targetBounds, targetNode.rotateAngle, targetPortLocation, sourcePortLocation, false);
                }
            }
        },
        _dockNode: function (connector, targetNode, sourceNode, targetConnected, sourceConnected) {
            var startsegment, endsegment;
            if (connector.segments.length == 1) {
                startsegment = endsegment = connector.segments[0];
            }
            else {
                startsegment = connector.segments[0];
                endsegment = connector.segments[connector.segments.length - 1];
            }
            if (targetConnected && sourceConnected && !connector.targetPort && !connector.sourcePort) {
                if (connector.segments.length == 1) {
                    if (connector.segments[0].type == "orthogonal") {
                        var sourceBounds = this.bounds(sourceNode);
                        var targetBounds = this.bounds(targetNode);
                        this._swapBounds(sourceNode, sourceBounds);
                        this._swapBounds(targetNode, targetBounds);
                        var srcDirection, tarDirection;
                        var srcPoint, tarPoint;
                        if (sourceBounds.y > targetBounds.bottom) {
                            srcDirection = "top";
                            tarDirection = "bottom";
                            srcPoint = sourceBounds.topCenter;
                            tarPoint = targetBounds.bottomCenter;
                        }
                        else if (sourceBounds.bottom < targetBounds.y) {
                            srcDirection = "bottom";
                            tarDirection = "top";
                            srcPoint = sourceBounds.bottomCenter;
                            tarPoint = targetBounds.topCenter;
                        }
                        else if (sourceBounds.x > targetBounds.right) {
                            srcDirection = "left";
                            tarDirection = "right";
                            srcPoint = sourceBounds.middleLeft;
                            tarPoint = targetBounds.middleRight;
                        }
                        else {
                            srcDirection = "right";
                            tarDirection = "left";
                            srcPoint = sourceBounds.middleRight;
                            tarPoint = targetBounds.middleLeft;
                        }
                        this._setLineEndPoint(connector, srcPoint, false);
                        this._setLineEndPoint(connector, tarPoint, true);
                        if (connector.segments[0].type == "orthogonal") {
                            this._constructSegements(connector, connector.segments[0], targetBounds, connector.targetPoint, tarDirection, sourceBounds, connector.sourcePoint, srcDirection);
                            connector.segments[0]._direction = srcDirection;
                        }
                        var srcPt = this._adjustPoint(connector.segments[0]._startPoint, connector.segments[0].points[1], true, sourceNode.connectorPadding);
                        var tarPt = this._adjustPoint(connector.segments[0].points[connector.segments[0].points.length - 2], connector.segments[0]._endPoint, false, targetNode.connectorPadding);
                        this._setLineEndPoint(connector, srcPt, false);
                        this._setLineEndPoint(connector, tarPt, true);
                    }
                    else {
                        if (targetNode) {
                            targetBounds = this.bounds(targetNode);
                            this._swapBounds(targetNode, targetBounds);
                            if (sourceNode) {
                                sourceBounds = this.bounds(sourceNode);
                                this._swapBounds(sourceNode, sourceBounds);
                                this._setLineEndPoint(connector, sourceBounds.center, false);
                                this._setLineEndPoint(connector, targetBounds.center, true);
                                this._dockBounds(connector, sourceNode, sourceBounds, false);
                            }
                            this._setLineEndPoint(connector, targetBounds.center, true);
                            this._dockBounds(connector, targetNode, targetBounds, true);
                        }
                        if (connector.segments[0].type == "bezier") {
                            this._updateBezierPoints(connector.segments[0]);
                        }
                    }
                }
                else {
                    this._dock(connector, startsegment, sourceNode, null, false);
                    this._updateIntermediateSegments(connector);
                    if (connector.segments.length == 1) {
                        this._dock(connector, startsegment, sourceNode, targetNode, false);
                        this._dock(connector, endsegment, targetNode, sourceNode, true);
                    }
                    else {
                        this._dock(connector, endsegment, targetNode, null, true);
                        this._updatePreviousSegment(connector);
                    }
                }
            }
            else if (targetConnected && !connector.targetPort) {
                this._dock(connector, endsegment, targetNode, sourceNode, true);
                this._updatePreviousSegment(connector);
            }
            else if (sourceConnected && !connector.sourcePort) {
                this._dock(connector, startsegment, targetNode, sourceNode, false);
                this._updateIntermediateSegments(connector);
            }
        },
        _adjustEndPoint: function (connector, sourceNode, sourcePort, targetNode, targetPort) {
            var length = 0;
            var targetBounds = targetNode ? this.bounds(targetNode) : null;
            var sourceBounds = sourceNode ? this.bounds(sourceNode) : null;
            if (sourceNode) {
                var endPoint;
                var segment = connector.segments[0];
                if (segment.type !== "orthogonal") endPoint = segment.type !== "bezier" ? segment._endPoint : segment._point1;
                else endPoint = segment.points[1];
                if (segment.type == "orthogonal") length = connector.sourcePadding + sourceNode.connectorPadding;
                if (sourcePort) length = connector.sourcePadding + sourcePort.connectorPadding;
                var sourcePortLocation = this._adjustPoint(segment._startPoint, endPoint, true, length);
                this._setLineEndPoint(connector, sourcePortLocation, false);
                if (segment.type == "bezier") this._updateBezierPoints(segment, targetNode, targetPort, targetBounds, sourceNode, sourcePort, sourceBounds);
            }
            if (targetNode) {
                var startPoint;
                var segment = connector.segments[connector.segments.length - 1];
                if (segment.type !== "orthogonal") startPoint = segment.type !== "bezier" ? segment._startPoint : segment._point2;
                else startPoint = segment.points[segment.points.length - 2];
                if (segment.type == "orthogonal") length = connector.targetPadding + targetNode.connectorPadding;
                if (targetPort) length = connector.targetPadding + targetPort.connectorPadding;
                var targetPortLocation = this._adjustPoint(startPoint, segment._endPoint, false, length);
                this._setLineEndPoint(connector, targetPortLocation, true);
                if (segment.type == "bezier") this._updateBezierPoints(segment, targetNode, targetPort, targetBounds, sourceNode, sourcePort, sourceBounds);
            }
        },
        _dock: function (connector, line, targetNode, sourceNode, isTarget) {
            var targetBounds;
            var sourceBounds;
            var points;
            if (targetNode) {
                var node = targetNode;
                var point = isTarget ? line._startPoint : line._endPoint;
                var sourceBounds = this.bounds(targetNode);
                this._swapBounds(targetNode, sourceBounds);
                if (!isTarget) {
                    if (line.type == "orthogonal" && connector.segments[1] && connector.segments[1].type == "orthogonal") {
                        if (connector.segments[0]._isInternal && ej.datavisualization.Diagram.Geometry.containsPoint(sourceBounds, line._endPoint)) {
                            this._insertSegmentAtSourceEnd(connector, line, sourceBounds, isTarget);
                        }
                        else if (ej.datavisualization.Diagram.Geometry.containsPoint(sourceBounds, line._endPoint)) {
                            this._removeFirstSegment(connector, line, sourceBounds, isTarget);
                        }
                        else {
                            var dockPoint, dockDirection;;
                            switch (line.direction) {
                                case "left":
                                    dockDirection = "left";
                                    dockPoint = sourceBounds.middleLeft;
                                    break;
                                case "right": dockDirection = "right";
                                    dockPoint = sourceBounds.middleRight;
                                    break;
                                case "top": dockDirection = "top";
                                    dockPoint = sourceBounds.topCenter;
                                    break;
                                case "bottom": dockDirection = "bottom";
                                    dockPoint = sourceBounds.bottomCenter;
                                    break;
                            }
                            line.points = [];
                            line.points.push(dockPoint);
                            line.points.push(line._endPoint);
                            this._setLineEndPoint(connector, dockPoint, isTarget);
                        }
                    }
                    else {
                        this._dockNodeToPoint(connector, line._endPoint, targetNode, isTarget);
                    }
                }
                else {
                    if (line.type == "orthogonal") {
                        var second = connector.segments[connector.segments.length - 2];
                        if (second && second.type == "orthogonal") {
                            if (line.points.length > 2 &&
                                ej.datavisualization.Diagram.Geometry.containsPoint(sourceBounds, line.points[line.points.length - 2])) {
                                var removePreSegment = false;
                                if (second.direction == "top" || second.direction == "bottom") {
                                    if (second._endPoint.x >= sourceBounds.left && second._endPoint.x <= sourceBounds.right) {
                                        this._removeLastSegment(connector, line, second, targetNode, sourceNode, isTarget); return;
                                    }
                                    else {
                                        second._length = second.length = Math.abs(second._startPoint.y - sourceBounds.middleLeft.y);;
                                        if (second.length == 0) {
                                            removePreSegment = true;
                                        }
                                        else {
                                            if (second.length < 0) {
                                                second._length = second.length *= -1;
                                                second._direction = second.direction = (second.direction == "top") ? "bottom" : "top";
                                            }
                                            connector.targetPoint = second._endPoint.x > sourceBounds.right ? sourceBounds.middleRight : sourceBounds.middleLeft;
                                        }
                                    }
                                }
                                else {
                                    if (second._endPoint.y >= sourceBounds.top && second._endPoint.y <= sourceBounds.bottom) {
                                        this._removeLastSegment(connector, line, second, targetNode, sourceNode, isTarget); return;
                                    }
                                    else {
                                        second._length = second.length = Math.abs(second._startPoint.x - sourceBounds.topCenter.x);;
                                        if (second.length == 0) removePreSegment = true;
                                        else {
                                            if (second.length < 0) {
                                                second._length = second.length *= -1;
                                                second._direction = second.direction = (second.direction == "left") ? "right" : "left";
                                            }
                                            connector.targetPoint = second._endPoint.y > sourceBounds.bottom ? sourceBounds.bottomCenter : sourceBounds.topCenter;
                                        }
                                    }
                                }
                                if (removePreSegment) {
                                    connector.segments.splice(connector.segments.length - 2, 1);
                                    this._dock(connector, line, targetNode, sourceNode, isTarget);
                                    return;
                                }
                                this._updateConnectorSegments(connector, connector.sourcePort, connector.targetPort);
                                line._direction = this._getOrthoDirection(line._startPoint, line._endPoint, second);
                                this._setLineEndPoint(connector, connector.targetPoint, isTarget);

                            }
                            else if (ej.datavisualization.Diagram.Geometry.containsPoint(sourceBounds, line._startPoint)) {
                                var diflength = second.direction == "left" || second.direction == "right" ? node.width / 2 : node.height / 2;
                                second._length = second.length -= diflength + 30;
                                if (second.length == 0) {
                                    connector.segments.splice(connector.segments.length - 2, 1);
                                    this._dock(connector, line, targetNode, sourceNode, isTarget);
                                    return;
                                }
                                if (second.direction == "left" || second.direction == "right")
                                    connector.targetPoint = second.direction == "right" ? sourceBounds.middleLeft : sourceBounds.middleRight;
                                else
                                    connector.targetPoint = second.direction == "bottom" ? sourceBounds.topCenter : sourceBounds.bottomCenter;
                                this._updateConnectorSegments(connector, connector.sourcePort, connector.targetPort);
                                line._direction = this._getOrthoDirection(line._startPoint, line._endPoint, second);
                                this._setLineEndPoint(connector, connector.targetPoint, isTarget);

                            }
                            else {
                                this._dockNodeToPoint(connector, point, targetNode, isTarget);
                            }
                        } else {
                            this._dockNodeToPoint(connector, point, targetNode, isTarget);
                        }
                    }
                    else { this._dockNodeToPoint(connector, point, targetNode, isTarget); }

                }
            }
        },
        _removeLastSegment: function (connector, line, second, targetNode, sourceNode, isTarget) {
            connector.segments.splice(connector.segments.length - 1, 1);
            second.length = second._length = null;
            second.direction = null;
            second._direction = line._direction;
            this._dock(connector, second, targetNode, sourceNode, isTarget);
        },
        _insertSegmentAtSourceEnd: function (connector, line, sourceBounds, isTarget) {
            var second = connector.segments[1];
            var third = connector.segments[2];
            if (connector.segments[0].direction == "left" || connector.segments[0].direction == "right") {
                var orientation = "horizontal";
                connector.sourcePoint = second.direction == "top" ? sourceBounds.topCenter : sourceBounds.bottomCenter;
                if (second && (second.length || second.length === 0))
                    second._length = second.length = Math.max(Math.abs(connector.sourcePoint.y - second._endPoint.y), 25);
                if (third && (third.length || third.length === 0)) {
                    third.length = third._length = Math.abs(sourceBounds.topCenter.x - third._endPoint.x);
                }
            }
            else {
                var orientation = "vertical";
                connector.sourcePoint = second.direction == "left" ? sourceBounds.middleLeft : sourceBounds.middleRight;
                if (second && (second.length || second.length === 0))
                    second._length = second.length = Math.max(Math.abs(connector.sourcePoint.x - second._endPoint.x), 25);
                if (third && (third.length || third.length === 0)) {
                    third.length = third._length = Math.abs(sourceBounds.middleRight.y - third._endPoint.y);
                }
            }
            //Updating adjacent segments
            if (connector.segments[3] && (connector.segments[3].length || connector.segments[3].length == 0)) {
                var value = second.direction == "bottom" || second.direction == "right" ? second.length : -second.length;
                connector.segments[3].length = connector.segments[3]._length = orientation == "vertical" ?
                    Math.abs(connector.sourcePoint.x + value - connector.segments[3]._endPoint.x) :
                    Math.abs(connector.sourcePoint.y + value - connector.segments[3]._endPoint.y);
                if (connector.segments[3].length < 0) {
                    var value = second.direction == "bottom" || second.direction == "right" ? second.length : -second.length;
                    connector.segments[3].length = connector.segments[3]._length = orientation == "vertical" ?
                        Math.abs(connector.sourcePoint.x + value - connector.segments[3]._endPoint.x) :
                    Math.abs(connector.sourcePoint.y + value - connector.segments[3]._endPoint.y);
                }
            }
            connector.segments.splice(0, 1);
            this._updateConnectorSegments(connector, connector.sourcePort, connector.targetPort);
            this._setLineEndPoint(connector, connector.sourcePoint, isTarget);
        },
        _removeFirstSegment: function (connector, line, sourceBounds, isTarget) {
            var newLength, firstSegLength;
            var direction = connector.segments[1].direction || this._getBezierDirection(connector.segments[1].points[0], connector.segments[1].points[1]);
            if (direction == "left" || direction == "right") {
                var length = line._endPoint.y - sourceBounds.middleRight.y;
                connector.segments[0].direction = connector.segments[0]._direction = length >= 0 ? "bottom" : "top";
                connector.segments[0].length = connector.segments[0]._length = Math.abs(length);
                var actualdist = direction == "right" ? connector.segments[1]._endPoint.x - sourceBounds.right :
                    sourceBounds.left - connector.segments[1]._endPoint.x;
                connector.sourcePoint = direction == "left" ? sourceBounds.middleLeft : sourceBounds.middleRight;
                newLength = Math.abs(connector.sourcePoint.x - connector.segments[0]._startPoint.x);
                firstSegLength = Math.abs(connector.sourcePoint.y - connector.segments[0]._endPoint.y);
            }
            else {
                if (connector.segments[0].length || connector.segments[0].length == 0) {
                    var length = line._endPoint.x - sourceBounds.bottomCenter.x;
                    connector.segments[0].direction = connector.segments[0]._direction = length >= 0 ? "right" : "left";
                    connector.segments[0].length = connector.segments[0]._length = Math.abs(length);
                }
                var actualdist = direction == "bottom" ? connector.segments[1]._endPoint.y - sourceBounds.bottom :
                    sourceBounds.top - connector.segments[1]._endPoint.y;
                connector.sourcePoint = direction == "top" ? sourceBounds.topCenter : sourceBounds.bottomCenter;
                newLength = Math.abs(connector.sourcePoint.y - connector.segments[0]._startPoint.y);
                firstSegLength = Math.abs(connector.sourcePoint.x - connector.segments[0]._endPoint.x);
            }

            if (connector.segments[1] && (connector.segments[1].length || connector.segments[1].length === 0)) {
                connector.segments[1]._length = connector.segments[1].length = actualdist - 25;
                if (connector.segments[1]._length < 0) {
                    connector.segments.splice(0, 2);
                    if (connector.segments[0].length || connector.segments[0].length === 0)
                        connector.segments[0].length = connector.segments[0]._length = newLength;
                    var newSegment = ej.datavisualization.Diagram.Segment({ type: "orthogonal", length: firstSegLength, direction: direction });
                }
            }
            if (!newSegment) {
                newSegment = ej.datavisualization.Diagram.Segment({ type: "orthogonal", length: 25, direction: direction });
            }
            var segments = [newSegment];
            newSegment._isInternal = true;
            connector.segments = segments.concat(connector.segments);
            this._updateConnectorSegments(connector, connector.sourcePort, connector.targetPort);
            this._setLineEndPoint(connector, connector.sourcePoint, isTarget);
        },
        _dockNodeToPoint: function (connector, fixedPoint, node, isTarget) {
            var line, sourceBounds;
            line = isTarget ? connector.segments[connector.segments.length - 1] : connector.segments[0];
            if (line.type != "orthogonal") {
                sourceBounds = this.bounds(node);
                this._swapBounds(node, sourceBounds);
                this._setLineEndPoint(connector, sourceBounds.center, isTarget);
                this._dockBounds(connector, node, sourceBounds, isTarget);
            }
            else {
                var sourceBounds = this.bounds(node);
                this._swapBounds(node, sourceBounds);
                var dockPoint, dockDirection, targetDirection;
                var point = fixedPoint;
                var prev = connector.segments[connector.segments.length - 2];
                var left = Math.abs(point.x - sourceBounds.left);
                var right = Math.abs(point.x - sourceBounds.right);
                var top = Math.abs(point.y - sourceBounds.top);
                var bottom = Math.abs(point.y - sourceBounds.bottom);
                if (prev && isTarget) {
                    var horizontal = prev.direction == "left" || prev.direction == "right";
                    var vertical = prev.direction == "top" || prev.direction == "bottom";
                }
                line = !isTarget ? connector.segments[0] : connector.segments[connector.segments.length - 1];
                if ((line.points.length == 2 || !prev) && line.type == "orthogonal") {
                    horizontal = vertical = false;
                }
                if (sourceBounds.bottom < point.y && !horizontal) {
                    dockDirection = "bottom";
                    targetDirection = "top";
                    dockPoint = sourceBounds.bottomCenter;
                }
                else if (sourceBounds.y > point.y && !horizontal) {
                    dockDirection = "top";
                    targetDirection = "bottom";
                    dockPoint = sourceBounds.topCenter;
                }
                else if (sourceBounds.right < point.x && !vertical) {
                    dockDirection = "right";
                    targetDirection = "left";
                    dockPoint = sourceBounds.middleRight;
                }
                else if (sourceBounds.x > point.x && !vertical) {
                    dockDirection = "left";
                    targetDirection = "right";
                    dockPoint = sourceBounds.middleLeft;
                }
                else {
                    var min = left;
                    dockPoint = sourceBounds.middleLeft;
                    dockDirection = "left";
                    targetDirection = "right";
                    if (min >= right && right != 0) {
                        dockPoint = sourceBounds.middleRight;
                        dockDirection = "right";
                        targetDirection = "left";
                        min = right;
                    }
                    if (min > top && top != 0) {
                        dockPoint = sourceBounds.topCenter;
                        dockDirection = "top";
                        targetDirection = "bottom";
                        min = top;
                    }
                    if (min > bottom && bottom != 0) {
                        dockPoint = sourceBounds.bottomCenter;
                        dockDirection = "bottom";
                        targetDirection = "top";
                        min = bottom;
                    }
                }
                if (dockPoint) {
                    if (isTarget || connector.segments.length == 1) {
                        var segment = connector.segments[connector.segments.length - 1];
                        if (segment.type == "orthogonal") {
                            segment._direction = isTarget ? targetDirection : dockDirection;
                        }
                    }
                    else { var segment = connector.segments[0]; }
                    isTarget ? connector.targetPoint = dockPoint : connector.sourcePoint = dockPoint;
                    if (connector.segments.length != 1)
                        this._addOrthogonalPoints(segment, !isTarget ? null : connector.segments[connector.segments.length - 2], !isTarget ? connector.segments[1] : null, connector.sourcePoint, connector.targetPoint);
                    this._setLineEndPoint(connector, dockPoint, isTarget);
                }
            }
        },
        _getDockSegment: function (connector, line, rotateAngle, bounds, isTarget, direction) {
            var segment; var segments = this._getEdges(rotateAngle, bounds);
            {
                var direction = "", segment, intersecSeg;
                //var line = connector.line;

                var length = ej.datavisualization.Diagram.Geometry.distance(line._startPoint, line._endPoint);
                if (isTarget)
                    intersecSeg = ej.datavisualization.Diagram.LineSegment(line.points[line.points.length - 2], line.points[line.points.length - 1]);
                else {
                    if (length > 5) {
                        intersecSeg = ej.datavisualization.Diagram.LineSegment(line._startPoint, line._endPoint);
                    }
                    else {
                        intersecSeg = ej.datavisualization.Diagram.LineSegment(line._startPoint, connector.segments[1] ? connector.segments[1]._endPoint : connector.targetPoint);
                    }
                }
                if (ej.datavisualization.Diagram.Geometry.intersectSegment(intersecSeg, segments.left)) {
                    segment = segments.left;
                    direction = "left";
                }
                else if (ej.datavisualization.Diagram.Geometry.intersectSegment(intersecSeg, segments.top)) {
                    segment = segments.top;
                    direction = "top";
                }
                else if (ej.datavisualization.Diagram.Geometry.intersectSegment(intersecSeg, segments.right)) {
                    segment = segments.right;
                    direction = "right";
                }
                else if (ej.datavisualization.Diagram.Geometry.intersectSegment(intersecSeg, segments.bottom)) {
                    segment = segments.bottom;
                    direction = "bottom";
                }
            }
            direction = this._swapDirection(rotateAngle, direction);
            if (segment) {
                return { "dockPoint": ej.datavisualization.Diagram.Geometry.midPoint(segment), "direction": direction };
            }
            return null;
        },
        _dockBounds: function (connector, node, bounds, isTarget) {
            var line;
            line = isTarget ? connector.segments[connector.segments.length - 1] : connector.segments[0];
            var segmentPoints, length;
            if (node.shape.type === "polygon") {
                length = node.shape.points.length;
                segmentPoints = $.extend(false, {}, node.shape.points);
                ej.datavisualization.Diagram.Geometry.updatePolygonPoints(node, segmentPoints);
                for (var i = 0; i < length; i++) {
                    var pt1 = ej.datavisualization.Diagram.Point(segmentPoints[i].x + (node.offsetX - node.width / 2), segmentPoints[i].y + (node.offsetY - node.height / 2));
                    if (node.rotateAngle != 0) {
                        var matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, node.rotateAngle, node.offsetX, node.offsetY);
                        pt1 = ej.Matrix.transform(matrix, pt1);
                    }
                    if (node.connectorPadding || connector.sourcePadding || connector.targetPadding) {
                        var x = node.offsetX == pt1.x ? 0 : (node.offsetX < pt1.x ? 1 : -1);
                        var y = node.offsetY == pt1.y ? 0 : (node.offsetY < pt1.y ? 1 : -1);
                        var pad = node.connectorPadding;
                        pad += isTarget ? connector.targetPadding : connector.sourcePadding;
                        pt1 = pad ? ej.datavisualization.Diagram.Geometry.translate(pt1, x * pad, y * pad) : pt1;
                    }
                    segmentPoints[i] = pt1;
                }
            }
            else if (node.shape.type === "path") {
                var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
                document.body.appendChild(svg);

                var pathEl = document.createElementNS('http://www.w3.org/2000/svg', "path");
                pathEl.setAttributeNS(null, "d", node.shape.pathData);
                svg.appendChild(pathEl);

                var pathBounds = pathEl.getBBox();
                var pad = node.connectorPadding;
                pad += isTarget ? connector.targetPadding : connector.sourcePadding;
                var pathData = ej.datavisualization.Diagram.Geometry.updatePath(-pad, -pad, node.width + 2 * pad, node.height + 2 * pad, node.shape.pathData, svg, pathBounds);
                pathEl.setAttributeNS(null, "d", pathData);
                var length = pathEl.getTotalLength(), pts = [];
                for (var i = 0; i < length - 1; i++) {
                    var pathSeg = pathEl.getPointAtLength(i);
                    var pt1 = ej.datavisualization.Diagram.Point(pathSeg.x + (node.offsetX - node.width / 2), pathSeg.y + (node.offsetY - node.height / 2));
                    if (node.rotateAngle != 0) {
                        var matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, node.rotateAngle, node.offsetX, node.offsetY);
                        pt1 = ej.Matrix.transform(matrix, pt1);
                    }
                    pts[i] = pt1;
                }
                length = pts.length;
                segmentPoints = pts;
                document.body.removeChild(svg);
            }
            else {
                if (node.connectorPadding || connector.sourcePadding || connector.targetPadding) {
                    var pad = node.connectorPadding;
                    pad += isTarget ? connector.targetPadding : connector.sourcePadding;
                    var rect = ej.datavisualization.Diagram.Rectangle(bounds.x - pad, bounds.y - pad, node.width + 2 * pad, node.height + 2 * pad);
                    bounds = this.bounds(rect);
                }
                length = bounds.points.length;
                segmentPoints = bounds.points;
            }
            var strPt = line._startPoint;
            var endPt = line._endPoint || line.point
            if (line.type == "bezier" && (line.point1 || line.point2)) {
                if (isTarget) strPt = line._point2;
                else endPt = line._point1;
            }
            var thisSegment = ej.datavisualization.Diagram.LineSegment(strPt, endPt);
            var i;
            var segment = ej.datavisualization.Diagram.LineSegment(segmentPoints[length - 1], segmentPoints[0]);
            var intersection = ej.datavisualization.Diagram.Geometry.intersectSegment(thisSegment, segment);
            if (!intersection) {
                for (i = 0; i < length - 1; i++) {
                    segment = ej.datavisualization.Diagram.LineSegment(segmentPoints[i], segmentPoints[i + 1]);
                    intersection = ej.datavisualization.Diagram.Geometry.intersectSegment(thisSegment, segment);
                    if (intersection)
                        break;
                }
            }
            if (intersection) {
                this._setLineEndPoint(connector, intersection, isTarget);
                if (line.type === "bezier") {
                    this._updateBezierPoints(line);
                }
            }
        },
        _getEdges: function (rotateAngle, bounds) {
            var points = bounds.points;
            var segments = {};
            var angle = rotateAngle % 360;
            var temp;
            segments.left = ej.datavisualization.Diagram.LineSegment(points[3], points[0]);
            segments.top = ej.datavisualization.Diagram.LineSegment(points[0], points[1]);
            segments.right = ej.datavisualization.Diagram.LineSegment(points[1], points[2]);
            segments.bottom = ej.datavisualization.Diagram.LineSegment(points[2], points[3]);
            if (angle < 0) {
                angle += 360;
            }
            if (angle > 315 || angle < 45) {

            }
            else if (angle < 135) {
                temp = segments.top;
                segments.top = segments.left;
                segments.left = segments.bottom;
                segments.bottom = segments.right;
                segments.right = temp;
            }
            else if (angle < 225) {
                temp = segments.top;
                segments.top = segments.bottom;
                segments.bottom = temp;
                temp = segments.left;
                segments.left = segments.right;
                segments.right = temp;
            }
            else {
                temp = segments.bottom;
                segments.bottom = segments.left;
                segments.left = segments.top;
                segments.top = segments.right;
                segments.right = temp;
            }
            return segments;
        },
        _pointsFromNodeToPoint: function (connector, segment, direction, bounds, angle, point, endPoint, isTarget) {
            var dir, num;
            var points = [];
            points.push(point);
            var straight;
            straight = (point.y == endPoint.y && (direction == "left" && endPoint.x < point.x || direction == "right" && endPoint.x > point.x)) ||
               (point.x == endPoint.x && (direction == "top" && endPoint.y < point.y || direction == "bottom" && endPoint.y > point.y));
            if (angle == 0)
                if (!straight && !isTarget) straight = point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom;
            if (!straight) {
                if (direction == "top" || direction == "bottom") {
                    if (direction == "top" && endPoint.y < point.y || direction == "bottom" && endPoint.y > point.y) {
                        //twosegments
                        points.push({ x: point.x, y: endPoint.y });
                    }
                    else if ((endPoint.x < bounds.left || endPoint.x > bounds.right) && endPoint.y != point.y) {
                        //three segments
                        var y = direction == "top" ? bounds.top - 15 : bounds.bottom + 15;
                        points.push({ x: point.x, y: y });
                        points.push({ x: endPoint.x, y: y });
                    }
                    else {
                        //four segments
                        var y = direction == "top" ? bounds.top - 15 : bounds.bottom + 15;
                        var x = (endPoint.x < point.x) ? bounds.left - 15 : bounds.right + 15;
                        points.push({ x: point.x, y: y });
                        points.push({ x: x, y: y });
                        points.push({ x: x, y: endPoint.y });
                    }
                }
                else {
                    if (direction == "left" && endPoint.x < point.x || direction == "right" && endPoint.x > point.x) {
                        points.push({ x: endPoint.x, y: point.y });
                        //twosegments
                    }
                    else if ((endPoint.y < bounds.top || endPoint.y > bounds.bottom) && endPoint.x != point.x) {
                        //three segments
                        var x = direction == "left" ? bounds.left - 15 : bounds.right + 15;
                        points.push({ x: x, y: point.y });
                        points.push({ x: x, y: endPoint.y });
                    }
                    else {
                        //four segments
                        var y = (endPoint.y < point.y) ? bounds.top - 15 : bounds.bottom + 15;
                        var x = direction == "left" ? bounds.left - 15 : bounds.right + 15;
                        points.push({ x: x, y: point.y });
                        points.push({ x: x, y: y });
                        points.push({ x: endPoint.x, y: y });
                    }
                }
            }
            points.push(endPoint);
            if (isTarget) points.reverse();
            segment._startPoint = points[0];
            segment._endPoint = points[points.length - 1];
            segment.points = points;
        },
        _constructSegements: function (connector, segment, targetBounds, targetPortLocation, targetDirection, sourceBounds, sourcePortLocation, sourceDirection) {
            var points, reverse;
            if (sourceDirection === "right") {
                if (targetDirection === "left") {
                    points = this._rightToLeft(targetBounds, targetPortLocation, sourceBounds, sourcePortLocation);
                }
                else if (targetDirection === "right") {
                    points = this._rightToRight(targetBounds, targetPortLocation, sourceBounds, sourcePortLocation);
                }
                else if (targetDirection === "top") {
                    points = this._rightToTop(targetBounds, targetPortLocation, sourceBounds, sourcePortLocation);
                }
                else if (targetDirection === "bottom") {
                    points = this._rightToBottom(targetBounds, targetPortLocation, sourceBounds, sourcePortLocation);
                }
            }
            if (sourceDirection === "left") {
                if (targetDirection === "right") {
                    points = this._rightToLeft(sourceBounds, sourcePortLocation, targetBounds, targetPortLocation);
                    reverse = true;
                }
                if (targetDirection === "left") {
                    points = this._leftToLeft(targetBounds, targetPortLocation, sourceBounds, sourcePortLocation);
                }
                if (targetDirection === "top") {
                    points = this._leftToTop(targetBounds, targetPortLocation, sourceBounds, sourcePortLocation);
                }
                if (targetDirection === "bottom") {
                    points = this._leftToBottom(targetBounds, targetPortLocation, sourceBounds, sourcePortLocation);
                }
            }
            if (sourceDirection === "top") {
                if (targetDirection === "left") {
                    points = this._leftToTop(sourceBounds, sourcePortLocation, targetBounds, targetPortLocation);
                    reverse = true;
                }
                if (targetDirection === "right") {
                    points = this._rightToTop(sourceBounds, sourcePortLocation, targetBounds, targetPortLocation);
                    reverse = true;
                }
                if (targetDirection === "top") {
                    points = this._topToTop(targetBounds, targetPortLocation, sourceBounds, sourcePortLocation);
                }
                if (targetDirection === "bottom") {
                    points = this._topToBottom(targetBounds, targetPortLocation, sourceBounds, sourcePortLocation);
                }
            }
            if (sourceDirection === "bottom") {
                if (targetDirection === "left") {
                    points = this._leftToBottom(sourceBounds, sourcePortLocation, targetBounds, targetPortLocation);
                    reverse = true;
                }
                if (targetDirection === "right") {
                    points = this._rightToBottom(sourceBounds, sourcePortLocation, targetBounds, targetPortLocation);
                    reverse = true;
                }
                if (targetDirection === "top") {
                    points = this._topToBottom(sourceBounds, sourcePortLocation, targetBounds, targetPortLocation);
                    reverse = true;
                }
                if (targetDirection === "bottom") {
                    points = this._bottomToBottom(targetBounds, targetPortLocation, sourceBounds, sourcePortLocation);
                }
            }
            if (reverse) {
                points.reverse();
            }
            var point1 = points[points.length - 1];
            var point2 = points[points.length - 2];
            while (points.length > 2 && point1.x == point2.x && point1.y == point2.y) {
                points.splice(points.length - 1, 1);
                point1 = points[points.length - 1];
                point2 = points[points.length - 2];
            }
            point1 = points[0];
            point2 = points[1];
            while (points.length > 2 && point1.x == point2.x && point1.y == point2.y) {
                points.splice(0, 1);
                point1 = points[0];
                point2 = points[1];
            }
            segment._startPoint = points[0];
            segment._endPoint = points[points.length - 1];
            segment.points = points;
            //this._setPoints(connector.line, points);
        },
        _updateIntermediateSegments: function (connector) {
            var startPoint = connector.segments[0]._endPoint;
            var prev = connector.segments[0];
            var length = prev.points.length;
            var next = null;
            var runAngle;
            if (connector.segments[1]) {
                var segment = connector.segments[1];
                segment._startPoint = startPoint;
                if (segment.type == "orthogonal" && (segment.length || segment.length === 0)) {
                    if (segment.direction == "left" || segment.direction == "right") {
                        if (connector.segments[2]) {
                            if (connector.segments[2].length || connector.segments[2].length === 0) {
                                if (connector.segments[2].direction == "top")
                                    connector.segments[2].length += segment._startPoint.y - segment._endPoint.y;
                                else
                                    connector.segments[2].length -= segment._startPoint.y - segment._endPoint.y;
                                if (connector.segments[2].length < 0) {
                                    connector.segments[2].length *= -1;
                                    connector.segments[2].direction = connector.segments[2]._direction = segment.direction == "right" ? "left" : "right";
                                }
                                connector.segments[2]._length = connector.segments[2].length;

                            }
                        }
                        segment._endPoint.y = segment._startPoint.y;
                    }
                    else {
                        if (connector.segments[2]) {
                            if (connector.segments[2].length || connector.segments[2].length === 0) {
                                if (connector.segments[2].direction == "left")
                                    connector.segments[2].length += segment._startPoint.x - segment._endPoint.x;
                                else
                                    connector.segments[2].length -= segment._startPoint.x - segment._endPoint.x;
                                if (connector.segments[2].length < 0) {
                                    connector.segments[2].length *= -1;
                                    connector.segments[2].direction = connector.segments[2]._direction = segment.direction == "bottom" ? "top" : "bottom";
                                }
                                connector.segments[2]._length = connector.segments[2].length;
                            }
                        }
                        segment._endPoint.x = segment._startPoint.x;
                    }
                    if (connector.sourcePort && prev.points.length > 2) {
                        if (segment.direction == "left" || segment.direction == "right") {
                            if (prev.points[prev.points.length - 1].y == prev.points[prev.points.length - 2].y) {
                                segment._startPoint = segment.points[0] = prev.points[prev.points.length - 2];
                                prev.points.splice(prev.points.length - 1, 1);
                                prev._endPoint = prev.points[prev.points.length - 1];
                                if (segment.points.length == 2) {
                                    segment._endPoint.y = segment._startPoint.y;
                                }
                            }
                        }
                        else {
                            if (prev.points[prev.points.length - 1].x == prev.points[prev.points.length - 2].x) {
                                segment._startPoint = segment.points[0] = prev.points[prev.points.length - 2];
                                prev.points.splice(prev.points.length - 1, 1);
                                prev._endPoint = prev.points[prev.points.length - 1];
                                if (segment.points.length == 2) {
                                    segment._endPoint.x = segment._startPoint.x;
                                }
                            }
                        }
                    }
                    if (segment.length || segment.length === 0)
                        segment.length = segment._length = ej.datavisualization.Diagram.Geometry.distance(segment._startPoint, segment.points[1]);
                    if (segment.length > 0)
                        segment.direction = segment._direction = this._getBezierDirection(segment._startPoint, segment._endPoint) || segment._direction;
                    this._addOrthogonalPoints(segment, prev, connector.segments[2], connector.sourcePoint, connector.targetPoint);
                    if (connector.segments[2])
                        this._addOrthogonalPoints(connector.segments[2], connector.segments[1], connector.segments[3], connector.sourcePoint, connector.targetPoint);
                }
                else if (segment.type == "orthogonal" && segment.length === null) {
                    if (connector.sourcePort && prev.points.length > 2) {
                        if (segment._direction == "left" || segment._direction == "right") {
                            if (prev.points[prev.points.length - 1].y == prev.points[prev.points.length - 2].y) {
                                segment._startPoint = segment.points[0] = prev.points[prev.points.length - 2];
                                prev.points.splice(prev.points.length - 1, 1);
                                prev._endPoint = prev.points[prev.points.length - 1];
                            }
                        }
                        else {
                            if (prev.points[prev.points.length - 1].x == prev.points[prev.points.length - 2].x) {
                                segment._startPoint = segment.points[0] = prev.points[prev.points.length - 2];
                                prev.points.splice(prev.points.length - 1, 1);
                                prev._endPoint = prev.points[prev.points.length - 1];
                            }
                        }
                    }
                    segment._startPoint = segment.points[0] = connector.segments[0]._endPoint;
                    this._addOrthogonalPoints(connector.segments[1], connector.segments[0], null, connector.sourcePoint, connector.targetPoint);
                }
                else {
                    segment._startPoint = segment.points[0] = connector.segments[0]._endPoint;
                    if (segment.type == "bezier") {
                        this._updateBezierPoints(segment);
                    }
                }
            }
        },
        _updatePreviousSegment: function (connector) {
            var previousSegment = connector.segments[connector.segments.length - 2];
            var current = connector.segments[connector.segments.length - 1];
            if (previousSegment) {
                if (previousSegment.type == "orthogonal" && current.points.length > 2) {
                    var update = false;
                    var direction = previousSegment.points.length == 2 ? previousSegment.direction :
                        ej.datavisualization.Diagram.Util._getBezierDirection(previousSegment.points[previousSegment.points.length - 2],
                        previousSegment.points[previousSegment.points.length - 1]);
                    if (direction == "left" || direction == "right") {
                        if (current.points[0].y == current.points[1].y) {
                            update = true;
                            var dif = current.points[1].x - current.points[0].x;
                            current.points.splice(0, 1);
                            current._startPoint = current.points[0];
                            previousSegment._endPoint = current.points[0];
                        }
                    }
                    else {
                        if (current.points[0].x == current.points[1].x) {
                            update = true;
                            current.points.splice(0, 1);
                            current._startPoint = current.points[0];
                            previousSegment._endPoint = current.points[0];
                        }
                    }
                }
                previousSegment._endPoint = current._startPoint;
                previousSegment.points[previousSegment.points.length - 1] = current._startPoint;
                if (previousSegment.type == "orthogonal" && update) {
                    previousSegment._length = previousSegment.length = ej.datavisualization.Diagram.Geometry.distance(previousSegment._startPoint, previousSegment._endPoint);
                    if (previousSegment._length > 0)
                        previousSegment._direction = previousSegment.direction = this._getBezierDirection(previousSegment._startPoint, previousSegment._endPoint);
                    if (connector.segments.length > 2 || !connector.sourcePort)
                        this._addOrthogonalPoints(previousSegment, connector.segments[connector.segments.length - 3], current, connector.sourcePoint, connector.targetPoint);
                }
                else {
                    previousSegment.point = current._startPoint;
                }
            }
        },
        _swapDirection: function (rotateAngle, direction) {
            var dir;
            var angle = rotateAngle % 360;
            if (angle < 0) {
                angle += 360;
            }
            var dirs;
            if (angle > 315 || angle < 45) {
                dir = direction;
            }
            else if (angle < 135) {
                dirs = { left: "top", top: "right", right: "bottom", bottom: "left" };
                dir = dirs[direction];
            }
            else if (angle < 225) {
                dirs = { left: "right", top: "bottom", right: "left", bottom: "top" };
                dir = dirs[direction];
            }
            else {
                dirs = { left: "bottom", top: "left", right: "top", bottom: "right" };
                dir = dirs[direction];
            }
            return dir;
        },
        _getIntersectionPoint: function (node, connectorSeg, segmentPoints) {
            var intersection, len = segmentPoints.length, i;
            var segment = ej.datavisualization.Diagram.Segment(segmentPoints[len - 1], segmentPoints[0]);
            if (node.shape.type != 'ellipse') {
                intersection = ej.datavisualization.Diagram.Geometry.intersectSegment(connectorSeg, segment);
            }
            if (!intersection) {
                for (i = 0; i < len - 1; i++) {
                    segment = ej.datavisualization.Diagram.Segment(segmentPoints[i], segmentPoints[i + 1]);
                    intersection = ej.datavisualization.Diagram.Geometry.intersectSegment(connectorSeg, segment);
                    if (intersection)
                        return intersection;
                }
            }
            else
                return intersection;
        },

        _getEllipseIntersectCoords: function (node, connectorSeg, connector) {
            var segmentPoints = [], intersection;
            var rx = node.width / 2;
            var ry = node.height / 2;
            var cx = node.offsetX - node.width / 2;
            var cy = node.offsetY - node.height / 2;

            //Convert Top Round Side to Path
            var topArchPath = "M " + (node.offsetX - node.width / 2) + ", " + (node.offsetY) + " A " + rx + " " + ry + " 0 0 " + 1 + " " + (node.offsetX + node.width / 2) + ", " + (node.offsetY);
            var path = document.createElementNS('http://www.w3.org/2000/svg', "path");
            path.setAttributeNS(null, "d", topArchPath);
            var len = path.getTotalLength(), pts = [], pt1, pt2, coor;
            for (var i = 0; i < len - 1; i++) {
                var pathSeg = path.getPointAtLength(i);
                pts[i] = pathSeg;
            }
            segmentPoints = pts;
            intersection = this._getIntersectionPoint(node, connectorSeg, segmentPoints);
            if (intersection)
                return intersection;

            segmentPoints = [];
            segmentPoints[0] = path.getPointAtLength(0);
            //Convert bottom Round Side to Path
            var bottomArchPath = "M " + (node.offsetX - node.width / 2) + ", " + (node.offsetY) + " A " + rx + " " + ry + " 0 0 " + 0 + " " + (node.offsetX + node.width / 2) + ", " + (node.offsetY);
            path.setAttributeNS(null, "d", bottomArchPath);
            len = path.getTotalLength();
            segmentPoints[1] = path.getPointAtLength(0);
            intersection = this._getIntersectionPoint(node, connectorSeg, segmentPoints);
            if (intersection)
                return intersection;
            segmentPoints = [];
            for (i = 0; i < len - 1; i++) {
                segmentPoints[i] = path.getPointAtLength(i);
            }
            intersection = this._getIntersectionPoint(node, connectorSeg, segmentPoints);
            if (intersection)
                return intersection;

            segmentPoints = [];
            segmentPoints[0] = path.getPointAtLength(len);
            path.setAttributeNS(null, "d", topArchPath);
            len = path.getTotalLength();
            segmentPoints[1] = path.getPointAtLength((len - 1));
            intersection = this._getIntersectionPoint(node, connectorSeg, segmentPoints);
            if (intersection)
                return intersection;
        },

        /**
         * Return length of an extension for source and target node bounds, which is used to determine the length
         * of the first segment of the connector near source and target nodes.
         * @return {Number} Minimal length of first segmnet of the connector.
         */
        getNodeBoundsExtension: function() {
            return 15;
        },

        _rightToLeft: function (targetBounds, targetPortLocation, sourceBounds, sourcePortLocation) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            var srcExtension = this.getNodeBoundsExtension();
            var tarExtension = this.getNodeBoundsExtension();
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            if (targetPortLocation.x > sourcePortLocation.x) {
                if (sourcePortLocation.y != targetPortLocation.y) {
                    if ((sourcePortLocation.x + srcExtension) >= targetBounds.left) {
                        x = sourceBounds.right + srcExtension;
                        y = sourcePortLocation.y;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if (targetPortLocation.y > sourceBounds.top) {
                            y = targetPortLocation.y;
                        }
                        else {
                            y = targetBounds.bottom + tarExtension;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if (targetPortLocation.y <= sourceBounds.top) {
                            x = targetBounds.right + tarExtension;
                            points.push(ej.datavisualization.Diagram.Point(x, y));
                            y = targetBounds.top - tarExtension;
                            points.push(ej.datavisualization.Diagram.Point(x, y));
                            x = targetPortLocation.x;
                            points.push(ej.datavisualization.Diagram.Point(x, y));
                        }
                    }
                    else {
                        x = sourceBounds.right + (targetBounds.left - sourceBounds.right) / 2;
                        y = sourcePortLocation.y;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetPortLocation.y;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            else {
                //5 segment
                if (Math.abs(targetBounds.top - sourceBounds.bottom) < 30 || Math.abs(targetBounds.bottom - sourceBounds.top) < 30) {
                    if ((sourcePortLocation.x + srcExtension) > targetBounds.right) {
                        x = sourcePortLocation.x + srcExtension;
                        y = sourcePortLocation.y;
                    }
                    else {
                        x = targetBounds.right + tarExtension;
                        y = sourcePortLocation.y;
                    }
                }
                else {
                    x = sourceBounds.right + srcExtension;
                    y = sourcePortLocation.y;
                }
                points.push(ej.datavisualization.Diagram.Point(x, y));
                if ((targetBounds.top - sourceBounds.bottom) >= 30) {
                    y = targetBounds.top - tarExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
                else if (sourcePortLocation.y > targetPortLocation.y) {
                    if ((sourceBounds.top - targetBounds.bottom) < 30) {
                        y = targetBounds.top - tarExtension;
                    }
                    else {
                        y = targetBounds.bottom + tarExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
                else {
                    y = targetBounds.bottom + tarExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
                x = targetBounds.left - tarExtension;
                points.push(ej.datavisualization.Diagram.Point(x, y));
                y = targetPortLocation.y;
                points.push(ej.datavisualization.Diagram.Point(x, y));
            }
            points.push(targetPortLocation);
            return points;
        },
        _rightToRight: function (targetBounds, targetPortLocation, sourceBounds, sourcePortLocation) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            y = sourcePortLocation.y;
            var srcExtension = this.getNodeBoundsExtension();
            var tarExtension = this.getNodeBoundsExtension();
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            if (targetBounds.right >= sourceBounds.left) {
                if (sourcePortLocation.y >= targetBounds.top && sourcePortLocation.y <= targetBounds.bottom) {
                    x = sourcePortLocation.x + srcExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if (sourcePortLocation.y >= targetBounds.center.y) {
                        if (sourcePortLocation.x > targetBounds.left) {
                            if (sourcePortLocation.y > targetPortLocation.y) {
                                y = targetBounds.bottom + tarExtension;
                            }
                            else {
                                y = targetBounds.top - tarExtension;
                            }
                        }
                        else {
                            y = targetBounds.top - tarExtension;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.right + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.right + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else if (targetBounds.right < sourceBounds.right) {
                    x = sourceBounds.right + srcExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    //points.push(ej.datavisualization.Diagram.Point(x, targetPortLocation.y));
                } else {
                    x = targetPortLocation.x + tarExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    //points.push(ej.datavisualization.Diagram.Point(x, targetPortLocation.y));
                }
            }
            else {
                x = sourcePortLocation.x + srcExtension;
                points.push(ej.datavisualization.Diagram.Point(x, y));
                if (targetPortLocation.y >= sourceBounds.top && targetPortLocation.y <= sourceBounds.bottom) {
                    if (targetPortLocation.y <= sourceBounds.center.y) {
                        y = sourceBounds.top - srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.right + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        y = sourceBounds.bottom + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.right + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            points.push(ej.datavisualization.Diagram.Point(x, targetPortLocation.y));
            points.push(targetPortLocation);
            return points;
        },
        _rightToTop: function (targetBounds, targetPortLocation, sourceBounds, sourcePortLocation) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            y = sourcePortLocation.y;
            var srcExtension = this.getNodeBoundsExtension();
            var tarExtension = this.getNodeBoundsExtension();
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            if (targetPortLocation.x >= sourcePortLocation.x) {
                if ((sourcePortLocation.y + srcExtension) >= targetPortLocation.y && targetBounds.height !== 0) {
                    if (targetBounds.left <= sourceBounds.right) {
                        x = targetBounds.right + tarExtension;
                    }
                    else if ((targetBounds.left - sourceBounds.right) > 30) {
                        x = sourceBounds.right + srcExtension;
                    }
                    else {
                        x = sourceBounds.right + (targetBounds.left - sourceBounds.right) / 2;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    y = targetBounds.top - tarExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
            }
            else {
                if (sourceBounds.bottom >= targetBounds.top) {
                    if ((sourcePortLocation.x + srcExtension) <= targetBounds.right) {
                        x = targetBounds.right + tarExtension;
                    }
                    else {
                        x = sourceBounds.right + srcExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if (sourceBounds.top >= targetBounds.top) {
                        if (targetBounds.height !== 0) {
                            y = targetBounds.top - tarExtension;
                        }
                        else {
                            y = targetPortLocation.y;
                        }
                    }
                    else {
                        y = sourceBounds.top - srcExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
                else {
                    x = sourcePortLocation.x + srcExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if ((targetBounds.top - sourceBounds.bottom) < 30 && targetBounds.height !== 0) {
                        if ((sourceBounds.left - targetBounds.right) >= 30) {
                            y = sourceBounds.bottom + srcExtension;
                            points.push(ej.datavisualization.Diagram.Point(x, y));
                            x = sourceBounds.left - srcExtension;
                            points.push(ej.datavisualization.Diagram.Point(x, y));
                            y = targetBounds.top - tarExtension;
                            points.push(ej.datavisualization.Diagram.Point(x, y));
                        }
                        else {
                            y = targetBounds.top - (targetBounds.top - sourceBounds.bottom) / 2;
                            points.push(ej.datavisualization.Diagram.Point(x, y));
                        }
                    }
                    else {
                        if (targetBounds.height !== 0) {
                            y = targetBounds.top - tarExtension;
                        }
                        else {
                            y = targetPortLocation.y;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            points.push(ej.datavisualization.Diagram.Point(targetPortLocation.x, y));
            points.push(targetPortLocation);
            return points;
        },
        _rightToBottom: function (targetBounds, targetPortLocation, sourceBounds, sourcePortLocation) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            y = sourcePortLocation.y;
            var srcExtension = this.getNodeBoundsExtension();
            var tarExtension = this.getNodeBoundsExtension();
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            if (targetPortLocation.x >= sourcePortLocation.x) {
                if (sourcePortLocation.y <= targetBounds.bottom) {
                    if (targetBounds.left > (sourceBounds.right + srcExtension)) {
                        x = sourcePortLocation.x + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        x = targetBounds.right + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else {
                    if ((sourceBounds.right + srcExtension) > targetPortLocation.x) {
                        x = sourcePortLocation.x + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if ((sourceBounds.top - targetBounds.bottom) > 30) {
                            y = targetBounds.bottom + tarExtension;
                        }
                        else {
                            y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        y = sourcePortLocation.y;
                    }
                }
            }
            else {
                if (sourcePortLocation.y <= targetBounds.bottom) {
                    if ((sourceBounds.right + srcExtension) > targetBounds.right) {
                        x = sourceBounds.right + srcExtension;
                    }
                    else {
                        x = targetBounds.right + tarExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    y = targetBounds.bottom + tarExtension;
                    if (y <= (sourceBounds.bottom + srcExtension)) {
                        y = sourceBounds.bottom + srcExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
                else {
                    if ((targetBounds.bottom) < sourceBounds.top) {
                        x = sourceBounds.right + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if ((sourceBounds.top - targetBounds.bottom) < 30) {
                            y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                        }
                        else {
                            y = targetBounds.bottom + tarExtension;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        x = sourceBounds.right + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = sourceBounds.bottom + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            points.push(ej.datavisualization.Diagram.Point(targetPortLocation.x, y));
            points.push(targetPortLocation);
            return points;
        },
        _leftToLeft: function (targetBounds, targetPortLocation, sourceBounds, sourcePortLocation) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            y = sourcePortLocation.y;
            var srcExtension = this.getNodeBoundsExtension();
            var tarExtension = this.getNodeBoundsExtension();
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            if (targetPortLocation.x >= sourcePortLocation.x) {
                x = sourceBounds.left - srcExtension;
                points.push(ej.datavisualization.Diagram.Point(x, y));
                if (sourcePortLocation.y > targetPortLocation.y) {
                    if ((targetPortLocation.y + tarExtension) >= sourceBounds.top) {
                        y = sourceBounds.top - srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if ((targetBounds.left - sourceBounds.right) > 30) {
                            x = targetBounds.left - tarExtension;
                        }
                        else {
                            x = sourceBounds.right + (targetBounds.left - sourceBounds.right) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        y = targetPortLocation.y;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetPortLocation.x;
                    }
                }
                else {
                    if ((sourceBounds.bottom + srcExtension) < targetPortLocation.y) {
                        y = targetPortLocation.y;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetPortLocation.x;
                    }
                    else {
                        y = sourceBounds.bottom + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if ((targetBounds.left - sourceBounds.right) > 30) {
                            x = targetBounds.left - tarExtension;
                        }
                        else {
                            x = sourceBounds.right + (targetBounds.left - sourceBounds.right) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            else {
                if (targetPortLocation.y > sourcePortLocation.y) {
                    if (sourcePortLocation.y > (targetBounds.top - tarExtension)) {
                        if ((sourceBounds.left - targetBounds.right) < 30) {
                            x = targetBounds.right + (sourceBounds.left - targetBounds.right) / 2;
                        }
                        else {
                            x = sourceBounds.left - srcExtension;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.top - tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else {
                    if ((targetBounds.bottom + tarExtension) >= sourcePortLocation.y) {
                        if ((sourceBounds.left - targetBounds.right) < 30) {
                            x = targetBounds.right + (sourceBounds.left - targetBounds.right) / 2;
                        }
                        else {
                            x = sourceBounds.left - srcExtension;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.left - tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                x = targetBounds.left - tarExtension;
                points.push(ej.datavisualization.Diagram.Point(x, y));
            }
            points.push(ej.datavisualization.Diagram.Point(x, targetPortLocation.y));
            points.push(targetPortLocation);
            return points;
        },
        _leftToTop: function (targetBounds, targetPortLocation, sourceBounds, sourcePortLocation) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            y = sourcePortLocation.y;
            var srcExtension = this.getNodeBoundsExtension();
            var tarExtension = this.getNodeBoundsExtension();
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            if (sourcePortLocation.x <= targetPortLocation.x) {
                if (sourcePortLocation.y > targetPortLocation.y && targetBounds.left <= sourceBounds.left) {
                    x = targetBounds.left - tarExtension;
                }
                else {
                    x = sourceBounds.left - srcExtension;
                }
                points.push(ej.datavisualization.Diagram.Point(x, y));
                if (sourceBounds.bottom <= targetBounds.top) {
                    if ((sourceBounds.bottom + srcExtension) < targetBounds.top) {
                        if (targetBounds.height !== 0) {
                            y = targetBounds.top - tarExtension;
                        }
                        else {
                            y = targetPortLocation.y;
                        }
                    }
                    else if (targetPortLocation.x < sourceBounds.right) {
                        y = sourceBounds.bottom + (targetBounds.top - sourceBounds.bottom) / 2;
                    }
                    else {
                        y = sourceBounds.top - srcExtension;
                    }
                }
                else {
                    if (sourceBounds.top >= targetBounds.top) {
                        if (targetBounds.height !== 0) {
                            y = targetBounds.top - tarExtension;
                        }
                        else {
                            y = targetPortLocation.y;
                        }
                    }
                    else {
                        y = sourceBounds.top - srcExtension;
                    }
                }
                points.push(ej.datavisualization.Diagram.Point(x, y));
            }
            else {
                if (targetPortLocation.y <= (sourcePortLocation.y + srcExtension)) {
                    if ((sourceBounds.left - targetBounds.right) > 30) {
                        x = sourceBounds.left - srcExtension;
                    }
                    else {
                        if (targetBounds.right >= sourceBounds.left) {
                            x = targetBounds.left - tarExtension;
                        }
                        else {
                            x = targetBounds.right + (sourceBounds.left - targetBounds.right) / 2;
                        }
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    y = targetBounds.top - tarExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
            }
            points.push(ej.datavisualization.Diagram.Point(targetPortLocation.x, y));
            points.push(targetPortLocation);
            return points;
        },
        _leftToBottom: function (targetBounds, targetPortLocation, sourceBounds, sourcePortLocation) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            y = sourcePortLocation.y;
            var srcExtension = this.getNodeBoundsExtension();
            var tarExtension = this.getNodeBoundsExtension();
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            if (sourcePortLocation.x <= targetPortLocation.x) {
                if (targetBounds.left <= sourcePortLocation.x && sourcePortLocation.y <= targetBounds.top) {
                    x = targetBounds.left - tarExtension;
                }
                else {
                    x = sourceBounds.left - srcExtension;
                }
                points.push(ej.datavisualization.Diagram.Point(x, y));
                if (targetBounds.bottom < sourceBounds.top) {
                    if ((sourceBounds.top - targetBounds.bottom) < 30) {
                        y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                    }
                    else {
                        y = targetBounds.bottom + tarExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
                else {
                    if (targetBounds.bottom < sourceBounds.bottom) {
                        y = sourceBounds.bottom + srcExtension;
                    }
                    else {
                        y = targetBounds.bottom + tarExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
            }
            else {
                if (!(sourcePortLocation.y > targetPortLocation.y)) {
                    if (targetBounds.right >= sourceBounds.left) {
                        x = targetBounds.left - tarExtension;
                    }
                    else if ((sourceBounds.left - targetBounds.right) < 30) {
                        x = sourceBounds.left - (sourceBounds.left - targetBounds.right) / 2;
                    }
                    else {
                        x = sourceBounds.left - srcExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    y = targetBounds.bottom + tarExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
            }
            points.push(ej.datavisualization.Diagram.Point(targetPortLocation.x, y));
            points.push(targetPortLocation);
            return points;
        },
        _topToTop: function (targetBounds, targetPortLocation, sourceBounds, sourcePortLocation) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            x = sourcePortLocation.x;
            var srcExtension = this.getNodeBoundsExtension();
            var tarExtension = this.getNodeBoundsExtension();
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            if (targetPortLocation.x >= sourcePortLocation.x) {
                if (targetPortLocation.y >= sourcePortLocation.y) {
                    y = sourceBounds.top - srcExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if (targetPortLocation.x <= sourceBounds.right) {
                        x = sourceBounds.right + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if (targetBounds.height !== 0) {
                            if ((targetBounds.top - sourceBounds.bottom) > 30) {
                                y = targetBounds.top - tarExtension;
                            }
                            else {
                                y = sourceBounds.bottom + (targetBounds.top - sourceBounds.bottom) / 2;
                            }
                        }
                        else {
                            y = targetPortLocation.y;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else {
                    if (targetBounds.left <= sourcePortLocation.x) {
                        if ((sourceBounds.top - targetBounds.bottom) > 30) {
                            y = sourceBounds.top - srcExtension;
                        }
                        else {
                            y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.left - tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.top - tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        if (targetBounds.height !== 0) {
                            y = targetBounds.top - tarExtension;
                        }
                        else {
                            y = targetPortLocation.y;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            else {
                if (targetPortLocation.y >= sourcePortLocation.y) {
                    y = sourceBounds.top - srcExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if (targetPortLocation.x >= sourceBounds.left) {
                        x = sourceBounds.left - srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if (targetBounds.height !== 0) {
                            if ((targetBounds.top - sourceBounds.bottom) > 30) {
                                y = targetBounds.top - tarExtension;
                            }
                            else {
                                y = sourceBounds.bottom + (targetBounds.top - sourceBounds.bottom) / 2;
                            }
                        }
                        else {
                            y = targetPortLocation.y;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else {
                    if (targetBounds.right >= sourcePortLocation.x) {
                        if ((sourceBounds.top - targetBounds.bottom) > 30) {
                            y = sourceBounds.top - srcExtension;
                        }
                        else {
                            y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.right + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.top - tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        if (targetBounds.height !== 0) {
                            y = targetBounds.top - tarExtension;
                        }
                        else {
                            y = targetPortLocation.y;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            x = targetPortLocation.x;
            points.push(ej.datavisualization.Diagram.Point(x, y));
            points.push(targetPortLocation);
            return points;
        },
        _topToBottom: function (targetBounds, targetPortLocation, sourceBounds, sourcePortLocation) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            x = sourcePortLocation.x;
            var srcExtension = this.getNodeBoundsExtension();
            var tarExtension = this.getNodeBoundsExtension();
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            var min = 30;
            if (targetPortLocation.x > sourcePortLocation.x) {
                if (sourceBounds.top >= targetBounds.bottom) {
                    if ((sourceBounds.top - targetBounds.bottom) >= 30) {
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if ((targetBounds.left - sourceBounds.right) >= 30) {
                            x = sourceBounds.right + srcExtension;
                        }
                        else {
                            x = sourceBounds.right + (targetBounds.left - sourceBounds.right) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else {
                    if (targetBounds.top < sourceBounds.top) {
                        if (targetBounds.left >= (sourceBounds.right + 15)) {
                            y = sourceBounds.top - srcExtension;
                        }
                        else {
                            y = targetBounds.top - tarExtension;
                        }
                    }
                    else {
                        y = sourceBounds.top - srcExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if (targetBounds.left >= (sourceBounds.right + 15)) {
                        x = sourceBounds.right + srcExtension;
                    }
                    else {
                        x = targetBounds.right + tarExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    y = targetBounds.bottom + tarExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
                points.push(ej.datavisualization.Diagram.Point(targetPortLocation.x, y));
            }
            else if (targetPortLocation.x < sourcePortLocation.x) {
                if (sourceBounds.top >= targetBounds.bottom) {
                    if ((sourceBounds.top - targetBounds.bottom) > 30) {
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if ((sourceBounds.left - targetBounds.right) >= 30) {
                            x = sourceBounds.left - srcExtension;
                        }
                        else {
                            x = targetBounds.right + (sourceBounds.left - targetBounds.right) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else {
                    if (sourceBounds.left >= (targetBounds.right + 15)) {
                        y = sourceBounds.top - srcExtension;
                    }
                    else {
                        y = sourceBounds.top - srcExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if (sourceBounds.left >= (targetBounds.right + 15)) {
                        x = targetBounds.right + tarExtension;
                    }
                    else {
                        x = sourceBounds.right + srcExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if (sourceBounds.left >= (targetBounds.right + 15)) {
                        y = targetBounds.bottom + tarExtension;
                    }
                    else {
                        if (targetBounds.bottom <= sourceBounds.bottom) {
                            y = sourceBounds.bottom + srcExtension;
                        }
                        else {
                            y = targetBounds.bottom + tarExtension;
                        }
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
                points.push(ej.datavisualization.Diagram.Point(targetPortLocation.x, y));
            }
            points.push(targetPortLocation);
            return points;
        },
        _bottomToBottom: function (targetBounds, targetPortLocation, sourceBounds, sourcePortLocation) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            x = sourcePortLocation.x;
            var srcExtension = this.getNodeBoundsExtension();
            var tarExtension = this.getNodeBoundsExtension();
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            if (targetPortLocation.x >= sourcePortLocation.x) {
                if (sourceBounds.bottom >= targetBounds.bottom) {
                    y = sourceBounds.bottom + srcExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if ((targetPortLocation.x) < sourceBounds.right) {
                        x = sourceBounds.right + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if (sourceBounds.top >= targetBounds.bottom) {
                            if ((sourceBounds.top - targetBounds.bottom) >= 30) {
                                y = targetBounds.bottom + tarExtension;
                            }
                            else {
                                y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                            }
                        }
                        else {
                            y = targetBounds.bottom + tarExtension;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else {
                    if (sourcePortLocation.x > targetBounds.left) {
                        if ((targetBounds.bottom - sourceBounds.bottom) >= 30) {
                            y = sourceBounds.bottom + srcExtension;
                        }
                        else {
                            y = sourceBounds.bottom + (targetBounds.bottom - sourceBounds.bottom) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.left - tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            else {
                if (sourceBounds.bottom >= targetBounds.bottom) {
                    y = sourceBounds.bottom + srcExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if (targetPortLocation.x > sourceBounds.left) {
                        x = sourceBounds.left - srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if (sourceBounds.top >= targetBounds.bottom) {
                            if ((sourceBounds.top - targetBounds.bottom) >= 30) {
                                y = targetBounds.bottom + tarExtension;
                            }
                            else {
                                y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                            }
                        }
                        else {
                            y = targetBounds.bottom + tarExtension;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else {
                    if (sourcePortLocation.x < targetBounds.right) {
                        if ((targetBounds.bottom - sourceBounds.bottom) >= 30) {
                            y = sourceBounds.bottom + srcExtension;
                        }
                        else {
                            y = sourceBounds.bottom + (targetBounds.bottom - sourceBounds.bottom) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.right + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            points.push(ej.datavisualization.Diagram.Point(targetPortLocation.x, y));
            points.push(targetPortLocation);
            return points;
        },
        _addOrthogonalPoints: function (line, prev, next, sourcePt, endPt, runAngle) {
            var points = [];
            var strt = prev ? prev._endPoint : sourcePt;
            points.push(strt);
            if (!line._direction) line._direction = this._getOrthoDirection(strt, endPt, prev);
            var angle = (!runAngle && runAngle != 0) ? this._directionToAngle(line._direction || this._getBezierDirection(strt, endPt)) : runAngle;
            var direction = line._direction;
            var angles = { "right": 0, "left": 180, "top": 270, "bottom": 90, "auto": 90 };
            if (direction == "left" || direction == "right" || direction == "top" || direction == "bottom") {
                angle = angles[direction];
            }
            else {
                switch (direction) {
                    case "straight":
                        angle = 1 - 1;
                        break;
                    case "clockWise90":
                        angle += 91 - 1;
                        break;
                    case "opposite":
                        angle += 181 - 1;
                        break;
                    case "antiClockWise90":
                        angle += 271 - 1;
                        break;
                }
            }
            if ((line.length || line.length == 0) && line.direction) {
                var ctrlPoint1 = ej.datavisualization.Diagram.Geometry.transform(strt, angle || 0, line._length);
                ctrlPoint1.x = Math.round(ctrlPoint1.x * 100) / 100;
                ctrlPoint1.y = Math.round(ctrlPoint1.y * 100) / 100;
                points.push(ctrlPoint1);
                line._endPoint = ctrlPoint1;
                if (next) {
                    next._startPoint = line._endPoint;
                    if (next.points) {
                        next.points[0] = line._endPoint;
                        if (next.type == "bezier") {
                            this._updateBezierPoints(next);
                        }
                    }
                }
            }
            else {
                if (strt.x != endPt.x && strt.y != endPt.y) {
                    var extra = 20;
                    if (!prev) {
                        var ctrlPoint1 = ej.datavisualization.Diagram.Geometry.transform(strt, angle, extra);
                    }
                    var tempx = endPt.x - (ctrlPoint1 ? ctrlPoint1.x : strt.x);
                    var tempy = endPt.y - (ctrlPoint1 ? ctrlPoint1.y : strt.y);
                    tempx = Math.abs(tempx) <= 0.0001 ? 0 : tempx;
                    tempy = Math.abs(tempy) <= 0.0001 ? 0 : tempy;
                    var direction = line._direction == "auto" ? prev ? prev._direction == "left" || prev.direction == "right" ? "left" : "top" : "bottom" : line._direction;
                    if ((direction == "left" || direction == "right") && tempx != 0 || tempy == 0) {
                        tempy = tempy > 0 ? tempy : -tempy;
                        if (tempy > 0) {
                            var ctrlPoint2 = ej.datavisualization.Diagram.Geometry.transform(ctrlPoint1 || strt, 90, endPt.y - (ctrlPoint1 ? ctrlPoint1.y : strt.y));
                        }
                    }
                    else {
                        tempx = tempx > 0 ? tempx : -tempx;
                        if (tempx > 0) {
                            var ctrlPoint2 = ej.datavisualization.Diagram.Geometry.transform(ctrlPoint1 || strt, 0, endPt.x - (ctrlPoint1 ? ctrlPoint1.x : strt.x));
                        }

                    }
                    if (ctrlPoint1) {
                        ctrlPoint1.x = Math.round(ctrlPoint1.x * 100) / 100;
                        ctrlPoint1.y = Math.round(ctrlPoint1.y * 100) / 100;
                        points.push(ctrlPoint1);
                    }
                    if (ctrlPoint2) {
                        ctrlPoint2.x = Math.round(ctrlPoint2.x * 100) / 100;
                        ctrlPoint2.y = Math.round(ctrlPoint2.y * 100) / 100;
                        points.push(ctrlPoint2);
                    }
                }
                line._direction = this._getBezierDirection(points[points.length - 1], endPt);
                points.push(endPt);
                line._endPoint = endPt;
                if (next) {
                    next._startPoint = line._endPoint;
                    if (!next.points) next.points = [];
                    next.points[0] = line._endPoint;
                    if (next.type == "bezier") {
                        this._updateBezierPoints(next);
                    }
                }
            }
            line.points = points;
            return angle;
        },
        _getOrthoDirection: function (src, point, prev) {
            if (!prev) {
                if (src.y < point.y) {
                    return "bottom";
                }
                else if (src.y > point.y) {
                    return "top";
                }
                else if (src.x < point.x) {
                    return "right";
                }
                else if (src.x > point.x) {
                    return "left";
                }
            }
            else {
                var tar = point;
                if (Math.abs(tar.x - src.x) > Math.abs(tar.y - src.y) && (prev && (prev._direction == "left" || prev._direction == "right"))) {
                    return src.x < tar.x ? "right" : "left";
                }
                else {
                    return src.y < tar.y ? "bottom" : "top";
                }
            }
        },
        _directionToAngle: function (direction) {
            var angles = { "right": 0, "left": 180, "top": 270, "bottom": 90, "auto": 90 };
            return angles[direction];
        },
        _resetOrthogonalPoints: function (line) {
            var points = [];
            points.push(line.sourcePoint);
            points.push(line.targetPoint);
            line.points = [];
            line.sourcePoint = points[0];
            line.points.push(points[0]);
            var ctrlPoints = this._constructOrthogonalPoints(points[0], points[1]);
            line.points.push(ctrlPoints[0]);
            line.points.push(ctrlPoints[1]);
            line.targetPoint = points[1];
            line.points.push(points[1]);
        },
        _updateBezierPoints: function (line, targetNode, targetPort, targetBounds, sourceNode, sourcePort, sourceBounds) {
            var bounds;
            var angles = { "right": 0, "left": 180, "top": 270, "bottom": 90 };
            if (line.vector1 || line.vector2) {
                if (line.vector1) {
                    line._point1 = ej.datavisualization.Diagram.Geometry.transform(line._startPoint, line.vector1.angle, line.vector1.distance);
                }
                if (line.vector2) {
                    line._point2 = ej.datavisualization.Diagram.Geometry.transform(line._endPoint, line.vector2.angle, line.vector2.distance);
                }
            }
            if ((line.point1 == null && !line.vector1) || (line.point2 == null && !line.vector2)) {
                var target = line._endPoint;
                var source = line._startPoint;
                var dir;
                var matrix;
                if (!sourcePort)
                    dir = this._getBezierDirection(source, target);
                else {
                    bounds = sourceBounds;
                    source = this._getPortPosition(sourcePort, bounds);
                    if (sourceNode.rotateAngle !== 0) {
                        matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, sourceNode.rotateAngle, sourceNode.offsetX, sourceNode.offsetY);
                        source = ej.Matrix.transform(matrix, source);
                    }
                    dir = this._getDirection(bounds, source, true);
                }
                if (!line.vector1)
                    line._point1 = line.point1 || this._getBezierAdjPoint(angles[dir], line._startPoint, line._endPoint);
                if (!targetPort) {
                    dir = this._getBezierDirection(target, source);
                }
                else {
                    bounds = targetBounds;
                    target = this._getPortPosition(targetPort, bounds);
                    if (targetNode.rotateAngle !== 0) {
                        matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, targetNode.rotateAngle, targetNode.offsetX, targetNode.offsetY);
                        target = ej.Matrix.transform(matrix, target);
                    }
                    dir = this._getDirection(bounds, target, true);
                }
                if (!line.vector2)
                    line._point2 = line.point2 || this._getBezierAdjPoint(angles[dir], line._endPoint, line._startPoint);
            }
        },
        _getBezierDirection: function (src, tar) {
            if (Math.abs(tar.x - src.x) > Math.abs(tar.y - src.y)) {
                return src.x < tar.x ? "right" : "left";
            }
            else {
                return src.y < tar.y ? "bottom" : "top";
            }
        },
        _getDirection: function (bounds, point, excludeBounds) {
            var points = bounds.points;
            var center = bounds.center;
            var part = excludeBounds ? 45 : 360 / (8 * (bounds.width / bounds.height));
            var fourty5 = part;
            var one35 = (180 - part);
            var two25 = one35 + (2 * part);
            var three15 = 360 - part;
            var dir;
            var angle = ej.datavisualization.Diagram.Geometry.findAngle(point, center);
            if (angle > fourty5 && angle < one35) {
                dir = "top";
            }
            else if (angle > one35 && angle < two25) {
                dir = "right";
            }
            else if (angle > two25 && angle < three15) {
                dir = "bottom";
            }
            else {
                dir = "left";
            }
            return dir;
        },
        _getBezierAdjPoint: function (angle, srcEnd, tarEnd) {
            var distance = 60;
            var endAdj = ej.datavisualization.Diagram.Point(0, 0);
            var dir;
            if (angle > 45 && angle < 135) {
                dir = "Bottom";
            }
            else if (angle > 135 && angle < 225) {
                dir = "Left";
            }
            else if (angle > 225 && angle < 315) {
                dir = "Top";
            }
            else {
                dir = "Right";
            }
            switch (dir) {
                case "Right":
                    distance = Math.min(Math.abs(srcEnd.x - tarEnd.x) * 0.45, distance);
                    endAdj = ej.datavisualization.Diagram.Point(srcEnd.x + distance, srcEnd.y);
                    break;
                case "Bottom":
                    distance = Math.min(Math.abs(srcEnd.y - tarEnd.y) * 0.45, distance);
                    endAdj = ej.datavisualization.Diagram.Point(srcEnd.x, srcEnd.y + distance);
                    break;
                case "Left":
                    distance = Math.min(Math.abs(srcEnd.x - tarEnd.x) * 0.45, distance);
                    endAdj = ej.datavisualization.Diagram.Point(srcEnd.x - distance, srcEnd.y);
                    break;
                case "Top":
                    distance = Math.min(Math.abs(srcEnd.y - tarEnd.y) * 0.45, distance);
                    endAdj = ej.datavisualization.Diagram.Point(srcEnd.x, srcEnd.y - distance);
                    break;
            }
            return endAdj;
        },
        _setLineEndPoint: function (connector, point, isTarget, dock) {
            var line = connector;
            point.x = Math.round(point.x * 100) / 100;
            point.y = Math.round(point.y * 100) / 100;
            if (isTarget) {
                var lastsegment = connector.segments[connector.segments.length - 1];
                line.targetPoint = point;
                if (lastsegment.type != "orthogonal") {
                    lastsegment.point = lastsegment._point = point;
                }
                lastsegment.points[lastsegment.points.length - 1] = point;
                lastsegment._endPoint = point;
            }
            else {
                line.sourcePoint = point;
                var first = connector.segments[0];
                first.points[0] = point;
                first._startPoint = point;
                if (first.type == "orthogonal" && !connector.sourcePort) {
                    if (first.points.length == 2) {
                        if (first._direction == "left" || first._direction == "right") {
                            first._endPoint.y = first._startPoint.y;
                            var length = Math.abs(first._startPoint.x - first._endPoint.x);
                        }
                        else {
                            first._endPoint.x = first._startPoint.x;
                            var length = Math.abs(first._startPoint.y - first._endPoint.y);
                        }


                        connector.segments[0]._length = length;
                        if (connector.segments[0].length || connector.segments[0].length === 0) {
                            connector.segments[0].length = connector.segments[0]._length;
                            connector.segments[0].direction = connector.segments[0]._direction;
                        }
                    }
                }
            }
            var segment = isTarget ? connector.segments[connector.segments.length - 1] : connector.segments[0];
            if (segment.type === "orthogonal" && ((!isTarget && !connector.sourcePort) || isTarget && !connector.targetPort) && (!(connector.sourceNode && connector.targetNode) || connector.segments.length > 1)) {
                segment.points = [];
                this._addOrthogonalPoints(segment, isTarget ? connector.segments[connector.segments.length - 2] : null,
                    isTarget ? null : connector.segments[1], connector.sourcePoint, connector.targetPoint);

            }
            else if (segment.type === "bezier") {
                this._updateBezierPoints(segment);
            }

        },
        _setBezierPoint: function (segment, point, whichpoint) {
            if (whichpoint === "bezierpoint1") {
                if (segment.vector1) {
                    segment.vector1 = {
                        distance: ej.datavisualization.Diagram.Geometry.distance(segment._startPoint, point),
                        angle: ej.datavisualization.Diagram.Geometry.findAngle(segment._startPoint, point),
                    };
                    segment._point1 = point;
                }
                else
                    segment.point1 = segment._point1 = point;
            }
            else {
                if (segment.vector2) {
                    segment.vector2 = {
                        distance: ej.datavisualization.Diagram.Geometry.distance(segment._endPoint, point),
                        angle: ej.datavisualization.Diagram.Geometry.findAngle(segment._endPoint, point),
                    };
                    segment._point2 = point;
                }
                else
                    segment.point2 = segment._point2 = point;
            }
        },
        _setPoints: function (line, points) {
            line.sourcePoint = line.points[0] = points[0];
            line.targetPoint = line.points[line.points.length - 1] = points[points.length - 1];
            line.points = points;
            if (line.type === "bezier") {
                line.point1 = points[2] || line.point1;
                line.point2 = points[3] || line.point2;
                if (!line.point1)
                    line._point1 = line.point1;
                if (!line.point2)
                    line._point2 = line.point2;
                this._updateBezierPoints(line);
            }
        },
        _updateConnectorSegments: function (connector, ignoreSource, ignoreTarget, diagram) {
            var runAngle;
            var startPoint = connector.sourcePoint;
            for (var i = 0; i < connector.segments.length; i++) {
                var segment = connector.segments[i];
                var prev = connector.segments[i - 1];
                var next = connector.segments[i + 1];
                segment._startPoint = prev ? prev._endPoint : startPoint;
                if (!(i == 0 && ignoreSource) && !(i == connector.segments.length - 1 && ignoreTarget)) {
                    if (segment.type == "orthogonal")
                        runAngle = ej.datavisualization.Diagram.Util._addOrthogonalPoints(segment, prev, next, connector.sourcePoint, connector.targetPoint, runAngle);
                    else {
                        runAngle = ej.datavisualization.Diagram.Geometry.findAngle(startPoint, segment._endPoint);
                        if (segment.type == "bezier") {
                            this._updateBezierPoints(segment);
                        }
                    }
                }
                startPoint = segment._endPoint;
            }
            if (diagram) {
                diagram._dock(connector, diagram.nameTable);
            }
        },
        _translateLine: function (connector, dx, dy, parent) {
            for (var i = 0; i < connector.segments.length; i++) {
                var segment = connector.segments[i];
                var next = connector.segments[i + 1];
                for (var j = 0; j < segment.points.length; j++) {
                    if (j == 0) {
                        segment._startPoint = segment.points[j] = ej.datavisualization.Diagram.Geometry.translate(segment.points[j], dx, dy);
                        if (i == 0) {
                            connector.sourcePoint = segment._startPoint;
                        }
                    }
                    else if (j == segment.points.length - 1) {
                        segment._endPoint = segment.points[j] = ej.datavisualization.Diagram.Geometry.translate(segment.points[j], dx, dy)
                        if (i == connector.segments.length - 1)
                            connector.targetPoint = segment._endPoint;
                    }
                    else segment.points[j] = ej.datavisualization.Diagram.Geometry.translate(segment.points[j], dx, dy);
                }
                if (segment.type === ej.datavisualization.Diagram.Segments.Bezier) {
                    segment._point1 = ej.datavisualization.Diagram.Geometry.translate(segment._point1, dx, dy);
                    segment._point2 = ej.datavisualization.Diagram.Geometry.translate(segment._point2, dx, dy);
                    if (segment.point1) { segment.point1 = segment._point1; }
                    if (segment.point2) { segment.point2 = segment._point2; }
                    segment.point = segment._endPoint;
                }
                else if (segment.type == "straight") {
                    segment.point = segment._point = segment._endPoint;
                }
            }
            //if (parent) {
            //    if(connector.segments[0].type == "orthogonal"){
            //        if (!this.isSourceConnected(parent)) {
            //            this._addOrthogonalPoints(connector.segments[0],null,connector.segments[1],connector.sourcePoint,connector.targetPoint);
            //        }
            //    }
            //    if(connector.segments[connector.segments.length-1].type == "orthogonal"){
            //        var segment=connector.segments[connector.segments.length-1];
            //        if( !this.isTargetConnected(parent)){
            //            this._addOrthogonalPoints(segment,connector.segments[connector.segments.length-2],null,connector.sourcePoint,connector.targetPoint);
            //        }
            //    }
            //}
        },
        _adjustPoint: function (source, target, isStart, length) {
            var pt = isStart ? { x: source.x, y: source.y } : { x: target.x, y: target.y };

            if (source.x == target.x) {
                if (source.y < target.y && isStart || source.y > target.y && !isStart)
                    pt.y += length;
                else pt.y -= length;
            }
            else if (source.y == target.y) {
                if (source.x < target.x && isStart || source.x > target.x && !isStart)
                    pt.x += length;
                else pt.x -= length;
            }
            else {
                var angle;
                if (isStart) {
                    angle = ej.datavisualization.Diagram.Geometry.findAngle(source, target);
                    pt = ej.datavisualization.Diagram.Geometry.transform(source, angle, length);
                }
                else {
                    angle = ej.datavisualization.Diagram.Geometry.findAngle(target, source);
                    pt = ej.datavisualization.Diagram.Geometry.transform(target, angle, length);
                }
            }
            return pt;
        },
        _getLabelPosition: function (label, bounds) {
            var x = (bounds.width * label.offset.x);
            var y = (bounds.height * label.offset.y);
            if (label.horizontalAlignment != "right")
                x += label.margin.left;
            else
                x -= label.margin.right;
            if (label.verticalAlignment != "bottom")
                y += label.margin.top;
            else
                y -= label.margin.bottom;
            return ej.datavisualization.Diagram.Point(x, y);
        },
        _getPortPosition: function (port, bounds, bExcludeBoundsLocation) {
            if (bExcludeBoundsLocation) {
                return ej.datavisualization.Diagram.Point(bounds.width * port.offset.x, bounds.height * port.offset.y);
            }
            else {
                var x = bounds.x + (bounds.width * port.offset.x);
                var y = bounds.y + (bounds.height * port.offset.y);
                return ej.datavisualization.Diagram.Point(x, y);
            }
        },

        _translate: function (node, dx, dy, nameTable, isContainer, diagram) {
            if (ej.datavisualization.Diagram.Util.canMove(node)) {
                if (!node.segments) {
                    node.offsetX += dx;
                    node.offsetY += dy;
                    if (node.type == "group" && !isContainer) {
                        var nodes = diagram._getChildren(node.children);
                        var child;
                        for (var i = 0; i < nodes.length; i++) {
                            child = nameTable[nodes[i]];
                            this._translate(child, dx, dy, nameTable);
                            if (child.parent && (child.parent != node.name && node.type != "pseudoGroup"))
                                ej.datavisualization.Diagram.Util._updateGroupBounds(nameTable[child.parent], diagram);
                        }
                        if (node.type != "group" && node.container)
                            ej.datavisualization.Diagram.Util._updateGroupBounds(node, diagram);
                    }
                } else {
                    ej.datavisualization.Diagram.Util._translateLine(node, dx, dy, node);
                }
            }
        },

        scale: function (node, sw, sh, pivot, nameTable, skipScalOnChild, updateMinMax, isHelper, diagram) {
            if (!node.container) {
                var matrix = ej.Matrix.identity();
                if (!node.segments) {
                    if (node.type == "group") {
                        var nodes = diagram._getChildren(node.children);
                        var child;
                        for (var i = 0; i < nodes.length; i++) {
                            child = nameTable[nodes[i]];
                            if (child) {
                                this.scale(child, sw, sh, pivot, nameTable);
                                if (child.parent && (child.parent != node.name && node.type != "pseudoGroup"))
                                    ej.datavisualization.Diagram.Util._updateGroupBounds(nameTable[child.parent], diagram);
                            }
                        }
                        ej.datavisualization.Diagram.Util._updateGroupBounds(node, diagram);
                    } else {
                        ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                        ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                        ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                        var newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY));
                        var width = node.width * sw;
                        var height = node.height * sh;
                        if (width > 1) {
                            node.width = width;
                            node.offsetX = newPosition.x;
                        }
                        if (height > 1) {
                            node.height = height;
                            node.offsetY = newPosition.y;
                        }
                    }
                } else {
                    ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                    for (var i = 0; i < node.segments.length; i++) {
                        var segment = node.segments[i];
                        for (var j = 0; j < segment.points.length; j++) {
                            segment.points[j] = ej.Matrix.transform(matrix, segment.points[j]);
                            if (i == 0 && j == 0 && !node.sourceNode) {
                                segment._startPoint = segment.points[0];
                                segment._endPoint = segment.points[segment.points.length - 1];
                                ej.datavisualization.Diagram.Util._setLineEndPoint(node, ej.Matrix.transform(matrix, node.sourcePoint), false);
                            }
                            if (i == node.segments.length - 1 && j == segment.points.length - 1 && !node.targetNode) {
                                segment._startPoint = segment.points[0];
                                segment._endPoint = segment.points[segment.points.length - 1];
                                node.targetPoint = segment._endPoint;
                            }
                        }
                        segment._startPoint = segment.points[0];
                        segment._endPoint = segment.points[segment.points.length - 1];
                        if (segment.type == "orthogonal") {
                            if (segment.length || segment.length === 0)
                                segment.length = segment._length = ej.datavisualization.Diagram.Geometry.distance(segment._startPoint, segment._endPoint);
                            else
                                ej.datavisualization.Diagram.Util._addOrthogonalPoints(segment, node.segments[i - 1], node.segments[i + 1], node.sourcePoint, node.targetPoint);
                        } else {
                            segment.point = segment._endPoint;
                        }
                    }
                }
            }
            else {
                switch (node.container.type) {
                    case "canvas":
                        var newSize = {};
                        var matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                        ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                        ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                        newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY));
                        width = node.width * sw;
                        height = node.height * sh;
                        if (updateMinMax) {
                            node.minHeight = height;
                            node.minWidth = width;
                        }
                        if (isHelper != true)
                            newSize = this._getMinMaxSize(node, width, height);
                        else {
                            newSize.width = width;
                            newSize.height = height;
                        }
                        if (newSize && newSize.width > 1) {
                            var x = node.offsetX - node.width / 2;
                            node.width = newSize.width;
                            node.offsetX = x + node.width / 2;
                        }
                        if (newSize && newSize.height > 1) {
                            var y = node.offsetY - node.height / 2;
                            node.height = newSize.height;
                            node.offsetY = y + node.height / 2;
                        }
                        if (!skipScalOnChild)
                            ej.datavisualization.Diagram.SvgContext._alignOnCanvas1(node, this, true);
                        break;
                    case "stack":
                        var matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                        ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                        ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                        newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY));
                        width = (node.width * sw) - (node.marginLeft + node.marginRight);
                        height = (node.height * sh) - (node.marginTop + node.marginBottom);
                        newSize = this._getMinMaxSize(node, width, height);
                        if (newSize.width > 1) {
                            x = node.offsetX - node.width / 2;
                            node.width = newSize.width - node.marginLeft;
                            node.offsetX = x + node.width / 2 + (node.marginLeft);
                        }
                        if (newSize.height > 1) {
                            y = node.offsetY - node.height / 2;
                            node.height = newSize.height - node.marginTop;
                            node.offsetY = y + node.height / 2 + (node.marginTop);
                        }
                        ej.datavisualization.Diagram.SvgContext._alignOnStack(node, this);
                        break;
                }
            }
        },
        _updateChildBounds: function (node, diagram) {
            var offX, offY, dx, dy;
            dx = node.width;
            dy = node.height;
            offX = node.offsetX;
            offY = node.offsetY;
            var childBounds = ej.datavisualization.Diagram.Util._getChildrenBounds(node, diagram);
            node.offsetX = childBounds.x + childBounds.width / 2;
            node.offsetY = childBounds.y + childBounds.height / 2;
            node.height = childBounds.height;
            node.width = childBounds.width;
            var deltaWidth = dx / node.width;
            var deltaHeight = dy / node.height;
            this.scale(node, deltaWidth, deltaHeight, node.pivot, diagram.nameTable, null, null, null, diagram);
            this._translate(node, offX - node.offsetX, offY - node.offsetY, diagram.nameTable, null, diagram);
        },

        _updateGroupBounds: function (node, diagram, needUpdate) {
            var exWidth, exHeight, exOffX, exOffY;
            if (node && !node.container) {
                if (node && (node.type == "group" || node.type == "pseudoGroup") && node.children.length > 0) {
                    exWidth = node.width;
                    exHeight = node.height;
                    exOffX = node.offsetX;
                    exOffY = node.offsetY;
                    this._updateRotateAngle(node, diagram.nameTable);
                    var bounds = this._getChildrenBounds(node, diagram, needUpdate);
                    var x = bounds.x + bounds.width * node.pivot.x;
                    var y = bounds.y + bounds.height * node.pivot.y;
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, node.rotateAngle);
                    var newposition = ej.Matrix.transform(matrix, { x: x, y: y });
                    if (bounds) {
                        node.offsetX = newposition.x;
                        node.offsetY = newposition.y;
                        node.width = bounds.width;
                        node.height = bounds.height;
                    }
                    if (needUpdate) {
                        var child = null;
                        if (node.children && node.children.length > 0) {
                            for (var k = 0; k < node.children.length; k++) {
                                if (diagram._getChild(node.children[k]))
                                    child = diagram.nameTable[diagram._getChild(node.children[k])];
                                if (child) {
                                    if (child.type == "group" || (child.children && child.children.length > 0)) {
                                        this._updateGroupBounds(child, diagram, needUpdate);
                                    }
                                }
                            }
                        }

                        //update the initial size of the group
                        if (exWidth && exWidth != node.width)
                            diagram.scale(node, exWidth / node.width, 1, new ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY), diagram.nameTable);
                        if (exHeight && exHeight != node.height)
                            diagram.scale(node, 1, exHeight / node.height, new ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY), diagram.nameTable);
                        //update the initial offset of the group
                        if (exOffX && exOffX != node.offsetX)
                            diagram._translate(node, exOffX - node.offsetX, 1, diagram.nameTable)
                        if (exOffX && exOffY != node.offsetY)
                            diagram._translate(node, 1, exOffY - node.offsetY, diagram.nameTable)

                    }
                }
            }
        },
        _getChildrenBounds: function (group, diagram, needUpdate) {
            var children = diagram._getChildren(group.children), rect, bounds = ej.datavisualization.Diagram.Rectangle(), child;
            if (children.length > 0) {
                child = diagram.nameTable[children[0]];
                if (child)
                    bounds = this._rotateChildBounds(child, group);
            }
            for (var i = 0, len = children.length; i < len; i++) {
                child = diagram.nameTable[children[i]];
                if (child) {
                    if (child.type == "group") {
                        this._updateGroupBounds(child, diagram, needUpdate);
                        rect = this._rotateChildBounds(child, group);
                    } else
                        rect = this._rotateChildBounds(child, group);
                }
                if (rect)
                    bounds = ej.datavisualization.Diagram.Geometry.union(bounds, rect);
            }
            return bounds;
        },

        _updateRotateAngle: function (node, nameTable) {
            if (node.offsetX == 0 && node.offsetY == 0 && node.width == 0 && node.height == 0) {
                for (var i = 0; i < node.children.length; i++) {
                    var child = nameTable[node.children[i]];
                    if (child && !child.segments && !node.rotateAngle) {
                        node.rotateAngle = child.rotateAngle;
                        return;
                    }
                }
            }
        },

        _rotateChildBounds: function (child, group) {
            var matrix = ej.Matrix.identity();
            ej.Matrix.rotate(matrix, -group.rotateAngle);
            var bounds = this.bounds(child);
            var topleft = ej.Matrix.transform(matrix, bounds.topLeft);
            var topright = ej.Matrix.transform(matrix, bounds.topRight);
            var bottomLeft = ej.Matrix.transform(matrix, bounds.bottomLeft);
            var bottomRight = ej.Matrix.transform(matrix, bounds.bottomRight);
            var x = Math.min(topleft.x, topright.x, bottomLeft.x, bottomRight.x);
            var y = Math.min(topleft.y, topright.y, bottomLeft.y, bottomRight.y);
            return {
                x: x,
                width: Math.max(topleft.x, topright.x, bottomLeft.x, bottomRight.x) - x,
                y: y,
                height: Math.max(topleft.y, topright.y, bottomLeft.y, bottomRight.y) - y
            };
        },

        updateBridging: function (connector, diagram) {
            var points1 = this.getPoints(connector);
            var bridgeSpacing = connector.bridgeSpace;
            var lstBridge = [];
            var count = -1;
            if (connector.segments.length > 0) {
                for (var m = 0; m < connector.segments.length; m++) {
                    connector.segments[m]._bridges = [];
                }
            }
            if (ej.datavisualization.Diagram.Util.canBridge(connector, diagram)) {
                var childBounds = ej.datavisualization.Diagram.Util.bounds(connector);
                var quads = ej.datavisualization.Diagram.SpatialUtil.findQuads(diagram._spatialSearch, childBounds);
                for (var item = 0; item < quads.length; item++) {
                    var quad = quads[item];
                    if (quad.objects.length > 0) {
                        for (var q = 0; q < quad.objects.length; q++) {
                            var connector1 = quad.objects[q];
                            if (connector1.segments) {
                                var bounds = ej.datavisualization.Diagram.Util.bounds(connector);
                                var bounds1 = ej.datavisualization.Diagram.Util.bounds(connector1);
                                if (ej.datavisualization.Diagram.Geometry.intersectsRect(bounds, bounds1)) {
                                    var points2 = this.getPoints(connector1);
                                    var intersectPts = this.interSect(points1, points2, false, diagram, connector.zOrder > connector1.zOrder ? true : false);
                                    /* Start For Loop */
                                    if (intersectPts.length > 0) {
                                        for (var i = 0; i < intersectPts.length; i++) {
                                            var fullLength = 0;
                                            var segmentIndex = 0;
                                            var length = 0;
                                            var pointIndex = 0;
                                            var obj = this.getLengthAtFractionPoint(connector, intersectPts[i]);
                                            length = obj.lengthAtFractionPt, fullLength = obj.fullLength, segmentIndex = obj.segmentIndex, pointIndex = obj.pointIndex;
                                            if (segmentIndex < 0) {
                                                continue;
                                            }
                                            if (connector.segments[0]) {
                                                var startBridge, endBridge;
                                                var fractLength = (length - (bridgeSpacing / 2)) / fullLength;
                                                startBridge = this.getPointAtLength((length - (bridgeSpacing / 2)), points1);
                                                fractLength = (length + (bridgeSpacing / 2)) / fullLength;
                                                endBridge = this.getPointAtLength((length + (bridgeSpacing / 2)), points1);
                                                if (ej.datavisualization.Diagram.Geometry.isEmptyPoint(endBridge))
                                                    endBridge = startBridge;
                                                var start, end;
                                                if (segmentIndex === 0) {
                                                    start = connector.sourcePoint;
                                                }
                                                else {
                                                    start = connector.segments[segmentIndex - 1]._endPoint;
                                                }
                                                if (connector.segments[segmentIndex].type === "straight")
                                                    end = connector.segments[segmentIndex]._point;
                                                else
                                                    end = connector.segments[segmentIndex].points[pointIndex];
                                                var angle = this._findAngle(start, end);
                                                if (lstBridge.length > segmentIndex && lstBridge[segmentIndex] != null) {
                                                    var fixedPoint;
                                                    if (segmentIndex === 0) {
                                                        fixedPoint = connector.sourcePoint;
                                                    }
                                                    else {
                                                        fixedPoint = connector.segments[segmentIndex - 1]._endPoint;
                                                    }
                                                    var fix = Math.abs(this.findLength(fixedPoint, endBridge));
                                                    var var1 = 0;
                                                    var insertAt = -1;
                                                    count = -1;
                                                    for (var k = 0; k < lstBridge[segmentIndex].bridges.length; k++) {
                                                        count++;
                                                        var arcSeg = lstBridge[segmentIndex].bridges[k];
                                                        var1 = Math.abs(this.findLength(fixedPoint, arcSeg.endPoint));
                                                        if (fix < var1) {
                                                            insertAt = count;
                                                            break;
                                                        }
                                                    }
                                                    if (insertAt >= 0) {
                                                        var paths;
                                                        paths = this.createSegment(startBridge, endBridge, angle, pointIndex, connector, diagram);
                                                        lstBridge[segmentIndex].bridges.splice(insertAt, 0, paths);
                                                        lstBridge[segmentIndex].bridges.join();
                                                        lstBridge[segmentIndex].bridgeStartPoint.splice(insertAt, 0, startBridge);
                                                        lstBridge[segmentIndex].bridgeStartPoint.join();
                                                        lstBridge[segmentIndex].segmentIndex = segmentIndex;
                                                    }
                                                    else {
                                                        var paths = this.createSegment(startBridge, endBridge, angle, pointIndex, connector, diagram);
                                                        lstBridge[segmentIndex].bridges.push(paths);
                                                        lstBridge[segmentIndex].bridgeStartPoint.push(startBridge);
                                                        lstBridge[segmentIndex].segmentIndex = segmentIndex;
                                                    }
                                                }
                                                else {
                                                    if (!isNaN(startBridge.x) && !isNaN(startBridge.y) && !ej.datavisualization.Diagram.Geometry.isEmptyPoint(endBridge)) {
                                                        var arcs = this.createSegment(startBridge, endBridge, angle, pointIndex, connector, diagram);
                                                        var stPoints = [];
                                                        var edPoints = [];
                                                        stPoints.push(startBridge);
                                                        edPoints.push(endBridge);
                                                        if (lstBridge.length < segmentIndex + 1) {

                                                        }
                                                        lstBridge[segmentIndex] = $.extend(true, {}, ej.datavisualization.Diagram.BridgeSegments, {});
                                                        lstBridge[segmentIndex].bridges.push(arcs);
                                                        lstBridge[segmentIndex].bridgeStartPoint = stPoints;
                                                        lstBridge[segmentIndex].segmentIndex = segmentIndex;

                                                    }
                                                }
                                            }
                                        }
                                    }
                                    /* End For Loop */
                                }

                            }
                        }
                    }
                }

                if (lstBridge.length != 0) {
                    for (var i = 0; i < lstBridge.length; i++) {
                        var bridge = lstBridge[i];
                        if (!bridge)
                            continue;
                        for (var k = 1; k < bridge.bridges.length; k++) {
                            if (this.findLength(bridge.bridges[k].endPoint,
                                bridge.bridges[k - 1].endPoint) < bridgeSpacing) {
                                bridge.bridges[k - 1].endPoint = bridge.bridges[k].endPoint;
                                var subBridge = bridge.bridges[k - 1];
                                var arc = diagram.getBridgeSegment(subBridge.startPoint, subBridge.endPoint, subBridge.angle, bridgeSpacing, subBridge.sweep);
                                bridge.bridges[k - 1].path = arc;
                                bridge.bridges.splice(k, 1);
                                bridge.bridgeStartPoint.splice(k, 1);
                                k--;
                            }
                        }

                        var pre = connector.sourcePoint;
                        for (var j = 0; j < bridge.bridges.length; j++) {
                            var subBridge = bridge.bridges[j];
                            var end;
                            if (connector.segments[bridge.segmentIndex].type === "straight")
                                end = connector.segments[bridge.segmentIndex]._endPoint;
                            else if (connector.segments[bridge.segmentIndex].type === "orthogonal")
                                end = connector.segments[bridge.segmentIndex].points[subBridge.segmentPointIndex];
                            if (segmentIndex != 0)
                                pre = connector.segments[bridge.segmentIndex]._endPoint;
                            var rectPoints = [];
                            rectPoints.push(ej.datavisualization.Diagram.Point(end.x - bridgeSpacing, end.y - bridgeSpacing));
                            rectPoints.push(ej.datavisualization.Diagram.Point(end.x + bridgeSpacing, end.y + bridgeSpacing));
                            var rect = ej.datavisualization.Diagram.Geometry.rect(rectPoints);
                            rectPoints = [];
                            rectPoints.push(ej.datavisualization.Diagram.Point(pre.x - bridgeSpacing, pre.y - bridgeSpacing));
                            rectPoints.push(ej.datavisualization.Diagram.Point(pre.x + bridgeSpacing, pre.y + bridgeSpacing));
                            var rect1 = ej.datavisualization.Diagram.Geometry.rect(rectPoints);
                            if (!ej.datavisualization.Diagram.Geometry.containsPoint(rect, bridge.bridgeStartPoint[j]) &&
                                !ej.datavisualization.Diagram.Geometry.containsPoint(rect1, subBridge.endPoint)) {
                                connector.segments[bridge.segmentIndex]._bridges.push(subBridge);
                                pre = subBridge.endPoint;
                            }
                        }

                    }
                }
            }
        },

        createSegment: function (start, end, angle, segmentPointIndex, connector, diagram) {
            var pathSegment = $.extend(true, {}, ej.datavisualization.Diagram.PathSegment, {});
            var arc, sweep;
            sweep = this.sweepDirection(angle, connector, diagram);
            arc = diagram.getBridgeSegment(start, end, angle, connector.bridgeSpace, sweep);
            pathSegment.path = arc;
            pathSegment.startPoint = start;
            pathSegment.endPoint = end;
            pathSegment.angle = angle;
            pathSegment.segmentPointIndex = segmentPointIndex;
            pathSegment.sweep = sweep;
            return pathSegment;
        },

        sweepDirection: function (angle, connector, diagram) {
            var angle1 = Math.abs(angle);
            if (diagram.bridgeDirection() === "top" || diagram.bridgeDirection() === "bottom") {
                var sweep = 1;
                if (angle1 >= 0 && angle1 <= 90) {
                    sweep = 0;
                }
            }
            else if (diagram.bridgeDirection() === "right" || diagram.bridgeDirection() === "left") {
                var sweep = 1;
                if (angle < 0 && angle >= -180) {
                    sweep = 0;
                }
            }
            if (diagram.bridgeDirection() === "right" || diagram.bridgeDirection() === "bottom") {
                if (sweep === 0)
                    sweep = 1;
                else
                    sweep = 0;
            }
            return sweep;
        },

        getPointAtLength: function (length, pts) {
            var run = 0;
            var pre = null;
            var found = ej.datavisualization.Diagram.Point(0, 0);
            for (var i = 0; i < pts.length; i++) {
                var pt = pts[i];
                if (!pre) {
                    pre = pt;
                    continue;
                }
                else {
                    var l = this.findLength(pre, pt);
                    if (run + l > length) {
                        var r = length - run;
                        var deg = this.findAngle(pre, pt);
                        var x = r * Math.cos(deg * Math.PI / 180);
                        var y = r * Math.sin(deg * Math.PI / 180);
                        found = ej.datavisualization.Diagram.Point(pre.x + x, pre.y + y);
                        break;
                    }
                    else {
                        run += l;
                    }
                }
                pre = pt;
            }
            return found;
        },

        getLengthAtFractionPoint: function (connector, pointAt) {
            var confirm = 100, fullLength = 0, segmentIndex = -1, count = 0, lengthAtFractionPt = 0, pointIndex = -1;
            if (connector.segments === null)
                return 0;
            var segments = connector.segments;
            var pt1 = connector.sourcePoint;
            var previouspt2 = pt1;
            for (var i = 0; i < connector.segments.length; i++) {
                var points = [];
                var segment1 = connector.segments[i];
                for (var j = 0; j < segment1.points.length; j++) {
                    var point2 = segment1.points[j];
                    points.push(point2);
                }

                for (var j = 0; j < points.length; j++) {
                    var pt2 = points[j];
                    var suspect = this.getSlope(pt2, pt1, pointAt, connector);
                    if (suspect < confirm) {
                        confirm = suspect;
                        lengthAtFractionPt = fullLength + this.findLength(pointAt, previouspt2);
                        segmentIndex = count;
                        pointIndex = j;
                    }
                    fullLength += this.findLength(pt2, pt1);
                    pt1 = pt2;
                    previouspt2 = pt2;
                }
                count++;
            }
            return { "lengthAtFractionPt": lengthAtFractionPt, "fullLength": fullLength, "segmentIndex": segmentIndex, "pointIndex": pointIndex };
        },

        getSlope: function (startPt, endPt, point, connector) {
            var three = 3.0;
            var delX = Math.abs(startPt.x - endPt.x);
            var delY = Math.abs(startPt.y - endPt.y);
            var lhs = ((point.y - startPt.y) / (endPt.y - startPt.y));
            var rhs = ((point.x - startPt.x) / (endPt.x - startPt.x));
            if (!isFinite(lhs) || !isFinite(rhs) || isNaN(lhs) || isNaN(rhs)) {
                if (startPt.x === endPt.x) {
                    if (startPt.y === endPt.y) {
                        return 10000;
                    }
                    else if (((startPt.y > point.y) && (point.y > endPt.y)) || ((startPt.y < point.y) && (point.y < endPt.y))) {
                        return Math.abs(startPt.x - point.x);
                    }
                    else {
                        return 10000;
                    }
                }
                else if (startPt.y == endPt.y) {
                    if (((startPt.x > point.x) && (point.x > endPt.x)) || ((startPt.x < point.x) && (point.x < endPt.x))) {
                        return Math.abs(startPt.y - point.y);
                    }
                    else {
                        return 10000;
                    }
                }
                else {
                    return 10000;
                }
            }
            else if (connector.segments.length > 0) {
                if ((startPt.x >= point.x && point.x >= endPt.x) || (startPt.x <= point.x && point.x <= endPt.x) || delX < three) {
                    if ((startPt.y >= point.y && point.y >= endPt.y) || (startPt.y <= point.y && point.y <= endPt.y) || delY < three) {
                        return Math.abs(lhs - rhs);
                    }
                    else {
                        return 10000;
                    }
                }
                else {
                    return 10000;
                }
            }
            else {
                return 10000;
            }
        },

        getPoints: function (connector) {
            var points = [];
            // points.push(connector.sourcePoint);
            if (connector.segments.length > 0) {
                for (var i = 0; i < connector.segments.length; i++) {
                    var segment = connector.segments[i];
                    if (segment.type === "straight" || segment.type === "bezier") {
                        if (i === 0)
                            points.push(connector.sourcePoint);
                        points.push(segment._point);
                    }
                    else if (segment.type === "orthogonal") {
                        for (var j = 0; j < connector.segments[i].points.length; j++) {
                            points.push(connector.segments[i].points[j]);
                        }
                    }
                }
            }
            return points;
        },

        interSect: function (points1, points2, self, diagram, zOrder) {
            if (self && points2.length >= 2) {
                points2.splice(0, 1);
                points2.splice(0, 1);
            }
            var points = [];
            for (var i = 0; i < points1.length - 1; i++) {
                var pt = this.interSect1(points1[i], points1[i + 1], points2, diagram, zOrder);
                if (pt.length > 0) {
                    for (var k = 0; k < pt.length; k++) {
                        points.push(pt[k]);
                    }
                }
                if (self && points2.length >= 1) {
                    points2.splice(0, 1);
                }
            }
            return points;
        },

        checkforHorizontalLine: function (angle) {
            var temp = 0;
            var ang = Math.abs(angle);
            if (ang > 90) {
                temp = 180 - ang;
            }
            else {
                temp = ang;
            }
            return temp;
        },

        interSect1: function (startPoint, endPoint, points, diagram, zOrder) {
            var points1 = [];
            for (var i = 0; i < points.length - 1; i++) {
                var point = this.interSect2(startPoint, endPoint, points[i], points[i + 1]);
                if (!ej.datavisualization.Diagram.Geometry.isEmptyPoint(point)) {
                    var angle = this._findAngle(startPoint, endPoint);
                    var angle1 = this._findAngle(points[i], points[i + 1]);
                    angle = this.checkforHorizontalLine(angle);
                    angle1 = this.checkforHorizontalLine(angle1);
                    if (diagram.bridgeDirection() === "left" || diagram.bridgeDirection() === "right") {
                        if (angle > angle1) {
                            points1.push(point);
                        }
                    }
                    else if (diagram.bridgeDirection() === "top" || diagram.bridgeDirection() === "bottom") {
                        if (angle < angle1) {
                            points1.push(point);
                        }
                    }
                    if (angle === angle1 && zOrder) {
                        points1.push(point);
                    }
                }
            }
            return points1;
        },

        interSect2: function (start1, end1, start2, end2) {
            var lineUtil1 = ej.datavisualization.Diagram.LineUtil(start1.x, start1.y, end1.x, end1.y);
            var lineUtil2 = ej.datavisualization.Diagram.LineUtil(start2.x, start2.y, end2.x, end2.y);
            var line3 = this.interSect3(lineUtil1, lineUtil2);
            if (line3.enabled) {
                return line3.intersectPt;
            }
            else {
                return ej.datavisualization.Diagram.Point(0, 0);
            }
        },

        interSect3: function (lineUtil1, lineUtil2) {
            var point = ej.datavisualization.Diagram.Point(0, 0);
            var l1 = lineUtil1;
            var l2 = lineUtil2;
            var d = (l2.y2 - l2.y1) * (l1.x2 - l1.x1) - (l2.x2 - l2.x1) * (l1.y2 - l1.y1);
            var n_a = (l2.x2 - l2.x1) * (l1.y1 - l2.y1) - (l2.y2 - l2.y1) * (l1.x1 - l2.x1);
            var n_b = (l1.x2 - l1.x1) * (l1.y1 - l2.y1) - (l1.y2 - l1.y1) * (l1.x1 - l2.x1);

            if (d == 0)
                return { enabled: false, intersectPt: point };

            var ua = n_a / d;
            var ub = n_b / d;

            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                point.x = l1.x1 + (ua * (l1.x2 - l1.x1));
                point.y = l1.y1 + (ua * (l1.y2 - l1.y1));
                return { enabled: true, intersectPt: point };
            }
            return { enabled: false, intersectPt: point };
        },

        findLength: function (startPt, endPt) {
            try {
                var length = Math.sqrt(Math.pow((startPt.x - endPt.x), 2) + Math.pow((startPt.y - endPt.y), 2));
                return length;
            }
            catch (e) {
                throw e;
            }
        },

        _findAngle: function (startPt, endPt) {
            var xDiff = startPt.x - endPt.x; var yDiff = startPt.y - endPt.y;
            return Math.atan2(yDiff, xDiff) * (180 / Math.PI);
        },

        findAngle: function (startPt, endPt) {
            if (ej.datavisualization.Diagram.Geometry.isEqualPoint(startPt, endPt))
                return 0;
            var r = ej.datavisualization.Diagram.Point(endPt.x, startPt.y);
            var sr = this.findLength(startPt, r);
            var re = this.findLength(r, endPt);
            var es = this.findLength(endPt, startPt);
            var ang = Math.asin(re / es);
            ang = ang * 180 / Math.PI;
            if (startPt.x < endPt.x) {
                if (startPt.y < endPt.y) {

                }
                else {
                    ang = 360 - ang;
                }
            }
            else {
                if (startPt.y < endPt.y) {
                    ang = 180 - ang;
                }
                else {
                    ang = 180 + ang;
                }
            }
            return ang;
        }
    };

    ej.datavisualization.Diagram.BridgeSegments = {
        bridges: [],
        bridgeStartPoint: [],
        segmentIndex: -1
    };

    ej.datavisualization.Diagram.PathSegment = {
        path: "",
        startPoint: { "x": 0, "y": 0 },
        endPoint: { "x": 0, "y": 0 },
        angle: 0,
        segmentPointIndex: -1,
        sweep: 1
    };

    ej.datavisualization.Diagram.LineUtil = function (x1, y1, x2, y2) {
        return { "x1": Number(x1) || 0, "y1": Number(y1) || 0, "x2": Number(x2) || 0, "y2": Number(y2) || 0 };
    };
    //#endregion

    //#region Geometry
    ej.datavisualization.Diagram.Geometry = {
        checkPointOnCircle: function (point, center, radius) {
            var r2 = Math.pow(radius, 2);
            var x2 = Math.pow((point.x - center.x), 2);
            var y2 = Math.pow((point.y - center.y), 2);
            if ((x2 + y2) <= r2) {
                return true;
            }
            return false;
        },
        rect: function (points) {
            var rectangle = ej.datavisualization.Diagram.Rectangle();
            if (arguments.length === 1) {
                var left = Number.MAX_VALUE;
                var top = Number.MAX_VALUE;
                var right = -Number.MAX_VALUE;
                var bottom = -Number.MAX_VALUE;
                var len = points.length;
                var x, y;
                for (var i = 0; i < len; i++) {
                    x = points[i].x;
                    y = points[i].y;
                    if (x < left) {
                        left = x;
                    }
                    if (x > right) {
                        right = x;
                    }
                    if (y < top) {
                        top = y;
                    }
                    if (y > bottom) {
                        bottom = y;
                    }
                }
                rectangle = ej.datavisualization.Diagram.Rectangle(left, top, right - left, bottom - top);
            }
            else if (arguments.length === 2) {
                var ptStart = ej.datavisualization.Diagram.Point(arguments[0]);
                var ptEnd = ej.datavisualization.Diagram.Point(arguments[1]);
                var swap;
                if (ptStart.x > ptEnd.x) {
                    swap = ptStart.x;
                    ptStart.x = ptEnd.x;
                    ptEnd.x = swap;
                }
                if (ptStart.y > ptEnd.y) {
                    swap = ptStart.y;
                    ptStart.y = ptEnd.y;
                    ptEnd.y = swap;
                }
                rectangle = ej.datavisualization.Diagram.Rectangle(ptStart.x, ptStart.y, ptEnd.x - ptStart.x, ptEnd.y - ptStart.y);
            }
            return rectangle;
        },
        union: function (rect1, rect2) {
            var x = Math.min(rect1.x, rect2.x);
            var y = Math.min(rect1.y, rect2.y);
            var width = Math.max(rect1.x + rect1.width, rect2.x + rect2.width);
            var height = Math.max(rect1.y + rect1.height, rect2.y + rect2.height);
            return ej.datavisualization.Diagram.Rectangle(x, y, width - x, height - y);
        },
        distance: function (pt1, pt2) {
            return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
        },
        translate: function (pt1, dx, dy) {
            return ej.datavisualization.Diagram.Point(pt1.x + dx, pt1.y + dy);
        },
        intersectsRect: function (rect1, rect2) {
            return ((((rect2.x < (rect1.x + rect1.width)) && (rect1.x < (rect2.x + rect2.width)))
                && (rect2.y < (rect1.y + rect1.height))) && (rect1.y < (rect2.y + rect2.height)));
        },
        findAngle: function (point1, point2) {
            var angle = Math.atan2(point2.y - point1.y, point2.x - point1.x);
            angle = (180 * angle / Math.PI);
            angle %= 360;
            if (angle < 0) {
                angle += 360;
            }
            return angle;
        },
        intersectSegment: function (segment1, segment2) {
            var x1 = segment1.point1.x;
            var y1 = segment1.point1.y;
            var x2 = segment1.point2.x;
            var y2 = segment1.point2.y;
            var x3 = segment2.point1.x;
            var y3 = segment2.point1.y;
            var x4 = segment2.point2.x;
            var y4 = segment2.point2.y;
            var a1, a2, b1, b2, c1, c2, x, y;
            var r1, r2, r3, r4;
            var denom, offset, num;
            a1 = y2 - y1;
            b1 = x1 - x2;
            c1 = (x2 * y1) - (x1 * y2);
            r3 = ((a1 * x3) + (b1 * y3) + c1);
            r4 = ((a1 * x4) + (b1 * y4) + c1);
            if ((r3 !== 0) && (r4 !== 0) && this.sameSign(r3, r4)) {
                return null;
            }
            a2 = y4 - y3;
            b2 = x3 - x4;
            c2 = (x4 * y3) - (x3 * y4);
            r1 = (a2 * x1) + (b2 * y1) + c2;
            r2 = (a2 * x2) + (b2 * y2) + c2;
            if ((r1 !== 0) && (r2 !== 0) && (this.sameSign(r1, r2))) {
                return null;
            }
            denom = (a1 * b2) - (a2 * b1);

            if (denom === 0) {
                return null;
            }

            if (denom < 0) {
                offset = -denom / 2;
            }
            else {
                offset = denom / 2;
            }
            offset = 0;
            num = (b1 * c2) - (b2 * c1);
            if (num < 0) {
                x = (num - offset) / denom;
            }
            else {
                x = (num + offset) / denom;
            }

            num = (a2 * c1) - (a1 * c2);
            if (num < 0) {
                y = (num - offset) / denom;
            }
            else {
                y = (num + offset) / denom;
            }
            return ej.datavisualization.Diagram.Point(x, y);
        },

        updatePath: function (x, y, width, height, pathData, svg, bounds) {
            var bBox, isInit;
            if (svg && svg.pathBounds) {
                isInit = true;
                bBox = svg.pathBounds(pathData);
            }
            else {
                isInit = false;
                bBox = bounds;
            }

            var newX = 0, newY = 0;
            var isResize = false;
            if (x.toString() !== bBox.x || y.toString() !== bBox.y) {
                newX = x - Number(bBox.x);
                newY = y - Number(bBox.y);
            }
            if (width !== bBox.width || height !== bBox.height) {
                newX = width / Number(bBox.width);
                newY = height / Number(bBox.height);
                isResize = true;
            }
            return ej.datavisualization.Diagram.Geometry.processPathData(pathData, newX, newY, isResize, bBox.x, bBox.y, x, y, isInit, svg);
        },

        processPathData: function (path, newX, newY, isResizing, oldX, oldY, offsetX, offsetY, isInit, svg) {
            var shape = document.createElementNS('http://www.w3.org/2000/svg', "path");
            shape.setAttribute("d", path);
            if (isInit && svg) {
                path = svg.absolutePath(shape).getAttribute('d');
                shape.setAttribute("d", path);
            }
            var x0, y0, x1, y1, x2, y2, segs = shape.pathSegList;
            for (var x = 0, y = 0, i = 0, length = segs.numberOfItems; i < length; ++i) {
                var seg = segs.getItem(i), char = seg.pathSegTypeAsLetter;

                if ('x1' in seg) x1 = seg.x1;
                if ('x2' in seg) x2 = seg.x2;
                if ('y1' in seg) y1 = seg.y1;
                if ('y2' in seg) y2 = seg.y2;
                if ('x' in seg) x = seg.x;
                if ('y' in seg) y = seg.y;


                if (isResizing) {
                    if (x != undefined) {
                        x = ej.datavisualization.Diagram.Geometry.scalePathData(x, newX, oldX, offsetX);
                    }
                    if (y != undefined) {
                        y = ej.datavisualization.Diagram.Geometry.scalePathData(y, newY, oldY, offsetY);
                    }
                    if (x1 != undefined) {
                        x1 = ej.datavisualization.Diagram.Geometry.scalePathData(x1, newX, oldX, offsetX);
                    }
                    if (y1 != undefined) {
                        y1 = ej.datavisualization.Diagram.Geometry.scalePathData(y1, newY, oldY, offsetY);
                    }
                    if (x2 != undefined) {
                        x2 = ej.datavisualization.Diagram.Geometry.scalePathData(x2, newX, oldX, offsetX);
                    }
                    if (y2 != undefined) {
                        y2 = ej.datavisualization.Diagram.Geometry.scalePathData(y2, newY, oldY, offsetY);
                    }
                }

                else {
                    if (x != undefined) {
                        x = (x + newX);
                    }
                    if (y != undefined) {
                        y = (y + newY);
                    }
                    if (x1 != undefined) {
                        x1 = (x1 + newX);
                    }
                    if (y1 != undefined) {
                        y1 = (y1 + newY);
                    }
                    if (x2 != undefined) {
                        x2 = (x2 + newX);
                    }
                    if (y2 != undefined) {
                        y2 = (y2 + newY);
                    }
                }

                switch (char) {
                    case 'M':
                        segs.replaceItem(shape.createSVGPathSegMovetoAbs(x, y), i);
                        break;
                    case 'L':
                        segs.replaceItem(shape.createSVGPathSegLinetoAbs(x, y), i);
                        break;
                    case 'H':
                        segs.replaceItem(shape.createSVGPathSegLinetoHorizontalAbs(x), i);
                        break;
                    case 'V':
                        segs.replaceItem(shape.createSVGPathSegLinetoVerticalAbs(y), i);
                        break;
                    case 'C':
                        segs.replaceItem(shape.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);
                        break;
                    case 'S':
                        segs.replaceItem(shape.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);
                        break;
                    case 'Q':
                        segs.replaceItem(shape.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);
                        break;
                    case 'T':
                        segs.replaceItem(shape.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);
                        break;
                    case 'A':
                        var r1 = seg.r1, r2 = seg.r2;
                        if (isResizing) {
                            r1 = (r1 * newX);
                            r2 = (r2 * newY);
                        }
                        segs.replaceItem(shape.createSVGPathSegArcAbs(x, y, r1, r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);
                        break;
                    case 'Z':
                        x = x0; y = y0;
                        break;
                }
                // Record the start of a subpath
                if (char === 'M' || char === 'm') x0 = x, y0 = y;
            }
            var pathData = shape.getAttribute("d");
            return pathData;
        },

        scalePathData: function (val, scaleFactor, oldOffset, newOffset) {
            if (val !== oldOffset) {
                if (newOffset !== oldOffset) {
                    val = (((val * scaleFactor) - (Number(oldOffset) * scaleFactor - Number(oldOffset)))
                        + (newOffset - Number(oldOffset)));
                }
                else
                    val = ((Number(val) * scaleFactor) - (Number(oldOffset) * scaleFactor - Number(oldOffset)));
            }
            else {
                if (newOffset !== oldOffset) {
                    val = newOffset;
                }
            }
            return val;
        },

        updatePolygonPoints: function (node, points) {
            if (node.shape.points) {
                if (!points)
                    points = node.shape.points;
                ej.datavisualization.Diagram.Geometry.scalePoints(points, node);
                var bounds = ej.datavisualization.Diagram.Geometry.rect(node.shape.points);
                for (var i = 0, len = node.shape.points.length; i < len; ++i) {
                    var point = ej.datavisualization.Diagram.Geometry.translate(points[i], -bounds.x, -bounds.y);
                    point = ej.datavisualization.Diagram.Geometry.translate(point, 0, 0);
                    points[i] = point;
                }
            }
        },

        scalePoints: function (points, node) {
            var bounds = ej.datavisualization.Diagram.Geometry.rect(node.shape.points);
            if (bounds.width > 0 && bounds.height > 0) {
                var scaleX = node.width / bounds.width;
                var scaleY = node.height / bounds.height;
                for (var i = 0, len = node.shape.points.length; i < len; ++i) {
                    points[i].x = points[i].x * scaleX;
                    points[i].y = points[i].y * scaleY;
                }
            }
        },

        sameSign: function (a, b) {
            return ((a * b) >= 0);
        },
        containsPoint: function (rect, point) {
            return ((((rect.x <= point.x) && (point.x <= (rect.x + rect.width)))
            && (rect.y <= point.y)) && (point.y <= (rect.y + rect.height)));
        },
        containsRect: function (rect, value) {
            return ((((rect.x <= value.x) && ((value.x + value.width) <= (rect.x + rect.width)))
               && (rect.y <= value.y)) && ((value.y + value.height) <= (rect.y + rect.height)));
        },
        inflate: function (rect, x, y) {
            rect.x -= x;
            rect.y -= y;
            rect.width += 2 * x;
            rect.height += 2 * y;
        },
        isEmptyRect: function (rect) {
            return rect.x === 0 && rect.y === 0 && rect.width === 0 && rect.height === 0;
        },
        isEmptyPoint: function (point) {
            return point.x === 0 && point.y === 0;
        },
        isEqualPoint: function (point1, point2) {
            return point1.x === point2.x && point1.y === point2.y;
        },
        isEmptySize: function (size) {
            return size.width === 0 && size.height === 0;
        },
        length: function (segment) {
            return ej.datavisualization.Diagram.Geometry.distance(segment.point1, segment.point2);
        },
        midPoint: function (segment) {
            return ej.datavisualization.Diagram.Point((segment.point1.x + segment.point2.x) / 2, (segment.point1.y + segment.point2.y) / 2);
        },
        transform: function (point, angle, length) {
            var pt = {};
            pt.x = Math.round((point.x + length * Math.cos(angle * Math.PI / 180)) * 100) / 100;
            pt.y = Math.round((point.y + length * Math.sin(angle * Math.PI / 180)) * 100) / 100;
            return pt;
        }
    };
    ej.datavisualization.Diagram.LineSegment = function (point1, point2) {
        return { "point1": point1, "point2": point2 };
    };
    ej.datavisualization.Diagram.Point = function (x, y) {
        return { "x": Number(x) || 0, "y": Number(y) || 0 };
    };
    ej.datavisualization.Diagram.Size = function (width, height) {
        return { "width": Number(width) || 0, "height": Number(height) || 0 };
    };
    ej.datavisualization.Diagram.Rectangle = function (x, y, width, height) {
        return { "x": Number(x) || 0, "y": Number(y) || 0, "width": Number(width) || 0, "height": Number(height) || 0 };
    };
    //#endregion

    //#region Enums
    /**
    * Enum for various decorator shapes in diagram	 
    * @enum {string}
    * @global 
    */
    ej.datavisualization.Diagram.DecoratorShapes = {
        /**Used to set decorator shape as none */
        None: "none",
        /**Used to set decorator shape as Arrow*/
        Arrow: "arrow",
        /**Used to set decorator shape as Open Arrow */
        OpenArrow: "openarrow",
        /**Used to set decorator shape as Circle */
        Circle: "circle",
        /**Used to set decorator shape as Diamond */
        Diamond: "diamond",
        /**Used to set decorator shape as path */
        Path: "path"
    };

    ej.datavisualization.Diagram.dependentconnector = {
        dependent: 1,
        independent: 2
    }
    /**
    * Enum for various containerType in diagram	 
    * @enum {string}
    * @global 
    */
    ej.datavisualization.Diagram.ContainerType = {
        /**Set the container type as Canvas*/
        Canvas: "canvas",
        /**Set the container type as Stack*/
        Stack: "stack",
    };
    /**
    * Enum for various port shapes in diagram	 
    * @enum {string}
    * @global 
    */
    ej.datavisualization.Diagram.PortShapes = {
        /**Used to set port shape as X*/
        X: "x",
        /**Used to set port shape as Circle*/
        Circle: "circle",
        /**Used to set port shape as Square*/
        Square: "square",
        /**Used to set port shape as Path*/
        Path: "path"
    };
    /**
    * Enum for port visibility in diagram	 
    * @enum {PortVisibility}
    * @global 
    */
    ej.datavisualization.Diagram.PortVisibility = {
        /**Set the port visibility as Visible*/
        Visible: 1 << 0,
        /**Set the port visibility as Hidden*/
        Hidden: 1 << 1,
        /**Port get visible when hover connector on node*/
        Hover: 1 << 2,
        /** Port gets visibile when connect connector to node*/
        Connect: 1 << 3,
        /**Specifies the port visibility as default*/
        Default: 1 << 3
    };
    /**
    * Enum for the Text Alignment in diagram	 
    * @enum {string}
    * @global 
    */
    ej.datavisualization.Diagram.TextAlign = {
        /** Used to align text on left side of node/connector*/
        Left: "left",
        /** Used to align text on center of node/connector*/
        Center: "center",
        /** Used to align text on Right side of node/connector*/
        Right: "right"
    };
    /**
    * Enum for Horizontal Alignment of text in diagram	 
    * @enum {string}
    * @global 
    */
    ej.datavisualization.Diagram.HorizontalAlignment = {
        /** Used to align text horizontally on left side of node/connector*/
        Left: "left",
        /** Used to align text horizontally on center of node/connector*/
        Center: "center",
        /** Used to align text horizontally on right side of node/connector*/
        Right: "right"
    };
    /**
    * Enum for LabelEditMode of text in diagram	 
    * @enum {string}
    * @global 
    */
    ej.datavisualization.Diagram.LabelEditMode = {
        /** Used to set label edit mode as edit*/
        Edit: "edit",
        /** Used to set label edit mode as view*/
        View: "view"
    };
    /**
    * Enum for Vertical Alignment of text in diagram	 
    * @enum {string}
    * @global 
    */
    ej.datavisualization.Diagram.VerticalAlignment = {
        /** Used to align text Vertically on left side of node/connector*/
        Top: "top",
        /** Used to align text Vertically on center of node/connector*/
        Center: "center",
        /** Used to align text Vertically on bottom of node/connector*/
        Bottom: "bottom"
    };
    /**
    * Enum for TextDecorations in diagram	 
    * @enum {string}
    * @global 
    */
    ej.datavisualization.Diagram.TextDecorations = {
        /** Used to set text decoration of the label as Underline*/
        Underline: "underline",
        /** Used to set text decoration of the label as Overline*/
        Overline: "overline",
        /** Used to set text decoration of the label as LineThrough*/
        LineThrough: "line-through",
        /** Used to set text decoration of the label as None*/
        None: "none"
    };
    /**
    * Enum for the NodeConstraints in diagram	 
    * @enum {NodeConstraints}
    * @global 
    */
    ej.datavisualization.Diagram.NodeConstraints = {
        /**Disable all node Constraints */
        None: 1 << 0,
        /**Enables node to be selected*/
        Select: 1 << 1,
        /**Enables node to be Deleted*/
        Delete: 1 << 2,
        /**Enables node to be Resized */
        Resize: 1 << 3,
        /**Enables node to be Dragged*/
        Drag: 1 << 4,
        /**Enables node to be Rotated*/
        Rotate: 1 << 5,
        /**Enables node to be connected*/
        Connect: 1 << 6,
        /**Enables node to be resize north east*/
        ResizeNorthEast: 1 << 7,
        /**Enables node to be resize east*/
        ResizeEast: 1 << 8,
        /**Enables node to be resize south east*/
        ResizeSouthEast: 1 << 9,
        /**Enables node to be resize south*/
        ResizeSouth: 1 << 10,
        /**Enables node to be resize south west*/
        ResizeSouthWest: 1 << 11,
        /**Enables node to be resize west*/
        ResizeWest: 1 << 12,
        /**Enables node to be resize north west*/
        ResizeNorthWest: 1 << 13,
        /**Enables node to be resize north */
        ResizeNorth: 1 << 14,
        /**Enables shadow*/
        Shadow: 1 << 15,
        /**Enables label of node to be Dragged*/
        DragLabel: 1 << 16,
        /**Enables panning should be done while node dragging */
        AllowPan: 1 << 17,
        /**Enables Proportional resize for node */
        AspectRatio: 1 << 18,
        /**Enables all node constraints*/
        Default: 1 << 1 | 1 << 2 | 1 << 3 | 1 << 4 | 1 << 5 | 1 << 6 | 1 << 7 | 1 << 8 | 1 << 9 | 1 << 10 | 1 << 11 | 1 << 12 | 1 << 13 | 1 << 14
    };
    /**
    * Enum for ConnectorConstraints in diagram	 
    * @enum {ConnectorConstraints}
    * @global 
    */
    ej.datavisualization.Diagram.ConnectorConstraints = {
        /**Disable all connector Constraints */
        None: 1 << 0,
        /**Enables connector to be selected*/
        Select: 1 << 1,
        /**Enables connector to be Deleted*/
        Delete: 1 << 2,
        /**Enables connector to be Dragged*/
        Drag: 1 << 3,
        /**Enables connectors source end to be selected*/
        DragSourceEnd: 1 << 4,
        /**Enables connectors target end to be selected*/
        DragTargetEnd: 1 << 5,
        /**Enables control point and end point of every segment in a connector for editing*/
        DragSegmentThumb: 1 << 6,
        /** Enables bridging to the connector */
        Bridging: 1 << 7,
        /**Enables label of node to be Dragged*/
        DragLabel: 1 << 8,
        /** Enables bridging to the connector */
        InheritBridging: 1 << 9,
        /**Enables all constraints*/
        Default: 1 << 1 | 1 << 2 | 1 << 3 | 1 << 4 | 1 << 5 | 1 << 6 | 1 << 9
    };

    /**
    * Enum for PortConstraints in diagram	 
    * @enum {PortConstraints}
    * @global 
    */
    ej.datavisualization.Diagram.PortConstraints = {
        /**Disable all constraints*/
        None: 1 << 0,
        /**Enables connections with connector*/
        Connect: 1 << 1
    };
    /**
    * Enum for specify the SelectorConstraints in diagram	 
    * @enum {SelectorConstraints}
    * @global 
    */
    ej.datavisualization.Diagram.SelectorConstraints = {
        /** Disables all constraints*/
        None: 1 << 0,
        /** Enables the rotation handle when select node*/
        Rotator: 1 << 1,
        /**Enables the resize when select node*/
        Resizer: 1 << 2,
        /** Enables the user handles when select node*/
        UserHandles: 1 << 3,
        /** Enables all the constraints*/
        All: 1 << 1 | 1 << 2 | 1 << 3
    };
    /**
    * Enum for Position in diagram	 
    * @enum {String}
    * @global 
    */
    ej.datavisualization.Diagram.UserHandlePositions = {
        /**Used to set position as TopLeft*/
        TopLeft: "topleft",
        /**Used to set position as TopCenter*/
        TopCenter: "topcenter",
        /**Used to set position as TopRight*/
        TopRight: "topright",
        /**Used to set position as MiddleLeft*/
        MiddleLeft: "middleleft",
        /**Used to set position as  MiddleRight*/
        MiddleRight: "middleright",
        /**Used to set position as BottomLeft*/
        BottomLeft: "bottomleft",
        /**Used to set position as BottomCenter*/
        BottomCenter: "bottomcenter",
        /**Used to set position as BottomRight*/
        BottomRight: "bottomright"
    };
    /**
    * Enum for SnapConstraints in diagram	 
    * @enum {SnapConstraints}
    * @global 
    */
    ej.datavisualization.Diagram.SnapConstraints = {
        /**Enables node to be snapped to horizontal gridlines*/
        None: 0,
        /**Enables node to be snapped to vertical gridlines*/
        SnapToHorizontalLines: 1,
        /**Enables node to be snapped to horizontal gridlines*/
        SnapToVerticalLines: 2,
        /**Enables node to be snapped to gridlines*/
        SnapToLines: 1 | 2,
        /**Enable horizontal lines*/
        ShowHorizontalLines: 4,
        /**Enable vertical lines*/
        ShowVerticalLines: 8,
        /**Enable both horizontal and vertical lines*/
        ShowLines: 4 | 8,
        /**Enable all the constraints*/
        All: 1 | 2 | 4 | 8
    };
    /**
    * Enum for PageOrientations in diagram	 
    * @enum {String}
    * @global 
    */
    ej.datavisualization.Diagram.PageOrientations = {
        /** Used to set orientation as Landscape*/
        Landscape: "landscape",
        /** Used to set orientation as portrait*/
        Portrait: "portrait"
    };

    /**
    * Enum for ScrollLimit in diagram	 
    * @enum {String}
    * @global 
    */
    ej.datavisualization.Diagram.ScrollLimit = {
        /** Used to set scrollLimit as Infinity*/
        Infinity: "infinity",
        /** Used to set scrollLimit as Diagram*/
        Diagram: "diagram",
        /** Used to set scrollLimit as Limited*/
        Limited: "limited"
    };

    /**
    * Enum for LayoutOrientations in diagram	
    * @enum {String}
    * @global 
    */
    ej.datavisualization.Diagram.LayoutOrientations = {
        /** Used to set LayoutOrientation from top to bottom */
        TopToBottom: "toptobottom",
        /** Used to set LayoutOrientation from bottom to top */
        BottomToTop: "bottomtotop",
        /** Used to set LayoutOrientation from left to right */
        LeftToRight: "lefttoright",
        /** Used to set LayoutOrientation from right to left */
        RightToLeft: "righttoleft"
    };
    //#endregion

    //#region Palette
    ej.datavisualization.Diagram.PaletteDefaults = {
        /** specifies the name of the palette
     * @default ""
     * @type {String}
     * @example
     * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
     * &lt;script&gt;
      var palette = [{name: "Basic Shapes"}];
     *  $("#symbolpalette").ejSymbolPalette({palettes:palette});
     * &lt;/script&gt
     * @memberof ejSymbolpalette
     * @instance
     */
        name: "",
        /** Enable or disable the expand property of palette
      * @default false
      * @type {Boolean}
      * @example
      * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
       var palette = [{expanded: true}];
      *  $("#symbolpalette").ejSymbolPalette({palettes:palette});
      * &lt;/script&gt
      * @memberof ejSymbolpalette
      * @instance
      */
        expanded: false,
        subControlId: null,
        /** Collection of items in plaette
    * @default []
    * @type {Array}
    * @example
    * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
     var palette = [{ items:[{ name: "Triangle"},{ name: "Ellipse"}]}];
    *  $("#symbolpalette").ejSymbolPalette({palettes:palette});
    * &lt;/script&gt
    * @memberof ejSymbolpalette
    * @instance
    */
        items: []
    };
    ej.datavisualization.Diagram.Palette = function (options, palette) {
        if (options.items)
            for (var i = 0; i < options.items.length; i++) {
                if (options.items[i].isLane) {
                    options.items[i] = ej.datavisualization.Diagram.SwimLaneHelper._createPaletteLane(options.items[i], palette.nameTable);
                }
                else if (options.items[i].segments)
                    options.items[i] = ej.datavisualization.Diagram.Connector(options.items[i]);
                else if (options.items[i].type == "group" || options.items[i].type == "group") {
                    options.items[i] = ej.datavisualization.Diagram.Group(options.items[i]);
                    palette._initGroupNode(options.items[i]);
                }
                else
                    options.items[i] = ej.datavisualization.Diagram.Node(options.items[i]);
            }
        return $.extend(true, {}, ej.datavisualization.Diagram.PaletteDefaults, options);
    };
    //#endregion

    //#region Shapes
    /**
    * Enum for various shapes of node in diagram	 
    * @enum {string}
    * @global 
    */
    ej.datavisualization.Diagram.Shapes = {
        /**Used to specify node Shape as Rectangle*/
        Rectangle: "rectangle",
        /**Used to specify node Shape as Ellipse*/
        Ellipse: "ellipse",
        /**Used to specify node Shape as Image*/
        Image: "image",
        /**Used to specify node Shape as Text*/
        Text: "text",
        /**Used to specify node Shape as Path*/
        Path: "path",
        /**Used to specify node Shape as Polygon*/
        Polygon: "polygon",
        /**Used to specify node Shape as Html*/
        Html: "html",
        /**Used to specify node Shape as Native*/
        Native: "native"
    };


    ej.datavisualization.Diagram.ShapeDefaults = {
        /** The type of node See {@link Shapes}
         
         * @default ej.datavisualization.Diagram.Shapes.Rectangle
         * @type {enum}
         * @example
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         * &lt;script&gt;
         * var node=[];
         * node={[shape:{type:"rectangle"}]};
         * $("#diagramcontent").ejDiagram({nodes:node});
         * &lt;/script&gt
        * @alias ejDiagram#nodes->shape->type
         * @memberof ejDiagram
         * @instance
         */
        type: ej.datavisualization.Diagram.Shapes.Rectangle,
        /** Defines the shape of the corner
         * @default 0
         * @type {Integer}
         * @example
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         * &lt;script&gt;
         * var node=[];
         * node={[shape:{type:"rectangle",cornerRadius:2}]};
         * $("#diagramcontent").ejDiagram({nodes:node});
         * &lt;/script&gt
       * @alias ejDiagram#nodes->shape->cornerRadius
         * @memberof ejDiagram
         * @instance
         */
        cornerRadius: 0,
        /** The src location for the image node
      * @default ""
      * @type {String}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var node=[];
      * node={[shape:{type:"image",src:"Syncfusion.png"}]};
      * $("#diagramcontent").ejDiagram({nodes:node});
      * &lt;/script&gt
     * @alias ejDiagram#nodes->shape->src
      * @memberof ejDiagram
      * @instance
      */
        src: "",
        /** Set the geometry that specifies the shapes to be drawn
       * @default ""
       * @type {String}
       * @example
       * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
       * &lt;script&gt;
       * var node=[];
       * node={[shape:{type:"path",pathData:"M 269.711,29.3333C 269.711,44.061 257.772,56 243.044,56L 158.058,56C 143.33z"}]};
       * $("#diagramcontent").ejDiagram({nodes:node});
       * &lt;/script&gt
     * @alias ejDiagram#nodes->shape->pathData
       * @memberof ejDiagram
       * @instance
       */
        pathData: "",
        /**This is used to display text
      * @default ""
      * @type {Integer}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var node=[];
      * var textBlock = ej.datavisualization.Diagram.TextBlockDefaults;
      * textBlock.text = "TextNode";
      * node={[shape: { type: "text", textBlock: textBlock }]};
      * $("#diagramcontent").ejDiagram({nodes:node});
      * &lt;/script&gt
     * @alias ejDiagram#nodes->shape->textBlock
      * @memberof ejDiagram
      * @instance
      */
        textBlock: null,
        /** Points to define X and Y coordinates for the polygon
       * @default []
       * @type {Array}
       * @example
       * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
       * &lt;script&gt;
       * var node=[];
       * node={[shape: { type: "polygon", points:[{ x: 0, y: 12.5 }, { x: 0, y: 50 }, { x: 50, y: 50 }, { x: 50, y: 0 }, { x: 12.5, y: 0 }, { x: 0, y: 12.5 }]}]};
       * $("#diagramcontent").ejDiagram({nodes:node});
       * &lt;/script&gt
    * @alias ejDiagram#nodes->shape->points
       * @memberof ejDiagram
       * @instance
       */
        points: [],
        /**This is used to set the templateid
    * @default ""
    * @type {string}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var node=[]; 
    * node={[shape: { type: "text", templateId: "templateId" }]};
    * $("#diagramcontent").ejDiagram({nodes:node});
    * &lt;/script&gt
   * @alias ejDiagram#nodes->shape->templateId
    * @memberof ejDiagram
    * @instance
    */
        templateId: null,
    };
    ej.datavisualization.Diagram.Shape = function (options) {
        if (options) {
            if (options.type === "html") {
                if (typeof (options.html) === "string")
                    options.html = ej.datavisualization.Diagram.Util.htmlEncode(options.html);
            }
            if (options.type === "text" && options.textBlock)
                options.textBlock = ej.datavisualization.Diagram.TextBlock(options.textBlock);
        }
        return $.extend(true, {}, ej.datavisualization.Diagram.ShapeDefaults, options);
    };
    //#endregion

    //#region Lines
    /**
    * Enum for various segments of connector in diagram	 
    * @enum {string}
    * @global 
    */
    ej.datavisualization.Diagram.Segments = {
        /** Used to specify the lines as Straight*/
        Straight: "straight",
        /** Used to specify the lines as Orthogonal*/
        Orthogonal: "orthogonal",
        /** Used to specify the lines as Bezier*/
        Bezier: "bezier"
    };


    ej.datavisualization.Diagram.SegmentDefaults = {
        /**Type of the segments See {@link Segments}         
                 * @default ej.datavisualization.Diagram.Segments.Straight
                 * @type {enum}
                 * @example
                 * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
                 * &lt;script&gt;
                 * var link=[];
                 * link=[{segments:[{type:"straight"}]}];
                 * $("#diagramcontent").ejDiagram({connectors:link});
                 * &lt;/script&gt
                 * @alias  ejDiagram#connectors->segments->type
                 * @memberof ejDiagram
                 * @instance
                 */
        type: ej.datavisualization.Diagram.Segments.Straight,

        /** Describes the end point of segment
      * @default Diagram.Point()
      * @type {Point}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var segments = [{ type: "straight",point:{x:10,y:30}}];
      * connectors = [{ name: "connector1", segments: segments, sourcePoint: { x: 450, y: 150 }, targetPoint: { x: 210, y: 40 }}];
      * $("#diagramcontent").ejDiagram({segments:segments});
      * &lt;/script&gt
      * @alias  ejDiagram#connectors->segments->point
      * @memberof ejDiagram
      * @instance
      */
        point: null,
        /** Describes the first control point of bezier segment
       * @default null
       * @type {Point}
       * @example
       * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
       * &lt;script&gt;
       * var connectors = [];
       * var point1={x:10,y:10}];
       * connectors=[{segments: [{type:"bezier", point1:point1}]}];
       * $("#diagramcontent").ejDiagram({connectors:connectors});
       * &lt;/script&gt
       * @alias ejDiagram#connectors->segments->point1
       * @memberof ejDiagram
       * @instance
       */
        point1: null,
        /** Describes the second control point of bezier segment
           * @default null
           * @type {Point}
           * @example
           * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
           * &lt;script&gt;
           * var connectors = [];
           * var point2= {x:10,y:10};
           * connectors=[{segments: [{type:"bezier",point2:point2}]}];
           * $("#diagramcontent").ejDiagram({connectors:connectors});
           * &lt;/script&gt
           * @alias ejDiagram#connectors->segments->point2
           * @memberof ejDiagram
           * @instance
           */
        point2: null,
        /** Describes the length and angle between the first control point and start point of segment
         * @default null
         * @type {Point}
         * @example
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         * &lt;script&gt;
         * var connectors = [];
         * var vector1= {x:20,y:20};
         * connectors=[{segments: [{type:"bezier",vector1:vector1}]}];
         * $("#diagramcontent").ejDiagram({connectors:connectors});
         * &lt;/script&gt
         * @alias ejDiagram#connectors->segments->vector1
         * @memberof ejDiagram
         * @instance
            */
        vector1: null,
        /** Describes the length and angle between the second control point and end point of segment
        * @default null
        * @type {Point}
        * @example
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * var connectors = [];
        * var vector2= {x:20,y:20};
        * connectors=[{segments: [{type:"bezier",vector2:vector2}]}];
        * $("#diagramcontent").ejDiagram({connectors:connectors});
        * &lt;/script&gt
        * @alias ejDiagram#connectors->segments->vector2
        * @memberof ejDiagram
        * @instance
           */
        vector2: null,
        _point1: ej.datavisualization.Diagram.Point(),
        _point2: ej.datavisualization.Diagram.Point(),
        /** Describes the length of orthogonal segment
* @default null
* @type {Number}
* @example
* &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
* &lt;script&gt;
* var connectors = [];
* connectors=[{segments: [{type:"orthogonal",length:20}]}];
* $("#diagramcontent").ejDiagram({connectors:connectors});
* &lt;/script&gt
* @alias ejDiagram#connectors->segments->length
* @memberof ejDiagram
* @instance
*/

        length: null, _length: null,
        _bridges: [],
        /** Describes the  direction of orthogonal segment
   * @default null
   * @type {String}
   * @example
   * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
   * &lt;script&gt;
   * var connectors = [];
   * connectors=[{segments: [{type:"orthogonal",direction:"left"}]}];
   * $("#diagramcontent").ejDiagram({connectors:connectors});
   * &lt;/script&gt
   * @alias ejDiagram#connectors->segments->direction
   * @memberof ejDiagram
   * @instance
    */
        direction: null, _direction: null,
    };
    ej.datavisualization.Diagram.Segment = function (options) {
        var line = $.extend(true, {}, ej.datavisualization.Diagram.SegmentDefaults, options);
        var points = [];
        line["points"] = points;
        if (line.type == "orthogonal") {
            line._length = line.length;
            line._direction = line.direction;
        }
        else {
            if (line.type == "bezier") {
                line._point1 = line.point1;
                line._point2 = line.point2;
            }
            line._point = line.point;
        }
        return line;
    };
    //#endregion


    //#region Margin
    /** This clears area around the label in diagram 
    * @alias ejDiagram.Label#margin
    */

    ej.datavisualization.Diagram.MarginDefaults = {
        /**		
                  * This allows to set the top margin for the label
                  * @default 0
                  * @type {Number}
                  * @example 
                  * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
                  * &lt;script&gt;
                  * var node = [];
                  *node={[labels: [{"margin": new ej.datavisualization.Diagram.Margin({ "top": 30})}]};
                  *$("#diagramContent").ejDiagram({nodes:node}); 
                  * &lt;/script&gt
                  * @alias  ejDiagram.Label#margin->top
                   * @memberof ejDiagram.Label
                  * @instance
                  */
        top: 0,
        /**		
                 * This allows to set the left margin for the label
                 * @default 0
                 * @type {Number}
                 * @example 
                 * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
                 * &lt;script&gt;
                 * var node = [];
                 *node={[labels: [{"margin": new ej.datavisualization.Diagram.Margin({ "left": 30})}]};
                 *$("#diagramContent").ejDiagram({nodes:node}); 
                 * &lt;/script&gt
                 * @alias  ejDiagram.Label#margin->left
                  * @memberof ejDiagram.Label
                 * @instance
                 */
        left: 0,
        /**		
                 * This allows to set the right margin for the label
                 * @default 0
                 * @type {Number}
                 * @example 
                 * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
                 * &lt;script&gt;
                 * var node = [];
                 *node={[labels: [{"margin": new ej.datavisualization.Diagram.Margin({ "right": 30})}]};
                 *$("#diagramContent").ejDiagram({nodes:node}); 
                 * &lt;/script&gt
                 * @alias  ejDiagram.Label#margin->right
                  * @memberof ejDiagram.Label
                 * @instance
                 */
        right: 0,
        /**		
                * This allows to set the bottom margin for the label 
                * @default 0
                * @type {Number}
                * @example 
                * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
                * &lt;script&gt;
                * var node = [];
                *node={[labels: [{"margin": new ej.datavisualization.Diagram.Margin({ "bottom": 30})}]};
                *$("#diagramContent").ejDiagram({nodes:node}); 
                * &lt;/script&gt
                * @alias  ejDiagram.Label#margin->bottom
                 * @memberof ejDiagram.Label
                * @instance
                */
        bottom: 0
    };
    ej.datavisualization.Diagram.Margin = function (options) {
        return $.extend(true, {}, ej.datavisualization.Diagram.MarginDefaults, options);
    };
    //#endregion

    //#region Path Util
    ej.datavisualization.Diagram.Path = function () {
        this._path = "";
    };
    ej.datavisualization.Diagram.Path.prototype = {
        moveTo: function (x, y) {
            this._path += "M" + x + "," + y; return this;
        },
        lineTo: function (x, y) {
            this._path += "L" + x + "," + y; return this;
        },
        cubicBezierTo: function (points, isSmooth) {
            if (isSmooth)
                this._path += "S";
            else
                this._path += "C";
            this._addPoints(points);
            return this;
        },
        quadraticBezierTo: function (points, isSmooth) {
            if (isSmooth)
                this._path += "T";
            else
                this._path += "Q";
            this._addPoints(points);
            return this;
        },
        ellipticalArcTo: function (rx, ry, xAngle, arcFlag, sweepFlag, x, y) {
            this._path += "A" + rx + "," + ry + " " + xAngle + " " + arcFlag + "," + sweepFlag + " " + x + "," + y;
            return this;
        },
        close: function () {
            this._path += "Z"; return this;
        },
        toString: function () {
            return this._path;
        },
        _addPoints: function (points) {
            var point;
            for (var i = 0; i < points.length; i++) {
                point = points[i];
                this._path += point.x + ", " + point.y;
                if (i !== (points.length - 1))
                    this._path += " ";
            }
        }
    };
    //#endregion

    ej.datavisualization.Diagram.DecoratorDefaults = {
        /** The shape of decorator in connector See {@link DecoratorShapes}
     
        * @default ej.datavisualization.Diagram.DecoratorShapes.Arrow
        * @type {enum}
        * @example
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * var link=[];
        * link={[targetDecorator:{shape:"arrow"}]};
        * $("#diagramcontent").ejDiagram({connectors:link});
        * &lt;/script&gt
        * @alias ejDiagram#connectors->sourceDecorator->shape
    
        * @memberof ejDiagram
        * @instance
        */

        shape: ej.datavisualization.Diagram.DecoratorShapes.Arrow,
        /** This allows to set the width of the decorator in connector
    * @default 8
    * @type {Number}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var link=[];
    * link={[targetDecorator:{width:10}]};
    * $("#diagramcontent").ejDiagram({connectors:link});
    * &lt;/script&gt
     * @alias ejDiagram#connectors->sourceDecorator->width
     
    * @memberof ejDiagram
    * @instance
    */
        width: 8,
        /** This allows to set the height of the decorator in connector
         * @default 8
         * @type {Number}
         * @example
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         * &lt;script&gt;
         * var link=[];
         * link={[targetDecorator:{height:10}]};
         * $("#diagramcontent").ejDiagram({connectors:link});
         * &lt;/script&gt
           * @alias ejDiagram#connectors->sourceDecorator->height
      
      * @memberof ejDiagram
         * @instance
         */
        height: 8,
        /** Sets the border color of the decorator
    * @default "black"
    * @type {String}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var link=[];
    * link={[targetDecorator:{borderColor: "green"}]};
    * $("#diagramcontent").ejDiagram({connectors:link});
    * &lt;/script&gt
      * @alias ejDiagram#connectors->sourceDecorator->borderColor
      
     * @memberof ejDiagram
    * @instance
    */
        borderColor: "black",
        /** The color which sets inside the decorator 
    * @default "black"
    * @type {String}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var link=[];
    * link={[targetDecorator:{fillColor: "green"}]};
    * $("#diagramcontent").ejDiagram({connectors:link});
    * &lt;/script&gt
     * @alias ejDiagram#connectors->sourceDecorator->fillColor
     
    * @memberof ejDiagram
    * @instance
    */
        fillColor: "black",
        /** Path data to draw custom shape for decorator
    * @default ""
    * @type {String}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var link=[];
    * link={[targetDecorator:{pathData: "M 269.711,29.3333C 269.711,44.061 257.772,56 243.044,56z"}]};
    * $("#diagramcontent").ejDiagram({connectors:link});
    * &lt;/script&gt
    * @alias ejDiagram#connectors->sourceDecorator->pathData
    
    * @memberof ejDiagram
    * @instance
    */
        pathData: ""
    };
    ej.datavisualization.Diagram.Decorator = function (options) {
        return $.extend(true, {}, ej.datavisualization.Diagram.DecoratorDefaults, options);
    };
    //#endregion


    ej.datavisualization.Diagram.TextBlockDefaults = {
        /** Allow the label to be read only
     * @default false
     * @type {Boolean}
     * @example
     * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
     * &lt;script&gt;
     * var node=[];
     * node=[{labels:{"readOnly": false}}];
     * $("#diagramcontent").ejDiagram({nodes:node});
     * &lt;/script&gt
      * @alias ejDiagram#nodes->labels->readOnly
      
    * @memberof ejDiagram
     * @instance
     */
        readOnly: false,
        /** To displays the bold font style for label
      * @default false
      * @type {Boolean}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var node=[];
      * node=[{labels:{"bold": false}}];
      * $("#diagramcontent").ejDiagram({nodes:node});
      * &lt;/script&gt
       * @alias ejDiagram#nodes->labels->bold
      
    * @memberof ejDiagram
      * @instance
      */
        bold: false,
        /** To displays the italic font style for label
    * @default false
    * @type {Boolean}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var node=[];
    * node=[{labels:{"italic": false}}];
    * $("#diagramcontent").ejDiagram({nodes:node});
    * &lt;/script&gt
     * @alias ejDiagram#nodes->labels->italic
     
    * @memberof ejDiagram
    * @instance
    */
        italic: false,
        /** Set text for the label
    * @default ""
    * @type {String}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var node=[];
    * node=[{labels:{"text": "Label"}}];
    * $("#diagramcontent").ejDiagram({nodes:node});
    * &lt;/script&gt
    * @alias ejDiagram#nodes->labels->text
     
    * @memberof ejDiagram
    * @instance
    */
        text: "",
        /**Thi allows to specifies the decoration addeed to text see{@link TextDecorations}
    
      * @default TextDecorations.None
      * @type {Enum}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var node=[];
      * node=[{labels:{textDecoration: ej.datavisualization.Diagram.TextDecorations.Underline}}];
      * $("#diagramcontent").ejDiagram({nodes:node});
      * &lt;/script&gt
       * @alias ejDiagram#nodes->labels->textDecoration
      
    * @memberof ejDiagram
      * @instance
      */
        textDecoration: ej.datavisualization.Diagram.TextDecorations.None,
        /** To sets the size of the font of the label
    * @default 12
    * @type {Integer}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var node=[];
    * node=[{labels:{"fontSize": 12}}];
    * $("#diagramcontent").ejDiagram({nodes:node});
    * &lt;/script&gt
    * @alias ejDiagram#nodes->labels->fontSize
    
    
    * @memberof ejDiagram
    * @instance
    */
        fontSize: 12,
        /** This allows to set font for label
    * @default "arial"
    * @type {String}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var node=[];
    * node=[{labels:{"fontFamily": "Arial"}}];
    * $("#diagramcontent").ejDiagram({nodes:node});
    * &lt;/script&gt
    * @alias ejDiagram#nodes->labels->fontFamily
    
    * @memberof ejDiagram
    * @instance
    */
        fontFamily: "Arial",
        /** Used to set the text color
    * @default "black"
    * @type {String}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var node=[];
    * node=[{labels:{"fontColor": "black"}}];
    * $("#diagramcontent").ejDiagram({nodes:node});
    * &lt;/script&gt
    * @alias ejDiagram#nodes->labels->fontColor
    
    * @memberof ejDiagram
    * @instance
    */
        fontColor: "black",
        /** Set offset to align label poistion
    * @default Point(0.5, 0.5)
    * @type {Point}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var node=[];
    * node=[{labels:{offset: ej.datavisualization.Diagram.Point(0.5, 0.5)}}];
    * $("#diagramcontent").ejDiagram({nodes:node});
    * &lt;/script&gt
    * @alias ejDiagram#nodes->labels->offset
    
    * @memberof ejDiagram
    * @instance
    */
        offset: ej.datavisualization.Diagram.Point(0.5, 0.5),
        /** Alignment of text in an element see{@link TextAlign}
    
      * @default TextAlign.Center
      * @type {Enum}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var node=[];
      * node=[{labels:{textAlign: ej.datavisualization.Diagram.TextAlign.Center}}];
      * $("#diagramcontent").ejDiagram({nodes:node});
      * &lt;/script&gt
       * @alias ejDiagram#nodes->labels->textAlign
       
     * @memberof ejDiagram
      * @instance
      */
        textAlign: ej.datavisualization.Diagram.TextAlign.Center,
        /** Horizontal alignment of text in an element see{@link HorizontalAlignment}
    
      * @default HorizontalAlignment.Center
      * @type {Enum}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var node=[];
      * node=[{labels:{horizontalAlignment: ej.datavisualization.Diagram.HorizontalAlignment.Center}}];
      * $("#diagramcontent").ejDiagram({nodes:node});
      * &lt;/script&gt
       * @alias ejDiagram#nodes->labels->horizontalAlignment
      
    * @memberof ejDiagram
      * @instance
      */
        horizontalAlignment: ej.datavisualization.Diagram.HorizontalAlignment.Center,
        /** Vertical alignment of text in an element see{@link VerticalAlignment}
      
      * @default VerticalAlignment.Center
      * @type {Enum}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var node=[];
      * node=[{labels:{verticalAlignment: ej.datavisualization.Diagram.VerticalAlignment.Center}}];
      * $("#diagramcontent").ejDiagram({nodes:node});
      * &lt;/script&gt
       * @alias ejDiagram#nodes->labels->verticalAlignment
    
    * @memberof ejDiagram
      * @instance
      */
        verticalAlignment: ej.datavisualization.Diagram.VerticalAlignment.Center,
        /** This enables or disables the line breaking rules for text
    * @default true
    * @type {Boolean}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var node=[];
    * node=[{labels:{wrapText: true}}];
    * $("#diagramcontent").ejDiagram({nodes:node});
    * &lt;/script&gt
     * @alias ejDiagram#nodes->labels->wrapText
    
    * @memberof ejDiagram
    * @instance
    */
        wrapText: true,
        /** margin of the label 
      * @default ej.datavisualization.Diagram.Margin()
      * @type {Object}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var node=[];
      * node=[{labels:{"margin": ej.datavisualization.Diagram.Margin()}}];
      * $("#diagramcontent").ejDiagram({nodes:node});
      * &lt;/script&gt
       * @alias ejDiagram#nodes->labels->margin
       
     * @memberof ejDiagram
      * @instance
      */
        margin: ej.datavisualization.Diagram.Margin(),
        /** To set the label edit mode see{@link LabelEditMode}       
      * @default LabelEditMode.Edit
      * @type {Enum}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var node=[];
      * node=[{labels:{mode: ej.datavisualization.Diagram.LabelEditMode.Edit}}];
      * $("#diagramcontent").ejDiagram({nodes:node});
      * &lt;/script&gt
       * @alias ejDiagram#nodes->labels->mode
       
     * @memberof ejDiagram
      * @instance
      */
        mode: ej.datavisualization.Diagram.LabelEditMode.Edit,
        /** To set the width of the label
     * @default 50
     * @type {Interger}
     * @example
     * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
     * &lt;script&gt;
     * var node=[];
     * node=[{labels:{width: 50}}];
     * $("#diagramcontent").ejDiagram({nodes:node});
     * &lt;/script&gt
      * @alias ejDiagram#nodes->labels->width
     
     * @memberof ejDiagram
     * @instance
     */
        width: 50,
        /** To set the angle of the label
     * @default 0
     * @type {Number}
     * @example
     * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
     * &lt;script&gt;
     * var node=[];
     * node=[{labels:{rotateAngle: 90}}];
     * $("#diagramcontent").ejDiagram({nodes:node});
     * &lt;/script&gt
     * @memberof ejDiagram
     * @instance
     */
        rotateAngle: 0
    };
    ej.datavisualization.Diagram.TextBlock = function (options) {
        return $.extend(true, {}, ej.datavisualization.Diagram.TextBlockDefaults, options);
    };
    ///**The label properties for node/Connector
    //* @alias ejDiagram#node->labels*/
    ej.datavisualization.Diagram.LabelDefaults = $.extend(true, {}, ej.datavisualization.Diagram.TextBlockDefaults, {
        /** Name of the label 
      * @default ""
      * @type {String}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var node=[];
      * node=[{labels:{name:"Label"}}];
      * $("#diagramcontent").ejDiagram({nodes:node});
      * &lt;/script&gt
       * @alias ejDiagram#nodes->labels->name
        
    * @memberof ejDiagram
      * @instance
      */
        name: "",
        /**Enables or disables the visibility of the label 
      * @default true
      * @type {Boolean}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var node=[];
      * node=[{labels:{visible: true}}];
      * $("#diagramcontent").ejDiagram({nodes:node});
      * &lt;/script&gt
       * @alias ejDiagram#nodes->labels->visible
     
    * @memberof ejDiagram
      * @instance
      */
        visible: true,
        /**The color of the border for the text
      * @default "transparent"
      * @type {String}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var node=[];
      * node=[{labels:{borderColor: "transparent"}}];
      * $("#diagramcontent").ejDiagram({nodes:node});
      * &lt;/script&gt
       * @alias ejDiagram#nodes->labels->borderColor
        
      * @memberof ejDiagram
      * @instance
      */
        borderColor: "transparent",
        /**Sets the border width of the label 
      * @default 0
      * @type {Number}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var node=[];
      * node=[{labels:{borderWidth: 4}}];
      * $("#diagramcontent").ejDiagram({nodes:node});
      * &lt;/script&gt
       * @alias ejDiagram#nodes->labels->borderWidth
         
      * @memberof ejDiagram
      * @instance
      */
        borderWidth: 0,
        /**The color which is filled inside the text 
      * @default "transparent"
      * @type {String}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var node=[];
      * node=[{labels:{fillColor: "green"}}];
      * $("#diagramcontent").ejDiagram({nodes:node});
      * &lt;/script&gt
       * @alias ejDiagram#nodes->labels->fillColor
       
      * @memberof ejDiagram
      * @instance
      */
        fillColor: "transparent"
    });
    ej.datavisualization.Diagram.Label = function (options) {
        var label = $.extend(true, {}, ej.datavisualization.Diagram.LabelDefaults, options);
        if (label.horizontalAlignment == "center")
            label.margin.left = 0;
        if (label.verticalAlignment == "center")
            label.margin.top = 0;
        return label;
    };
    //#endregion

    //#region Port


    //    /**
    //* @namespace ej
    //* @class ejDiagram.Port 
    //* @classdesc Port is a specific point on node to make a static connection with node
    //* @example 
    //* &lt;div id="diagram"&gt;&lt;/div&gt;<br>
    //* &lt;script&gt;
    //* //Create Diagram
    //$("#diagram").ejDiagram();
    //* &lt;/script&gt
    //*/
    ej.datavisualization.Diagram.PortDefaults = {
        /** The name of port to be specified
           * @default ""
           * @type {String}
           * @example
           * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
           * &lt;script&gt;
           * var node=[];
           * node={ports:[{ name: "port"}]};
           * $("#diagramcontent").ejDiagram({nodes:node});
           * &lt;/script&gt
    
            * @alias ejDiagram#nodes->ports->name;
           * @memberof ejDiagram 
           * @instance
           */
        name: "",
        /** Enables or disables the visibility of port See {@link PortVisibility}
      
      * @default PortVisibility.Default
      * @type {enum}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var node=[];
      * node={ports:[{visibility: ej.datavisualization.Diagram.PortVisibility.Default}]};
      * $("#diagramcontent").ejDiagram({nodes:port});
      * &lt;/script&gt 
        * @alias ejDiagram#nodes->ports->visibility
           * @memberof ejDiagram 
      * @instance
      */
        visibility: ej.datavisualization.Diagram.PortVisibility.Default,
        /** Enables or disables the behavior of port See {@link PortConstraints}
      
      * @default PortConstraints.Connect
      * @type {enum}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var node=[];
      * node={ports:[{constraints: ej.datavisualization.Diagram.PortConstraints.Connect}]};
      * $("#diagramcontent").ejDiagram({nodes:node});
      * &lt;/script&gt
        * @alias ejDiagram#nodes->ports->constraints
          * @memberof ejDiagram 
      * @instance
      */
        constraints: ej.datavisualization.Diagram.PortConstraints.Connect,
        /**Size of the port
    * @default 8
    * @type {Number}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var node=[];
    * node={ports:[{size: 10}]};
    * $("#diagramcontent").ejDiagram({nodes:node});
    * &lt;/script&gt
     * @alias ejDiagram#nodes->ports->size
          * @memberof ejDiagram 
    * @instance
    */
        size: 8,
        /** Offset value to align the label position
    * @default Point(0, 0)
    * @type {Point}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var node=[];
    * node={ports:[{{ x: 0, y: 0.5 }}]};
    * $("#diagramcontent").ejDiagram({nodes:node});
    * &lt;/script&gt
      * @alias ejDiagram#nodes->ports->offset
           * @memberof ejDiagram 
    * @instance
    */
        offset: ej.datavisualization.Diagram.Point(0, 0),
        /** Sets the border color of the port
    * @default "#1a1a1a"
    * @type {String}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var node=[];
    * node={ports:[{borderColor:"green"}]};
    * $("#diagramcontent").ejDiagram({nodes:node});
    * &lt;/script&gt
       * @alias ejDiagram#nodes->ports->borderColor
          * @memberof ejDiagram 
    * @instance
    */
        borderColor: "#1a1a1a",
        /** Sets the border width of the port
    * @default 1
    * @type {Number}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var node=[];
    * node={ports:[{borderWidth: 1}]};
    * $("#diagramcontent").ejDiagram({nodes:node});
    * &lt;/script&gt
      * @alias ejDiagram#nodes->ports->borderWidth
            * @memberof ejDiagram 
    * @instance
    */
        borderWidth: 1,
        /** The color to be filled inside the port 
     * @default "white"
     * @type {String}
     * @example
     * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
     * &lt;script&gt;
     * var node=[];
     * node={ports:[{fillColor:"green"}]};
     * $("#diagramcontent").ejDiagram({nodes:node});
     * &lt;/script&gt
      * @alias ejDiagram#nodes->ports->fillColor
           * @memberof ejDiagram 
     * @instance
     */
        fillColor: "white",
        /** Shape of the port to be updated See {@link PortShapes}
    
    * @default PortShapes.Square
    * @type {enum}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var node=[];
    * node={ports:[{shape: ej.datavisualization.Diagram.PortShapes.Square}]};
    * $("#diagramcontent").ejDiagram({nodes:node});
    * &lt;/script&gt
     * @alias ejDiagram#nodes->ports->shape
            * @memberof ejDiagram
    * @instance
    */
        shape: ej.datavisualization.Diagram.PortShapes.Square,
        /**Path data to draw the custom port 
    * @default ""
    * @type {String}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var node=[];
    * node={ports:[{pathData:""}]};
    * $("#diagramcontent").ejDiagram({nodes:node});
    * &lt;/script&gt
    * @alias ejDiagram#nodes->ports->pathData
          * @memberof ejDiagram 
    * @instance
    */
        pathData: "",
        /** To set distance to left of between port and connector.
        * @default 0
        * @type {Int}
        * @example
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * var node = [{ports:[{connectorPadding:2}]}];
        * $("#diagramcontent").ejDiagram({nodes:node});
        * &lt;/script&gt
        * @alias ejDiagram#nodes->ports->connectorPadding
        * @memberof ejDiagram
        * @instance
        */
        connectorPadding: 0
    };
    ej.datavisualization.Diagram.Port = function (options) {
        return $.extend(true, {}, ej.datavisualization.Diagram.PortDefaults, options);
    };
    //#endregion
    // /**
    //* @namespace ej
    //* @class Gradient 
    //* @classdesc The diagram control provides 2D surface to visualize the data as shapes, lines, text and images. It can be configured to DOM element such as DIV.
    //* @example 
    //* &lt;div id="diagram"&gt;&lt;/div&gt;<br>
    //* &lt;script&gt;
    //* //Create Diagram
    //$("#diagram").ejDiagram();
    //* &lt;/script&gt

    // */
    /**Specifies the gradient of the Node.
           * @type {object} 
              * @memberof ejDiagram
             * @alias ejDiagram#nodes->gradient->Stop
             * @instance
           */

    //#region Gradient
    ej.datavisualization.Diagram.StopDefaults = {
        /**The color for applied gradient region 
          * @default ""
          * @type {String}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var gradient = ej.datavisualization.Diagram.LinearGradientDefaults();
          * gradient.type = "linear;
          * gradient.x1 = 0;
          * gradient.x2 = 50;
          * gradient.y1 = 0;
          * gradient.y2 = 50;
          * var stop = ej.datavisualization.Diagram.Stop();
          * stop.color = "white";
          * stop.offset = 0;
          * gradient.stops.push(stop);
          * stop = ej.datavisualization.Diagram.Stop();
          * stop.color = "darkCyan";
          * stop.offset = 100;
          * gradient.stops.push(stop);
          * gradient.stops.push(stop);
          * var nodes = [{name:"Node1",width: 100,height: 100,gradient : gradient}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
        * @alias ejDiagram#nodes->gradient->Stop->color
          * @memberof ejDiagram
          * @instance
          */
        color: "",
        /**To set desired offset to apply color to the node region
          * @default 0
          * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var gradient = ej.datavisualization.Diagram.LinearGradientDefaults();
          * gradient.type = "linear;
          * gradient.x1 = 0;
          * gradient.x2 = 50;
          * gradient.y1 = 0;
          * gradient.y2 = 50;
          * var stop = ej.datavisualization.Diagram.Stop();
          * stop.color = "white";
          * stop.offset = 0;
          * gradient.stops.push(stop);
          * stop = ej.datavisualization.Diagram.Stop();
          * stop.color = "darkCyan";
          * stop.offset = 100;
          * gradient.stops.push(stop);
          * gradient.stops.push(stop);
          * var nodes = [{name:"Node1",width: 100,height: 100,gradient : gradient}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->gradient->Stop->offset
          * @memberof ejDiagram
          * @instance
          */
        offset: 0,
        /**Decribes the transparency level for the region
          * @default 1
          * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var gradient = ej.datavisualization.Diagram.LinearGradientDefaults();
          * gradient.type = "linear;
          * gradient.x1 = 0;
          * gradient.x2 = 50;
          * gradient.y1 = 0;
          * gradient.y2 = 50;
          * var stop = ej.datavisualization.Diagram.Stop();
          * stop.color = "white";
          * stop.opacity = 0.8;
          * stop.offset = 0;
          * gradient.stops.push(stop);
          * stop = ej.datavisualization.Diagram.Stop();
          * stop.color = "darkCyan";
          * stop.offset = 100;
          * gradient.stops.push(stop);
          * gradient.stops.push(stop);
          * var nodes = [{name:"Node1",width: 100,height: 100,gradient : gradient}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
        * @alias ejDiagram#nodes->gradient->Stop->opacity
          * @memberof ejDiagram
          * @instance
          */
        opacity: 1
    };
    ej.datavisualization.Diagram.Stop = function (options) {
        return $.extend(true, {}, ej.datavisualization.Diagram.StopDefaults, options);
    };

    /**Paints an area with a linear gradient. 
           * @type {object}
            
              * @alias ejDiagram#nodes->gradient->LinearGradient
             
           */
    ej.datavisualization.Diagram.LinearGradientDefaults = {
        type: "linear",
        /**The starting X-Axis for the region
        * @default 0
        * @type {Int}
        * @example
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * var gradient = ej.datavisualization.Diagram.LinearGradientDefaults();
        * gradient.type = "linear;
        * gradient.x1 = 10;
        * gradient.x2 = 50;
        * gradient.y1 = 0;
        * gradient.y2 = 50;
        * var nodes = [{name:"Node1",width: 100,height: 100,gradient : gradient}];
        * $("#diagramcontent").ejDiagram({nodes:nodes});
        * &lt;/script&gt
          * @alias ejDiagram#nodes->gradient->LinearGradient->x1
        * @memberof ejDiagram
        * @instance
        */
        x1: 0,
        /**The ending X-Axis for the region
        * @default 0
        * @type {Int}
        * @example
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * var gradient = ej.datavisualization.Diagram.LinearGradientDefaults();
        * gradient.type = "linear;
        * gradient.x1 = 10;
        * gradient.x2 = 50;
        * gradient.y1 = 20;
        * gradient.y2 = 50;
        * var nodes = [{name:"Node1",width: 100,height: 100,gradient : gradient}];
        * $("#diagramcontent").ejDiagram({nodes:nodes});
        * &lt;/script&gt
          * @alias ejDiagram#nodes->gradient->LinearGradient->x2
        * @memberof ejDiagram
        * @instance
        */
        x2: 0,
        /**The starting Y-Axis for the region
        * @default 0
        * @type {Int}
        * @example
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * var gradient = ej.datavisualization.Diagram.LinearGradientDefaults();
        * gradient.type = "linear;
        * gradient.x1 = 10;
        * gradient.x2 = 50;
        * gradient.y1 = 0;
        * gradient.y2 = 50;
        * var nodes = [{name:"Node1",width: 100,height: 100,gradient : gradient}];
        * $("#diagramcontent").ejDiagram({nodes:nodes});
        * &lt;/script&gt
           * @alias ejDiagram#nodes->gradient->LinearGradient->y1
        * @memberof ejDiagram
        * @instance
        */
        y1: 0,
        /**The ending Y-Axis for the region
        * @default 0
        * @type {Int}
        * @example
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * var gradient = ej.datavisualization.Diagram.LinearGradientDefaults();
        * gradient.type = "linear;
        * gradient.x1 = 10;
        * gradient.x2 = 50;
        * gradient.y1 = 0;
        * gradient.y2 = 50;
        * var nodes = [{name:"Node1",width: 100,height: 100,gradient : gradient}];
        * $("#diagramcontent").ejDiagram({nodes:nodes});
        * &lt;/script&gt
          * @alias ejDiagram#nodes->gradient->LinearGradient->y2
        * @memberof ejDiagram
        * @instance
        */
        y2: 0,
        /**The stop region for the gradient
        * @default ""
          * @type {Array}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var gradient = ej.datavisualization.Diagram.LinearGradientDefaults();
          * gradient.type = "linear;
          * gradient.x1 = 10;
          * gradient.x2 = 50;
          * gradient.y1 = 20;
          * gradient.y2 = 50;
          * var stop = ej.datavisualization.Diagram.Stop();
          * stop.color = "white";
          * stop.opacity = 0.8;
          * stop.offset = 0;
          * gradient.stops.push(stop);
          * stop = ej.datavisualization.Diagram.Stop();
          * stop.color = "darkCyan";
          * stop.offset = 100;
          * gradient.stops.push(stop);
          * gradient.stops.push(stop);
          * var nodes = [{name:"Node1",width: 100,height: 100,gradient : gradient}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
           * @alias ejDiagram#nodes->gradient->LinearGradient->stops
          * @memberof ejDiagram
          * @instance
        */
        stops: []
    };
    ej.datavisualization.Diagram.LinearGradient = function (options) {
        for (var i = 0; i < options.stops.length; i++) {
            options.stops[i] = ej.datavisualization.Diagram.Stop(options.stops[i]);
        }
        return $.extend(true, {}, ej.datavisualization.Diagram.LinearGradientDefaults, options);
    };
    /**Paints an area with a radial gradient. A focal point defines the beginning of the gradient, and a circle defines the end point of the gradient. 
           * @type {object}
             
                 * @alias ejDiagram#nodes->gradient->RadialGradient
          
           */
    ej.datavisualization.Diagram.RadialGradientDefaults = {
        type: "radial",
        /**The starting X-Axis for the region
        * @default 0
        * @type {Int}
        * @example
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * var gradient = ej.datavisualization.Diagram.RadialGradientDefaults();
        * gradient.type = "linear;
        * gradient.cx = 20;
        * gradient.cy = 50;
        * gradient.fx = 20;
        * gradient.fy = 50;
        * var nodes = [{name:"Node1",width: 100,height: 100,gradient : gradient}];
        * $("#diagramcontent").ejDiagram({nodes:nodes});
        * &lt;/script&gt
        * @alias ejDiagram#nodes->gradient->RadialGradient->cx
        * @memberof ejDiagram
        * @instance
        */
        cx: 0,
        /**The ending X-Axis for the region
       * @default 0
       * @type {Int}
       * @example
       * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
       * &lt;script&gt;
       * var gradient = ej.datavisualization.Diagram.RadialGradientDefaults();
       * gradient.type = "linear;
       * gradient.cx = 20;
       * gradient.cy = 50;
       * gradient.fx = 20;
       * gradient.fy = 50;
       * var nodes = [{name:"Node1",width: 100,height: 100,gradient : gradient}];
       * $("#diagramcontent").ejDiagram({nodes:nodes});
       * &lt;/script&gt
    * @alias ejDiagram#nodes->gradient->RadialGradient->cy
       * @memberof ejDiagram
       * @instance
       */
        cy: 0,
        /**The starting X-Axis for the region
        * @default 0
        * @type {Int}
        * @example
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * var gradient = ej.datavisualization.Diagram.RadialGradientDefaults();
        * gradient.type = "linear;
        * gradient.cx = 20;
        * gradient.cy = 50;
        * gradient.fx = 20;
        * gradient.fy = 50;
        * var nodes = [{name:"Node1",width: 100,height: 100,gradient : gradient}];
        * $("#diagramcontent").ejDiagram({nodes:nodes});
        * &lt;/script&gt
      * @alias ejDiagram#nodes->gradient->RadialGradient->fx
        * @memberof ejDiagram
        * @instance
        */
        fx: 0,
        /**The ending Y-Axis for the region
       * @default 0
       * @type {Int}
       * @example
       * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
       * &lt;script&gt;
       * var gradient = ej.datavisualization.Diagram.RadialGradientDefaults();
       * gradient.type = "linear;
       * gradient.cx = 20;
       * gradient.cy = 50;
       * gradient.fx = 20;
       * gradient.fy = 50;
       * var nodes = [{name:"Node1",width: 100,height: 100,gradient : gradient}];
       * $("#diagramcontent").ejDiagram({nodes:nodes});
       * &lt;/script&gt
    * @alias ejDiagram#nodes->gradient->RadialGradient->fy
       * @memberof ejDiagram
       * @instance
       */
        fy: 0,
        r: 50,
        /**The stop region for the gradient
        * @default ""
          * @type {Array}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var gradient = ej.datavisualization.Diagram.RadialGradientDefaults();
          * gradient.type = "linear;
          * gradient.x1 = 10;
          * gradient.x2 = 50;
          * gradient.y1 = 20;
          * gradient.y2 = 50;
          * var stop = ej.datavisualization.Diagram.Stop();
          * stop.color = "white";
          * stop.opacity = 0.8;
          * stop.offset = 0;
          * gradient.stops.push(stop);
          * stop = ej.datavisualization.Diagram.Stop();
          * stop.color = "darkCyan";
          * stop.offset = 100;
          * gradient.stops.push(stop);
          * gradient.stops.push(stop);
          * var nodes = [{name:"Node1",width: 100,height: 100,gradient : gradient}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->gradient->RadialGradient->stops
          * @memberof ejDiagram
          * @instance
        */
        stops: []
    };
    ej.datavisualization.Diagram.RadialGradient = function (options) {
        for (var i = 0; i < options.stops.length; i++) {
            options.stops[i] = ej.datavisualization.Diagram.Stop(options.stops[i]);
        }
        return $.extend(true, {}, ej.datavisualization.Diagram.RadialGradientDefaults, options);
    };


    //#region Node
    ej.datavisualization.Diagram.NodeBaseDefaults = {
        /** To set the name of node
          * @default ""
          * @type {String}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{name:"Node1"}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->name
          * @memberof ejDiagram
          * @instance
          */
        name: "",
        /** To sets the width of the node
          * @default 0
          * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{width: 100}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
            * @alias ejDiagram#nodes->width
          * @memberof ejDiagram
          * @instance
          */
        width: 0,
        /** To sets the height of the node
          * @default 0
          * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{height: 100}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->height
          * @memberof ejDiagram
          * @instance
          */
        height: 0,
        /** Align nodes position along X-axis
          * @default 0
          * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{offsetX: 100}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
           * @alias ejDiagram#nodes->offsetX
          * @memberof ejDiagram
          * @instance
          */
        offsetX: 0,
        /** Align nodes position along y axis
          * @default 0
          * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{offsetY: 100}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->offsetY
          * @memberof ejDiagram
          * @instance
          */
        offsetY: 0,
        /** To set the visibility of the node
          * @default true
          * @type {Boolean}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{visible: true}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
           * @alias ejDiagram#nodes->visible
          * @memberof ejDiagram
          * @instance
          */
        visible: true,
        /** Zorder of the node
          * @default 0
          * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{zOrder: 1}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->zOrder
          * @memberof ejDiagram
          * @instance
          */
        zOrder: 0,
        /**The arrangements of node in layout
          * @default false
          * @type {Boolean}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{visible: true}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->excludeFromLayout
          * @memberof ejDiagram
          * @instance
          */
        excludeFromLayout: false,
        /** To enables or disables the default behaviour of the node see{@link NodeConstraints}
      
          * @default NodeConstraints.Default
          * @type {Constraints}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{Constraints: ej.datavisualization.Diagram.NodeConstraints.Select}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->constraints
          * @memberof ejDiagram
          * @instance
          */
        constraints: ej.datavisualization.Diagram.NodeConstraints.Default,
        /**parent name of the node
           * @default ""
           * @type {String}
           * @example
           * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
           * &lt;script&gt;
           * var node = [ {name: "rect",parent:"group1"}];
           * &lt;/script&gt
           * @alias ejDiagram#nodes->parent
           * @memberof ejDiagram
           * @instance
           */
        parent: "",
        /** Collection labels of node
          * @default ""
          * @type {Array}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var label = [];
          * label = { "text": "Node1", "fontColor": "Red"};
          * nodes=[{labels:label}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->labels
          * @memberof ejDiagram
          * @instance
          */
        labels: [],
        /**To add port to the node
          * @default ""
          * @type {Array}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var port: [{ offset: { x: 0, y: 0.5 }, name: "aport" }]
          * nodes=[{ports:port}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->ports
          * @memberof ejDiagram
          * @instance
          */
        ports: [],
        /**The connectors which comes to the Node.
          * @default ""
          * @type {Array}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var connectors = [{ name: "connector1", sourceNode: "Node1", targetNode: "Node2"}];
          * nodes=[{inEdges:connectors}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->inEdges
          * @memberof ejDiagram
          * @instance
          */
        inEdges: [],
        /** The connectors which leave from the Node.
          * @default ""
          * @type {Array}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var connectors = [{ name: "connector1", sourceNode: "Node1", targetNode: "Node2"}];
          * nodes=[{outEdges:connectors}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->outEdges
          * @memberof ejDiagram
          * @instance
          */
        outEdges: [],
        /** To set the rotation angle of the node
          * @default 0
          * @type {Number}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{rotateAngle: 120}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->rotateAngle
          * @memberof ejDiagram
          * @instance
          */
        rotateAngle: 0,
        /** To set the pivot point of the node
          * @default Points(0.5,0.5)
          * @type {Point}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{pivot: ej.datavisualization.Diagram.Point(0.8, 0.8)}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->pivot
          * @memberof ejDiagram
          * @instance
          */
        pivot: ej.datavisualization.Diagram.Point(0.5, 0.5),
        /** To provide/save extra information about Node
          * @default null
          * @type {Object}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * var addInfo = {Name1:"Node1",Name2:"Name2"}
          * nodes=[{addInfo: addInfo}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->addInfo
          * @memberof ejDiagram
          * @instance
          */
        addInfo: {},
        /** To set marginleft for the node. Applicable if the type is group.
         * @default 0
         * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{marginLeft: 1}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->marginLeft
          * @memberof ejDiagram
          * @instance
         */
        marginLeft: 0,
        /** To set marginTop for the node. Applicable if the type is group.
      * @default 0
      * @type {Int}
       * @example
       * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
       * &lt;script&gt;
       * var nodes = [];
       * node={name:"node1",marginTop: 1};
       * $("#diagramcontent").ejDiagram({nodes:[node]});
       * &lt;/script&gt
       * @alias ejDiagram#nodes->marginTop
       * @memberof ejDiagram
       * @instance
      */
        marginTop: 0,
        /** To set marginRight for the node. Applicable if the type is group.
        * @default 0
        * @type {Int}
         * @example
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         * &lt;script&gt;
         * var nodes = [];
         * node={name:"node1",marginRight: 1};
        * $("#diagramcontent").ejDiagram({nodes:[node]});
         * &lt;/script&gt
         * @alias ejDiagram#nodes->marginRight
         * @memberof ejDiagram
         * @instance
        */
        marginRight: 0,
        /** To set marginBottom for the node. Applicable if the type is group.
         * @default 0
         * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * node={name:"node1",marginBottom: 1};
          * $("#diagramcontent").ejDiagram({nodes:[node]});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->marginBottom
          * @memberof ejDiagram
          * @instance
         */
        marginBottom: 0,
        /** To set the horizontal alignment for node. Applicable if the type is group.
         * @default HorizontalAlignment.Left
         * @type {HorizontalAlignment}
         * @example
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         * &lt;script&gt; 
          * node={name:"node1", ej.datavisualization.Diagram.HorizontalAlignment.Left};
         * $("#diagramcontent").ejDiagram({nodes:[node]});
         * &lt;/script&gt
         * @alias ejDiagram#nodes->horizontalAlign
         * @memberof ejDiagram
         * @instance
         */
        horizontalAlign: ej.datavisualization.Diagram.HorizontalAlignment.Left,
        /** To set the Vertical  alignment for node. Applicable if the type is group.
        * @default VerticalAlignment.Top
        * @type {VerticalAlignment}
        * @example
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * var nodes = [];
        * node={name:"node1",VerticalAlignment: ej.datavisualization.Diagram.VerticalAlignment.Top};
        * $("#diagramcontent").ejDiagram({nodes:[node]});
        * &lt;/script&gt
        * @alias ejDiagram#nodes->vertical Align
        * @memberof ejDiagram
        * @instance
        */
        verticalAlign: ej.datavisualization.Diagram.VerticalAlignment.Top,
        /** To set minimum width for the node. Applicable if the type is group.
         * @default 0
         * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * node={name:"node1",minWidth: 1};
          * $("#diagramcontent").ejDiagram({nodes:[node]});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->minWidth
          * @memberof ejDiagram
          * @instance
         */
        minWidth: 0,
        /** To set maximum width for the node. Applicable if the type is group.
         * @default 0
         * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * node={name:"node1",maxWidth: 1};
          * $("#diagramcontent").ejDiagram({nodes:[node]});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->maxWidth
          * @memberof ejDiagram
          * @instance
         */
        maxWidth: 0,
        /** To set minimum height for the node. Applicable if the type is group.
         * @default 0
         * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * node={name:"node1",minHeight: 1};
          * $("#diagramcontent").ejDiagram({nodes:[node]});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->minHeight
          * @memberof ejDiagram
          * @instance
         */
        minHeight: 0,
        /** To set maximum height for the node. Applicable if the type is group.
         * @default 0
         * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * node={name:"node1",maxHeight: 1};
          * $("#diagramcontent").ejDiagram({nodes:[node]});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->maxHeight
          * @memberof ejDiagram
          * @instance
         */
        maxHeight: 0,
        /** To set distance to left of between node and connector.
         * @default 0
         * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * node={name:"node1",connectorPadding: 2};
          * $("#diagramcontent").ejDiagram({nodes:[node]});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->connectorPadding
          * @memberof ejDiagram
          * @instance
         */
        connectorPadding: 0
    };
    ej.datavisualization.Diagram.NodeBase = function (options) {
        var i;
        if (options.labels)
            for (i = 0; i < options.labels.length; i++) {
                options.labels[i] = ej.datavisualization.Diagram.Label(options.labels[i]);
            }
        if (options.ports)
            for (i = 0; i < options.ports.length; i++) {
                options.ports[i] = ej.datavisualization.Diagram.Port(options.ports[i]);
            }
        return $.extend(true, {}, ej.datavisualization.Diagram.NodeBaseDefaults, options);
    };

    ej.datavisualization.Diagram.NodeDefaults = {
        /** The color to be filled inside the node
          * @default "White"
          * @type {String}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{fillColor: "white"}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
           * @alias ejDiagram#nodes->fillColor
          * @memberof ejDiagram
          * @instance
          */
        fillColor: "white",
        /** Sets the border color of the node
      * @default "black"
      * @type {String}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var nodes = [];
      * nodes=[{borderColor: "black"}];
      * $("#diagramcontent").ejDiagram({nodes:nodes});
      * &lt;/script&gt
       * @alias ejDiagram#nodes->borderColor
      * @memberof ejDiagram
      * @instance
      */
        borderColor: "black",
        /** Sets the border width of the node
     * @default 1
     * @type {Number}
     * @example
     * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
     * &lt;script&gt;
     * var nodes = [];
     * nodes=[{borderWidth: 3}];
     * $("#diagramcontent").ejDiagram({nodes:nodes});
     * &lt;/script&gt
      * @alias ejDiagram#nodes->borderWidth
     * @memberof ejDiagram
     * @instance
     */
        borderWidth: 1,
        /** The dotted line for the node
    * @default ""
    * @type {String}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var nodes = [];
    * nodes=[{borderDashArray: "2 2"}];
    * $("#diagramcontent").ejDiagram({nodes:nodes});
    * &lt;/script&gt
     * @alias ejDiagram#nodes->borderDashArray
    * @memberof ejDiagram
    * @instance
    */
        borderDashArray: "",
        /**Defines the transparency of the node
    * @default 1
    * @type {Number}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var nodes = [];
    * nodes=[{opacity: 2}];
    * $("#diagramcontent").ejDiagram({nodes:nodes});
    * &lt;/script&gt
    * @alias ejDiagram#nodes->opacity
    * @memberof ejDiagram
    * @instance
    */
        opacity: 1,
        /** Smooth transition from one color to another color in node   
         * @alias ejDiagram#nodes->gradient
    * @memberof ejDiagram
    * @instance
    */
        gradient: null,
        /** The shape of the node see{@link Shapes}
    
    * @default Diagram.Shape()
    * @type {Enum}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var nodes = [];
    * nodes=[shape:{type: "rectangle"}];
    * $("#diagramcontent").ejDiagram({nodes:nodes});
    * &lt;/script&gt
     * @alias ejDiagram#nodes->shape
    * @memberof ejDiagram
    * @instance
    */
        shape: ej.datavisualization.Diagram.Shape(),
        /** To expand the diagram.
      * @default true
      * @type {Boolean}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var nodes = [];
      * nodes=[{isExpanded: true}];
      * $("#diagramcontent").ejDiagram({nodes:nodes});
      * &lt;/script&gt
          * @alias ejDiagram#nodes->expanded
      * @memberof ejDiagram
      * @instance
      */
        isExpanded: true,
        type: "node",
    };
    ej.datavisualization.Diagram.Node = function (options) {
        if (options.gradient) {
            if (options.gradient.type === "linear") {
                options.gradient = ej.datavisualization.Diagram.LinearGradient(options.gradient);
            }
            else if (options.gradient.type === "radial") {
                options.gradient = ej.datavisualization.Diagram.RadialGradient(options.gradient);
            }
        }
        if (options.shape) {
            options.shape = ej.datavisualization.Diagram.Shape(options.shape);
        }
        options.minWidth = options.minWidth ? options.minWidth : 0;
        options.minHeight = options.minHeight ? options.minHeight : 0;
        options.maxWidth = options.maxWidth ? options.maxWidth : 0;
        options.maxHeight = options.maxHeight ? options.maxHeight : 0;

        return $.extend(true, {}, ej.datavisualization.Diagram.NodeDefaults, ej.datavisualization.Diagram.NodeBase(options));
    };
    //#endregion

    //#region Connector
    ej.datavisualization.Diagram.ConnectorDefaults = {
        /**Name of the connector
          * @default ""
          * @type {String}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var connectors = [];
          * connectors=[{name:"Connector1"}];
          * $("#diagramcontent").ejDiagram({connectors:connectors});
          * &lt;/script&gt
           * @alias ejDiagram#connectors->name
          * @memberof ejDiagram
          * @instance
          */
        name: "",
        /** Enables or disables the visibility of connector
          * @default true
          * @type {Boolean}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var connectors = [];
          * connectors=[{visible: true}];
          * $("#diagramcontent").ejDiagram({connectors:connectors});
          * &lt;/script&gt
              * @alias ejDiagram#connectors->visible
          * @memberof ejDiagram
          * @instance
          */
        visible: true,
        /** Dotted lines for connector
          * @default ""
          * @type {String}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var connectors = [];
          * connectors=[{lineDashArray:"4 4"}];
          * $("#diagramcontent").ejDiagram({connectors:connectors});
          * &lt;/script&gt
              * @alias ejDiagram#connectors->lineDashArray
          * @memberof ejDiagram
          * @instance
          */
        lineDashArray: "",
        /** To set targetDecorator for connector
          * @default null
          * @type {String}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var connectors = [];
          * var targetDecorator = { shape: "arrow", borderColor: "#606060", width: "10", height: "10" };
          * connectors=[{targetDecorator:targetDecorator}];
          * $("#diagramcontent").ejDiagram({connectors:connectors});
          * &lt;/script&gt
              * @alias ejDiagram#connectors->targetDecorator
          * @memberof ejDiagram
          * @instance
          */
        targetDecorator:  /** @lends ejdiagram# */
            {
                /** The shape of decorator in connector See {@link DecoratorShapes}
     
        * @default ej.datavisualization.Diagram.DecoratorShapes.Arrow
        * @type {enum}
        * @example
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * var link=[];
        * link={[targetDecorator:{shape:"arrow"}]};
        * $("#diagramcontent").ejDiagram({connectors:link});
        * &lt;/script&gt
        * @alias ejDiagram#connectors->targetDecorator->shape
    
        * @memberof ejDiagram
        * @instance
        */

                shape: ej.datavisualization.Diagram.DecoratorShapes.Arrow,
                /** This allows to set the width of the decorator in connector
            * @default 8
            * @type {Number}
            * @example
            * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
            * &lt;script&gt;
            * var link=[];
            * link={[targetDecorator:{width:10}]};
            * $("#diagramcontent").ejDiagram({connectors:link});
            * &lt;/script&gt
             * @alias ejDiagram#connectors->targetDecorator->width
             
            * @memberof ejDiagram
            * @instance
            */
                width: 8,
                /** This allows to set the height of the decorator in connector
                 * @default 8
                 * @type {Number}
                 * @example
                 * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
                 * &lt;script&gt;
                 * var link=[];
                 * link={[targetDecorator:{height:10}]};
                 * $("#diagramcontent").ejDiagram({connectors:link});
                 * &lt;/script&gt
                   * @alias ejDiagram#connectors->targetDecorator->height
              
              * @memberof ejDiagram
                 * @instance
                 */
                height: 8,
                /** Sets the border color of the decorator
            * @default "black"
            * @type {String}
            * @example
            * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
            * &lt;script&gt;
            * var link=[];
            * link={[targetDecorator:{borderColor: "green"}]};
            * $("#diagramcontent").ejDiagram({connectors:link});
            * &lt;/script&gt
              * @alias ejDiagram#connectors->targetDecorator->borderColor
              
             * @memberof ejDiagram
            * @instance
            */
                borderColor: "black",
                /** The color which sets inside the decorator 
            * @default "black"
            * @type {String}
            * @example
            * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
            * &lt;script&gt;
            * var link=[];
            * link={[targetDecorator:{fillColor: "green"}]};
            * $("#diagramcontent").ejDiagram({connectors:link});
            * &lt;/script&gt
             * @alias ejDiagram#connectors->targetDecorator->fillColor
             
            * @memberof ejDiagram
            * @instance
            */
                fillColor: "black",
                /** Path data to draw custom shape for decorator
            * @default ""
            * @type {String}
            * @example
            * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
            * &lt;script&gt;
            * var link=[];
            * link={[targetDecorator:{pathData: "M 269.711,29.3333C 269.711,44.061 257.772,56 243.044,56z"}]};
            * $("#diagramcontent").ejDiagram({connectors:link});
            * &lt;/script&gt
            * @alias ejDiagram#connectors->targetDecorator->pathData
            
            * @memberof ejDiagram
            * @instance
            */
                pathData: ""
            },
        /** To set sourceDecorator for connector
         * @default null
         * @type {String}
         * @example
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         * &lt;script&gt;
         * var connectors = [];
         * var targetDecorator = { shape: "arrow", borderColor: "#606060", width: "10", height: "10" };
         * connectors=[{targetDecorator:targetDecorator}];
         * $("#diagramcontent").ejDiagram({connectors:connectors});
         * &lt;/script&gt
             * @alias ejDiagram#connectors->sourceDecorator
         * @memberof ejDiagram
         * @instance
         */

        sourceDecorator:
            /** @lends ejdiagram# */
            {
                /** The shape of decorator in connector See {@link DecoratorShapes}
     
        * @default ej.datavisualization.Diagram.DecoratorShapes.Arrow
        * @type {enum}
        * @example
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * var link=[];
        * link={[targetDecorator:{shape:"arrow"}]};
        * $("#diagramcontent").ejDiagram({connectors:link});
        * &lt;/script&gt
        * @alias ejDiagram#connectors->sourceDecorator->shape
    
        * @memberof ejDiagram
        * @instance
        */

                shape: ej.datavisualization.Diagram.DecoratorShapes.Arrow,
                /** This allows to set the width of the decorator in connector
            * @default 8
            * @type {Number}
            * @example
            * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
            * &lt;script&gt;
            * var link=[];
            * link={[targetDecorator:{width:10}]};
            * $("#diagramcontent").ejDiagram({connectors:link});
            * &lt;/script&gt
             * @alias ejDiagram#connectors->sourceDecorator->width
             
            * @memberof ejDiagram
            * @instance
            */
                width: 8,
                /** This allows to set the height of the decorator in connector
                 * @default 8
                 * @type {Number}
                 * @example
                 * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
                 * &lt;script&gt;
                 * var link=[];
                 * link={[targetDecorator:{height:10}]};
                 * $("#diagramcontent").ejDiagram({connectors:link});
                 * &lt;/script&gt
                   * @alias ejDiagram#connectors->sourceDecorator->height
              
              * @memberof ejDiagram
                 * @instance
                 */
                height: 8,
                /** Sets the border color of the decorator
            * @default "black"
            * @type {String}
            * @example
            * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
            * &lt;script&gt;
            * var link=[];
            * link={[targetDecorator:{borderColor: "green"}]};
            * $("#diagramcontent").ejDiagram({connectors:link});
            * &lt;/script&gt
              * @alias ejDiagram#connectors->sourceDecorator->borderColor
              
             * @memberof ejDiagram
            * @instance
            */
                borderColor: "black",
                /** The color which sets inside the decorator 
            * @default "black"
            * @type {String}
            * @example
            * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
            * &lt;script&gt;
            * var link=[];
            * link={[targetDecorator:{fillColor: "green"}]};
            * $("#diagramcontent").ejDiagram({connectors:link});
            * &lt;/script&gt
             * @alias ejDiagram#connectors->sourceDecorator->fillColor
             
            * @memberof ejDiagram
            * @instance
            */
                fillColor: "black",
                /** Path data to draw custom shape for decorator
            * @default ""
            * @type {String}
            * @example
            * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
            * &lt;script&gt;
            * var link=[];
            * link={[targetDecorator:{pathData: "M 269.711,29.3333C 269.711,44.061 257.772,56 243.044,56z"}]};
            * $("#diagramcontent").ejDiagram({connectors:link});
            * &lt;/script&gt
            * @alias ejDiagram#connectors->sourceDecorator->pathData
            
            * @memberof ejDiagram
            * @instance
            */
                pathData: ""
            },
        /** Describes the collection of segments
             * @default [ Segment ]
             * @type {Array}
             * @example
             * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
             * &lt;script&gt;
             * var connectors = [];
             * var point= {x:20,y:20};
             * connectors=[{segments: [{type:"straight",point:point}]}];
             * $("#diagramcontent").ejDiagram({connectors:connectors});
             * &lt;/script&gt
             * @alias ejDiagram#connectors->segments
             * @memberof ejDiagram
             * @instance
             */
        segments: [ej.datavisualization.Diagram.Segment({ type: "straight" })],

        /** Describes the sourcePoint of connector
 * @default Point
 * @type {Point}
 * @example
 * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
 * &lt;script&gt;
 * var connectors = [];
 * var sourcePoint= {x:20,y:20};
 * connectors=[{ name: "connector1",sourcePoint: { x: 450, y: 150 }}];
* $("#diagramcontent").ejDiagram({connectors:connectors});
 * &lt;/script&gt
 * @alias ejDiagram#connectors->sourcePoint
 * @memberof ejDiagram
 * @instance
 */
        sourcePoint: ej.datavisualization.Diagram.Point(),
        /** Describes the targetPoint of connector
* @default Point
* @type {Point}
* @example
* &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
* &lt;script&gt;
* var connectors = [];
* var targetPoint= {x:20,y:20};
* connectors=[{ name: "connector1",targetPoint: { x: 450, y: 150 }}];
* $("#diagramcontent").ejDiagram({connectors:connectors});
* &lt;/script&gt
* @alias ejDiagram#connectors->targetPoint
* @memberof ejDiagram
* @instances
*/
        targetPoint: ej.datavisualization.Diagram.Point(),
        /**Sets the color of the connector
          * @default black
          * @type {String}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var connectors = [];
          * connectors=[{lineColor:"blue"}];
          * $("#diagramcontent").ejDiagram({connectors:connectors});
          * &lt;/script&gt
              * @alias ejDiagram#connectors->lineColor
          * @memberof ejDiagram
          * @instance
          */
        lineColor: "black",
        /**Sets the width of the line
          * @default 1
          * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var connectors = [];
          * connectors=[{lineWidth:4}];
          * $("#diagramcontent").ejDiagram({connectors:connectors});
          * &lt;/script&gt
              * @alias ejDiagram#connectors->lineWidth
          * @memberof ejDiagram
          * @instance
          */
        lineWidth: 1,
        /** Enables or disables the behaviour of connector see{@link ConnectorConstraints}
          * @default ConnectorConstraints.Default
          * @type {Constraints}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var connectors = [];
          * connectors=[{constraints: ej.datavisualization.Diagram.ConnectorConstraints.Select}];
          * $("#diagramcontent").ejDiagram({connectors:connectors});
          * &lt;/script&gt
              * @alias ejDiagram#connectors->constraints
          * @memberof ejDiagram
          * @instance
          */
        constraints: ej.datavisualization.Diagram.ConnectorConstraints.Default,
        /**The transparency of the connector
          * @default 1
          * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var connectors = [];
          * connectors=[{opacity:0.6}];
          * $("#diagramcontent").ejDiagram({connectors:connectors});
          * &lt;/script&gt
              * @alias ejDiagram#connectors->opacity
          * @memberof ejDiagram
          * @instance
          */
        opacity: 1,
        /**parent name of the connector
              * @default ""
              * @type {String}
              * @example
              * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
              * &lt;script&gt;
              * var connector = [ {name: "rect",parent:"group1"}];
              * &lt;/script&gt
              * @alias ejDiagram#connectors->parent
              * @memberof ejDiagram
              * @instance
              */
        parent: "",

        /**The labels property of connectors
                * @default ""
                * @type {Array}
                * @example
                * Refer nodes label for label properties details <br>
                
                * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
                * &lt;script&gt;
                * var label = [];
                * label = [{ "text": "Connector1", "fontColor": "Red"}];
                * $("#diagramcontent").ejDiagram({label:label});
                * &lt;/script&gt
                * @alias ejDiagram#connectors->labels
                * @memberof ejDiagram
                * @instance
                */
        labels: [],
        /** Zorder of the connector
          * @default 0
          * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var connectors= [];
          * connectors=[{connectors: 1}];
          * $("#diagramcontent").ejDiagram({connectors:connectors});
          * &lt;/script&gt
              * @alias ejDiagram#connectors->zOrder
          * @memberof ejDiagram
          * @instance
          */
        zOrder: 0,
        /** The padding added to the line to detect line during interaction
          * @default 10
          * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var connectors= [];
          * connectors=[{lineHitPadding: 30}];
          * $("#diagramcontent").ejDiagram({connectors:connectors});
          * &lt;/script&gt
              * @alias ejDiagram#connectors->lineHitPadding
          * @memberof ejDiagram
          * @instance
          */
        lineHitPadding: 10,
        /**To provide/save extra information about Node
          * @default null
          * @type {Object}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var connectors = [];
          * var addInfo = {Name1:"Connector1",Connector2:"Connector3"}
          * connectors=[{addInfo: addInfo}];
          * $("#diagramcontent").ejDiagram({connectors:connectors});
          * &lt;/script&gt
              * @alias ejDiagram#connectors->addInfo
          * @memberof ejDiagram
          * @instance
          */
        addInfo: {},
        /** The target node of the connector
          * @default null
          * @type {Object}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes =[];
          * var connectors = [];
          * nodes = {name: "openBrowses", width: 175, height: 60};
          * connectors=[{targetNode: "openBrowses"}];
          * $("#diagramcontent").ejDiagram({connectors:connectors});
          * &lt;/script&gt
              * @alias ejDiagram#connectors->targetNode
          * @memberof ejDiagram
          * @instance
          */
        targetNode: null,
        /** The targetPort of the connector
          * @default null
          * @type {Object}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * var ports = [];
          * var connectors = [];
          * nodes = {name: "openBrowses", width: 175, height: 60};
          * ports = { offset: { x: 0, y: 0.5 }, name: "aport" };
          * connectors=[{targetPort: "aport"}];
          * $("#diagramcontent").ejDiagram({connectors:connectors});
          * &lt;/script&gt
              * @alias ejDiagram#connectors->targetPort
          * @memberof ejDiagram
          * @instance
          */
        targetPort: null,
        /** The sourceNode of the connector
          * @default null
          * @type {Object}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * var connectors = [];
          * nodes = {name: "openBrowses", width: 175, height: 60};
          * connectors=[{sourceNode: "openBrowses"}];
          * $("#diagramcontent").ejDiagram({connectors:connectors});
          * &lt;/script&gt
              * @alias ejDiagram#connectors->sourceNode
          * @memberof ejDiagram
          * @instance
          */
        sourceNode: null,
        /** The sourcePort of the connector
          * @default null
          * @type {Object}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * var ports = [];
          * var connectors = [];
          * nodes = {name: "openBrowses", width: 175, height: 60};
          * ports = { offset: { x: 0, y: 0.5 }, name: "bport" };
          * connectors=[{sourcePort: "bport"}];
          * $("#diagramcontent").ejDiagram({connectors:connectors});
          * &lt;/script&gt
              * @alias ejDiagram#connectors->sourcePort
          * @memberof ejDiagram
          * @instance
          */
        sourcePort: null,
        /** To set margin left for the connector.Applicable if the parent is group.
         * @default ""
         * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var connectors = [];
          * connectors=[{name:"connector",marginLeft: 1}];
          * $("#diagramcontent").ejDiagram({connectors:connectors});
          * &lt;/script&gt
          * @alias ejDiagram#connectors->marginLeft
          * @memberof ejDiagram
          * @instance
         */
        marginLeft: 0,
        /** To set top margin for the connector.Applicable if the parent is group.
        * @default 0
        * @type {Int}
         * @example
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         * &lt;script&gt;
         * var connectors = [];
         * connectors=[{marginTop: 1}];
         * $("#diagramcontent").ejDiagram({connectors:connectors});
         * &lt;/script&gt
         * @alias ejDiagram#connectors->marginTop
         * @memberof ejDiagram
         * @instance
        */
        marginTop: 0,
        /** To set right margin for the connector.Applicable if the parent is group.
        * @default 0
        * @type {Int}
         * @example
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         * &lt;script&gt;
         * var connectors = [];
         * connectors=[{marginRight: 1}];
         * $("#diagramcontent").ejDiagram({connectors:connectors});
         * &lt;/script&gt
         * @alias ejDiagram#connectors->marginRight
         * @memberof ejDiagram
         * @instance
        */
        marginRight: 0,
        /** To set margin bottom for the connector.Applicable if the parent is group.
     * @default 0
     * @type {Int}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var connectors = [];
      * connectors=[{marginBottom: 1}];
      * $("#diagramcontent").ejDiagram({connectors:connectors});
      * &lt;/script&gt
      * @alias ejDiagram#connectors->marginBottom
      * @memberof ejDiagram
      * @instance
     */
        marginBottom: 0,
        /** To set the horizontal alignment for connector.Applicable if the parent is group.
         * @default HorizontalAlignment.Left
         * @type {HorizontalAlignment}
         * @example
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         * &lt;script&gt;
         * var connectors = [];
         * connectors=[{HorizontalAlignment: ej.datavisualization.Diagram.HorizontalAlignment.Left}];
         * $("#diagramcontent").ejDiagram({connectors:connectors});
         * &lt;/script&gt
         * @alias ejDiagram#nodes->horizontalAlign
         * @memberof ejDiagram
         * @instance
         */
        horizontalAlign: ej.datavisualization.Diagram.HorizontalAlignment.Left,
        /** To set the vertical alignment for connector.Applicable if the parent is group.
        * @default VerticalAlignment.Top
        * @type {VerticalAlignment}
        * @example
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * var connectors = [];
        * connectors=[{VerticalAlignment: ej.datavisualization.Diagram.VerticalAlignment.Top}];
        * $("#diagramcontent").ejDiagram({connectors:connectors});
        * &lt;/script&gt
        * @alias ejDiagram#nodes->verticalAlign
        * @memberof ejDiagram
        * @instance
        */
        verticalAlign: ej.datavisualization.Diagram.VerticalAlignment.Top,
        /** Defines the radius of the rounded corner
        * @default 0
        * @type {Integer}
        * @example
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * var connectors=[];
        * connectors=[{cornerRadius:2}];
        * $("#diagramcontent").ejDiagram({connectors:connectors});
        * &lt;/script&gt
      * @alias ejDiagram#connectors->cornerRadius
        * @memberof ejDiagram
        * @instance
        */
        cornerRadius: 0,
        /** Defines the bridge spacing of the connector
       * @default 0
       * @type {Integer}
       * @example
       * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
       * &lt;script&gt;
       * var connectors=[];
       * connectors=[{bridgeSpace:15}];
       * $("#diagramcontent").ejDiagram({connectors:connectors});
       * &lt;/script&gt
     * @alias ejDiagram#connectors->bridgeSpace
       * @memberof ejDiagram
       * @instance
       */
        bridgeSpace: 10,

        /** Defines the space between node and connector's source point 
       * @default 0
       * @type {Integer}
       * @example
       * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
       * &lt;script&gt;
       * var connectors=[];
       * connectors=[{sourcePadding:5}];
       * $("#diagramcontent").ejDiagram({connectors:connectors});
       * &lt;/script&gt
       * @alias ejDiagram#connectors->sourcePadding
       * @memberof ejDiagram
       * @instance
       */
        sourcePadding: 0,
        /** Defines the space between node and connector's target point 
       * @default 0
       * @type {Integer}
       * @example
       * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
       * &lt;script&gt;
       * var connectors=[];
       * connectors=[{targetPadding:5}];
       * $("#diagramcontent").ejDiagram({connectors:connectors});
       * &lt;/script&gt
       * @alias ejDiagram#connectors->targetPadding
       * @memberof ejDiagram
       * @instance
       */
        targetPadding: 0
    };
    ej.datavisualization.Diagram.Connector = function (options) {
        options.targetDecorator = ej.datavisualization.Diagram.Decorator(options.targetDecorator || {});
        options.sourceDecorator = ej.datavisualization.Diagram.Decorator(options.sourceDecorator || { shape: ej.datavisualization.Diagram.DecoratorShapes.None });
        options.segments = options.segments || [ej.datavisualization.Diagram.Segment({ type: "straight" })];
        if (options.segments.length) {
            options.sourcePoint = options.sourcePoint || ej.datavisualization.Diagram.Point();
            options.targetPoint = options.targetPoint || ej.datavisualization.Diagram.Point();
            ej.datavisualization.Diagram.Util._initializeSegments(options, options.defaultType);
        }
        if (options.labels)
            for (var i = 0; i < options.labels.length; i++) {
                options.labels[i] = ej.datavisualization.Diagram.Label(options.labels[i]);
            }
        return $.extend(true, {}, ej.datavisualization.Diagram.ConnectorDefaults, options);
    };
    //#endregion

    // /**
    //* @namespace ej
    //* @class ejDiagram.Container    
    //* @classdesc Container is a container of Nodes and Connectors as a single entity
    //* @example 
    //* &lt;div id="diagram"&gt;&lt;/div&gt;<br>
    //* &lt;script&gt;
    //* //Create Diagram
    //$("#diagram").ejDiagram();
    //* &lt;/script&gt
    //*/
    //#region Container
    ej.datavisualization.Diagram.ContainerDefaults = {
        /**To indicate the container type.Applicable if the group as container.
        * @default "Canvas"
          * @type {string}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var container = ej.datavisualization.Diagram.ContainerType.Canvas
          * container.type = "linear; 
          * var nodes = [{name:"Node1",container : container}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->container->type
          * @memberof ejDiagram
          * @instance
        */
        type: ej.datavisualization.Diagram.ContainerType.Canvas,
        /**To indicate the container orientation.Applicable if the group as container.
        * @default "vertical"
         * @type {string}
         * @example
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         * &lt;script&gt;
         * var container = ej.datavisualization.Diagram.ContainerType.Canvas
         * container.orientation = "vertical; 
         * var nodes = [{name:"Node1",container : container}];
         * $("#diagramcontent").ejDiagram({nodes:nodes});
         * &lt;/script&gt
         * @alias ejDiagram#nodes->container->orientation
         * @memberof ejDiagram
         * @instance
       */
        orientation: "vertical",
    };
    ej.datavisualization.Diagram.Container = function (options) {
        return $.extend(true, {}, ej.datavisualization.Diagram.ContainerDefaults, options);
    };
    // #endregion
    // /**
    //* @namespace ej
    //* @class ejDiagram.Group    
    //* @classdesc Group is a container of Nodes and Connectors as a single entity
    //* @example 
    //* &lt;div id="diagram"&gt;&lt;/div&gt;<br>
    //* &lt;script&gt;
    //* //Create Diagram
    //$("#diagram").ejDiagram();
    //* &lt;/script&gt
    //*/
    //#region Group
    ej.datavisualization.Diagram.GroupDefaults = {
        /** Collection of children in group node
    * @default ""
    * @type {Array}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var nodes = [];
    * var children = ["Node1","Node2"];
    * nodes=[{name:"GroupNode",children:children}];
    * $("#diagramcontent").ejDiagram({nodes:nodes});
    * &lt;/script&gt
     * @alias ejDiagram#nodes->children
    * @memberof ejDiagram
    * @instance
    */
        children: [],
        /**This is used to set whether we can ungroup the group or not
          * @default true
          * @type {Boolean}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * var children = ["Node1","Node2"];
          * nodes=[{name:"GroupNode",children:children,canUngroup:false}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
           * @alias ejDiagram#nodes->canUngroup
          * @memberof ejDiagram
          * @instance
          */
        canUngroup: true,
        /** To indicating whether this element can be used as the target of a drop operation. Applicable if the type is group.
           * @default true
           * @type {Boolean}
           * @example
           * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
           * &lt;script&gt;
           * var nodes = [];
           * nodes=[{name:"GroupNode",allowDrop:true}];
           * $("#diagramcontent").ejDiagram({nodes:nodes});
           * &lt;/script&gt
            * @alias ejDiagram#nodes->allowDrop
           * @memberof ejDiagram
           * @instance
           */
        allowDrop: true,
        /** To indicating whether this element can be used as container.Applicable only if the object as Group.
          * @default null
          * @type {obj}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{name:"GroupNode",container:{}}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
           * @alias ejDiagram#nodes->container
          * @memberof ejDiagram
          * @instance
          */
        container: null,
        /** To set padding left value for the group.
         * @default 0
         * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{paddingLeft: 1}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->paddingLeft
          * @memberof ejDiagram
          * @instance
         */
        paddingLeft: 0,
        /** To set Top padding value for the group. Applicable if the type is group.
       * @default 0
       * @type {Int}
        * @example
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * var nodes = [];
        * nodes=[{paddingTop: 1}];
        * $("#diagramcontent").ejDiagram({nodes:nodes});
        * &lt;/script&gt
        * @alias ejDiagram#nodes->paddingTop
        * @memberof ejDiagram
        * @instance
       */
        paddingTop: 0,
        /** To set Right padding value for the group. Applicable if the type is group.
     * @default 0
     * @type {Int}
      * @example
      * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * var nodes = [];
      * nodes=[{paddingRight: 1}];
      * $("#diagramcontent").ejDiagram({nodes:nodes});
      * &lt;/script&gt
      * @alias ejDiagram#nodes->paddingRight
      * @memberof ejDiagram
      * @instance
     */
        paddingRight: 0,
        /** To set bottom padding value for the group. Applicable if the type is group.
   * @default 0
   * @type {Int}
    * @example
    * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
    * &lt;script&gt;
    * var nodes = [];
    * nodes=[{paddingBottom: 1}];
    * $("#diagramcontent").ejDiagram({nodes:nodes});
    * &lt;/script&gt
    * @alias ejDiagram#nodes->paddingBottom
    * @memberof ejDiagram
    * @instance
   */
        paddingBottom: 0,
        /** To set minimum width for the node. Applicable if the type is group.
         * @default 0
         * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{minWidth: 1}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->minWidth
          * @memberof ejDiagram
          * @instance
         */
        minWidth: 0,
        /** To set maximum width for the group. Applicable if the type is group.
         * @default 0
         * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{maxWidth: 1}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->maxWidth
          * @memberof ejDiagram
          * @instance
         */
        maxWidth: 0,
        /** To set minimum height for the group. Applicable if the type is group.
         * @default 0
         * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{minHeight: 1}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->minHeight
          * @memberof ejDiagram
          * @instance
         */
        minHeight: 0,
        /** To set maximum height for the group. Applicable if the type is group.
         * @default 0
         * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var nodes = [];
          * nodes=[{maxHeight: 1}];
          * $("#diagramcontent").ejDiagram({nodes:nodes});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->maxHeight
          * @memberof ejDiagram
          * @instance
         */
        maxHeight: 0,
        type: "group",
    };
    ej.datavisualization.Diagram.Group = function (options) {
        options = options ? options : null;
        options.minWidth = options.minWidth ? options.minWidth : 0;
        options.minHeight = options.minHeight ? options.minHeight : 0;
        options.maxWidth = options.maxWidth ? options.maxWidth : 0;
        options.maxHeight = options.maxHeight ? options.maxHeight : 0;
        options.container = options.container ? ej.datavisualization.Diagram.Container(options.container) : null;
        options.fillColor = options.fillColor ? options.fillColor : "transparent";
        options.borderColor = options.borderColor ? options.borderColor : "transparent";
        return $.extend(true, {}, ej.datavisualization.Diagram.NodeDefaults, ej.datavisualization.Diagram.GroupDefaults, ej.datavisualization.Diagram.NodeBase(options));
    };
    //#endregion

    //#region ZoomCommand
    ej.datavisualization.Diagram.ZoomCommand = {
        ///** ZoomIn operation assigns the value to ,which operation is to be performed
        //  * @default 1
        //  * @type {Int}
        //  * @example
        //  * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        //  * &lt;script&gt;
        //  * var zoom = ZoomCommand.ZoomIn;
        //  * &lt;/script&gt
        //  * @memberof ejDiagram
        //  * @instance
        //  */
        ZoomIn: 1,
        ///** ZoomOut operation assigns the value to ,which operation is to be performed
        // * @default 2
        // * @type {Int}
        // * @example
        // * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        // * &lt;script&gt;
        // * var zoom = ZoomCommand.ZoomOut;
        // * &lt;/script&gt
        // * @memberof ejDiagram
        // * @instance
        // */
        ZoomOut: 2
    };
    ej.datavisualization.Diagram.Zoom = function (options) {
        return $.extend(true, {}, { zoomFactor: 0.2, focusPoint: null, zoomCommand: ej.datavisualization.Diagram.ZoomCommand.ZoomIn }, options);
    };
    //#endregion

    /**
* Enum for the DiagramConstraints in diagram	 
* @enum {DiagramConstraints}
* @global 
*/
    ej.datavisualization.Diagram.DiagramConstraints = {
        /**Disables all  DiagramConstraints */
        None: 1 << 0,
        /**Enables/Disables PageEditing */
        PageEditable: 1 << 1,
        /**Enables/Disables Bridging */
        Bridging: 1 << 2,
        /**Enables/Disables Zooming*/
        Zoomable: 1 << 3,
        /**Enables/Disables panning on horizontal axis */
        PannableX: 1 << 4,
        /**Enables/Disables panning on vertical axis */
        PannableY: 1 << 5,
        /**Enables/Disables Panning */
        Pannable: 1 << 4 | 1 << 5,
        /**Enables/Disables undo actions */
        Undoable: 1 << 6,
        /**Enables all Constraints */
        Default: 1 << 1 | 1 << 3 | 1 << 4 | 1 << 5 | 1 << 6
    };

    //#endregion
    /**
* Enum for the Tool in diagram	 
* @enum {Tool}
* @global 
*/
    ej.datavisualization.Diagram.Tool = {
        /**Disables all Tools */
        None: 1 << 0,
        /**Enables/Disables SingleSelect tool */
        SingleSelect: 1 << 1,
        /**Enables/Disables MultiSelect tool */
        MultipleSelect: 1 << 2,
        /**Enables/Disables ZoomPan tool*/
        ZoomPan: 1 << 3,
        /**Enables/Disables DrawOnce tool*/
        DrawOnce: 1 << 4,
        /**Enables/Disables ContinuousDraw tool*/
        ContinuesDraw: 1 << 5
    };
    //#endregion
    /**
* Enum to specify the ConnectorType in diagram	 
* @enum {ConnectorType}
* @global 
*/
    ej.datavisualization.Diagram.ConnectorType = {
        /** Enables/Disables straight line drawing tool*/
        StraightLine: "straightLine",
        /**Enables/Disables orthogonal line drawing tool*/
        OrthogonalLine: "orthogonalLine"
    };

    //  /**
    //* @namespace ej
    //* @class  ejDiagram.UserHandle    
    //* @classdesc Some frequently used commands can be added around the selector though user handles.
    //* @example 
    //* &lt;div id="diagram"&gt;&lt;/div&gt;<br>
    //* &lt;script&gt;
    //* //Create Diagram
    //$("#diagram").ejDiagram();
    //* &lt;/script&gt
    //*/
    //#region UserHandle
    ej.datavisualization.Diagram.UserHandleDefaults = {
        /** The name of the user handles
          * @default ""
          * @type {String}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var userHandles = ej.datavisualization.Diagram.UserHandle();
          * userHandles.name = "Clone";
          * $("#diagramcontent").ejDiagram({userHandles:userHandles});
          * &lt;/script&gt
          * @memberof ejDiagram.UserHandle 
          * @instance
          */
        name: "",
        /** To customize the userhandles shape using path data
          * @default ""
          * @type {String}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var userHandles = ej.datavisualization.Diagram.UserHandle();
          * userHandles.pathData = "M4.6350084,4.8909971 L4.6350084,9.3649971 9.5480137,9.3649971 9.5480137,4.8909971 z M3.0000062,2.8189973 L11.184016,2.8189973 11.184016,10.999997 3.0000062,10.999997 z M0,0 L7.3649998,0 7.3649998,1.4020001 1.4029988,1.4020001 1.4029988,8.0660002 0,8.0660002 0,1.4020001 0,0.70300276 z";
          * $("#diagramcontent").ejDiagram({userHandles:userHandles});
          * &lt;/script&gt
          * @memberof ejDiagram.UserHandle 
          * @instance
          */
        pathData: "",
        /** The border color of user handles
          * @default ""
          * @type {String}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var userHandles = ej.datavisualization.Diagram.UserHandle();
          * userHandles.borderColor = "red";
          * $("#diagramcontent").ejDiagram({userHandles:userHandles});
          * &lt;/script&gt
          * @memberof ejDiagram.UserHandle 
          * @instance
          */
        borderColor: "",
        /**The background color of user handle
          * @default #2382c3
          * @type {String}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var userHandles = ej.datavisualization.Diagram.UserHandle();
          * userHandles.backgroundColor = "red";
          * $("#diagramcontent").ejDiagram({userHandles:userHandles});
          * &lt;/script&gt
          * @memberof ejDiagram.UserHandle 
          * @instance
          */
        backgroundColor: "#2382c3",
        /** The Position of user handles to be updated See {@link Position}
          * @name Position
          * @default ej.datavisualization.Diagram.UserHandlePositions.BottomCenter
          * @type {enum}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var userHandles = ej.datavisualization.Diagram.UserHandle();
          * userHandles.position = ej.datavisualization.Diagram.UserHandlePositions.BottomLeft;
          * $("#diagramcontent").ejDiagram({userHandles:userHandles});
          * &lt;/script&gt
          * @memberof ejDiagram.UserHandle 
          * @instance
          */
        position: ej.datavisualization.Diagram.UserHandlePositions.BottomCenter,
        /** Customize the color of user handles
          * @default white
          * @type {String}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var userHandles = ej.datavisualization.Diagram.UserHandle();
          * userHandles.pathColor = "red";
          * $("#diagramcontent").ejDiagram({userHandles:userHandles});
          * &lt;/script&gt
          * @memberof ejDiagram.UserHandle 
          * @instance
          */
        pathColor: "white",
        /**The tool to be used as a user handle
          * @default ""
          * @type {String}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var userHandles = ej.datavisualization.Diagram.UserHandle();
          * userHandles.tool = new CloneTool(cloneHandle.name);
          * function CloneTool(name) { base.call(this, name);this.singleAction = true;} //Properties can be modified
          * $("#diagramcontent").ejDiagram({userHandles:userHandles});
          * &lt;/script&gt
          * @memberof ejDiagram.UserHandle 
          * @instance
          */
        tool: "",
        /**The size of the tool
          * @default 20
          * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var userHandles = ej.datavisualization.Diagram.UserHandle();
          * userHandles.size = 30;
          * $("#diagramcontent").ejDiagram({userHandles:userHandles});
          * &lt;/script&gt
          * @memberof ejDiagram.UserHandle 
          * @instance
          */
        size: 20,
        /**Enables or disables the visibility of the user handle
          * @default true
          * @type {Boolean}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var userHandles = ej.datavisualization.Diagram.UserHandle();
          * userHandles.visibility = false;
          * $("#diagramcontent").ejDiagram({userHandles:userHandles});
          * &lt;/script&gt
          * @memberof ejDiagram.UserHandle 
          * @instance
          */
        visible: true,
        /** The functionality to enables or disables the multiple selection
          * @default false
          * @type {Boolean}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var userHandles = ej.datavisualization.Diagram.UserHandle();
          * userHandles.enableMultiSelection = false;
          * $("#diagramcontent").ejDiagram({userHandles:userHandles});
          * &lt;/script&gt
          * @memberof ejDiagram.UserHandle 
          * @instance
          */
        enableMultiSelection: false
    };
    ej.datavisualization.Diagram.UserHandle = function (options) {
        return $.extend(true, {}, ej.datavisualization.Diagram.UserHandleDefaults, options);
    };
    //#endregion
    //#region Swimlane
    ej.datavisualization.Diagram.SwimLaneDefaults = {
        /** The header of the swimlane . Applicable if the type is group.
          * @default "Null"
          * @type {obj}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * $("#diagramcontent").ejDiagram({nodes:{type: "swimlane",name: "swimlane",  header: {text: "Header", width:50}}});
          * &lt;/script&gt
           * @alias ejDiagram#nodes->header
          * @memberof ejDiagram
          * @instance
          */
        header: {
            /** Used to specify the width of the swimlane header*/
            width: 30,
            /** Used to specify the text of the swimlane header*/
            text: "",
        },
        /** The color to be filled inside the swimlane. Applicable if type is swimlane.
          * @default "White"
          * @type {String}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
           * $("#diagramcontent").ejDiagram({nodes:{type: "swimlane",name: "swimlane",  fillColor: "red"}});
          * &lt;/script&gt
           * @alias ejDiagram#nodes->fillColor
          * @memberof ejDiagram
          * @instance
          */
        fillColor: "transparent",
        /** The orientation type of the swimlane. Applicable if type is swimlane.
          * @default "vertical"
          * @type {String}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
           * $("#diagramcontent").ejDiagram({nodes:{type: "swimlane",name: "swimlane",  orientation: "vertical"}});
          * &lt;/script&gt
           * @alias ejDiagram#nodes->orientation
          * @memberof ejDiagram
          * @instance
          */
        orientation: "vertical",
        type: "group",
        /** Indicates class as swimlane. Applicable if type is swimlane.
          * @default true
          * @type {Boolean}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt; 
          * $("#diagramcontent").ejDiagram({nodes:{type: "swimlane",name: "swimlane",  isSwimlane: true}});
          * &lt;/script&gt
           * @alias ejDiagram#nodes->isSwimlane
          * @memberof ejDiagram
          * @instance
          */
        isSwimlane: true,
        /** Align swimlane position along X-axis. Applicable if type is swimlane.
          * @default 0
          * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt; 
          * $("#diagramcontent").ejDiagram({nodes:{type: "swimlane",name: "swimlane",offsetX:100}});
          * &lt;/script&gt
           * @alias ejDiagram#nodes->offsetX
          * @memberof ejDiagram
          * @instance
          */
        offsetX: 100,
        /** Align swimlane position along Y-axis. Applicable if type is swimlane.
         * @default 0
         * @type {Int}
         * @example
         * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
         * &lt;script&gt; 
         * $("#diagramcontent").ejDiagram({nodes:{type: "swimlane",name: "swimlane",offsetY:100}});
         * &lt;/script&gt
          * @alias ejDiagram#nodes->offsetY
         * @memberof ejDiagram
         * @instance
         */
        offsetY: 100,
        /** To set minimum height for the swimlane. Applicable if type is swimlane.
         * @default 0
         * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
         * $("#diagramcontent").ejDiagram({nodes:{type: "swimlane",name: "swimlane",minHeight:100}});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->minHeight
          * @memberof ejDiagram
          * @instance
         */
        minHeight: 100,
        /** To set maximum height for the swimlane. Applicable if type is swimlane.
         * @default 0
         * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * $("#diagramcontent").ejDiagram({nodes:{type: "swimlane",name: "swimlane",maxHeight:100}});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->maxHeight
          * @memberof ejDiagram
          * @instance
         */
        maxHeight: 100,
        /** To set minimum width for the swimlane. Applicable if type is swimlane.
         * @default 0
         * @type {Int}
        * @example
        * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * $("#diagramcontent").ejDiagram({nodes:{type: "swimlane",name: "swimlane",minWidth:100}});
        * &lt;/script&gt
        * @alias ejDiagram#nodes->minWidth
        * @memberof ejDiagram
        * @instance
         */
        minWidth: 100,
        /** To set maximum width for the swimlane. Applicable if type is swimlane.
         * @default 0
         * @type {Int}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt; 
          * $("#diagramcontent").ejDiagram({nodes:{type: "swimlane",name: "swimlane",maxWidth:100}});
          * &lt;/script&gt
          * @alias ejDiagram#nodes->maxWidth
          * @memberof ejDiagram
          * @instance
         */
        maxWidth: 100,
        /** Collection of Lanes in swimlane. Applicable if type is swimlane.
           * @default []
          * @type {Array}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var lanes = []; 
          * lanes=[{["Lane1","Lane1"]}];
          * $("#diagramcontent").ejDiagram( );
          * var nodes = [ {type: "swimlane",name: "swimlane",lanes: []}
          * &lt;/script&gt
           * @alias ejDiagram#nodes->lanes
          * @memberof ejDiagram
          * @instance
          */
        lanes: [],
        /** Collection of phases in swimlane node. Applicable if type is swimlane.
          * @default []          
          * @type {Array}
          * @example
          * &lt;div id="diagramcontent"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * var phases = []; 
          * phases=[{["phase1","phase2"]}];
          * $("#diagramcontent").ejDiagram( );
          * var nodes = [ {type: "swimlane",name: "swimlane",phases: []}
          * &lt;/script&gt
           * @alias ejDiagram#nodes->phases
          * @memberof ejDiagram
          * @instance
          */
        phases: [],
    };
    ej.datavisualization.Diagram.SwimLane = function (options) {
        return $.extend(true, {}, ej.datavisualization.Diagram.SwimLaneDefaults, options);
    };
    //#endregion  
    //#region Lane
    ej.datavisualization.Diagram.LaneDefaults = {
        header: { width: 30, text: "", }, name: "", children: [], isLane: true, orientation: "horizontal",
    };
    ej.datavisualization.Diagram.Lane = function (options) {
        return $.extend(true, {}, ej.datavisualization.Diagram.LaneDefaults, options);
    };
    //#endregion  
    //#region phase
    ej.datavisualization.Diagram.phaseDefaults = {
        name: "", type: "phase", offset: 0, lineWidth: 1, lineDashArray: "", lineColor: "black", parent: "", orientation: "",
    };
    ej.datavisualization.Diagram.phase = function (options) {
        return $.extend(true, {}, ej.datavisualization.Diagram.phaseDefaults, options);
    };
    //#endregion 
    ej.datavisualization.Diagram.SwimLaneHelper = {
        //#region diagram
        _initSwimLane: function (obj, diagram, headAdded) {
            var canvas = null;
            var lanes = null;
            var phases = this._initphases(obj, diagram);
            lanes = this._initLanes(obj, diagram, headAdded);
            var childern = [];
            var header = null;
            if (!obj.header) {
                obj.header = { text: "", height: 0, fillColor: "white" };
            }
            if (obj.orientation == "vertical") {
                var height = obj.header.height;
            } else {
                var width = obj.header.width;

            }
            if (obj.header) {
                header = ej.datavisualization.Diagram.Node({
                    type: "node",
                    name: obj.name + "_header_swimlane",
                    labels: [
                        {
                            text: obj.header.text ? obj.header.text : "",
                            offset: { x: 0.5, y: .5 },
                            fontColor: obj.header.fontColor ? obj.header.fontColor : "black",
                            fontSize: obj.header.fontSize ? obj.header.fontSize : 11,
                            fontFamily: obj.header.fontFamily ? obj.header.fontFamily : "Arial",
                            bold: obj.header.bold ? obj.header.bold : false,
                            italic: obj.header.italic ? obj.header.italic : false,
                            textDecoration: obj.header.textDecoration ? obj.header.textDecoration : "none",
                        },
                    ],
                    height: height ? height : 50,
                    width: width ? width : 50,
                    fillColor: obj.header.fillColor ? obj.header.fillColor : "white",
                    rotateAngle: 0,
                    constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Select ^ ej.datavisualization.Diagram.NodeConstraints.Connect,
                    horizontalAlign: "stretch",
                    parent: obj.name,
                });
            }

            if (header) {
                diagram.nodes().push(header);
                diagram.nameTable[header.name] = header;
                childern.push(header.name);
            }

            var hAlign = null, vAlign = null;
            if (obj.orientation == "vertical")
                vAlign = "stretch";
            else
                hAlign = "stretch";

            var orientation;
            if (obj.orientation == "horizontal")
                orientation = "vertical";
            else
                orientation = "horizontal";


            var stack = ej.datavisualization.Diagram.Group({
                name: obj.name + "_stack",
                children: lanes,
                parent: obj.name,
                container: { type: ej.datavisualization.Diagram.ContainerType.Stack, orientation: orientation },
                horizontalAlign: "stretch",
                verticalAlign: "stretch",
                marginTop: obj.header ? obj.header.height : 50,
                width: 10,
                height: 10,

            });

            //if (obj.orientation == "horizontal") {
            //    stack.minHeight = 250;

            //}

            var cW = 0, cH = 0;
            if (obj.orientation == "horizontal") {
                cW = obj.width;
                cH = obj.height;

            }
            else if (obj.orientation == "vertical") {
                cW = obj.width;
                cH = obj.height + header.height;
            }
            diagram.nodes().push(stack);
            diagram.nameTable[stack.name] = stack;
            childern.push(stack.name);
            canvas = ej.datavisualization.Diagram.Group({
                name: obj.name ? obj.name : "",
                type: "group",
                parent: "",
                offsetX: obj.offsetX ? obj.offsetX : 100,
                offsetY: obj.offsetY ? obj.offsetY : 100,
                children: childern,
                fillColor: "transparent",
                container: { type: ej.datavisualization.Diagram.ContainerType.Canvas, },
                minHeight: cH ? cH - header.height : 100,
                maxHeight: obj.maxHeight ? obj.maxHeight : 1000,
                minWidth: cW ? cW : 100,
                maxWidth: obj.maxWidth ? obj.maxWidth : 1000,
                constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.ResizeNorth ^
                      ej.datavisualization.Diagram.NodeConstraints.ResizeWest ^ ej.datavisualization.Diagram.NodeConstraints.ResizeNorthWest ^
                  ej.datavisualization.Diagram.NodeConstraints.ResizeNorthEast ^ ej.datavisualization.Diagram.NodeConstraints.ResizeSouthWest,
            });
            canvas.isSwimlane = true;
            //this.nodes().push(canvas);
            canvas.phases = phases;
            canvas.orientation = obj.orientation;
            return canvas;
        },
        _initLanes: function (obj, diagram, headAdded) {
            var lanes = [], lane = null;
            if (obj.lanes) {
                for (var i = 0; i < obj.lanes.length; i++) {
                    obj.lanes[i]._laneHeader = obj.lanes[i]._laneHeader ? obj.lanes[i]._laneHeader : obj.lanes[i].header
                    lane = this._initLane(obj.lanes[i], obj, diagram, headAdded);
                    lanes.push(lane.name);
                    diagram.nodes().push(lane);
                    diagram.nameTable[lane.name] = lane;
                }
            }
            return lanes;
        },
        _initLane: function (laneobj, obj, diagram, headAdded) {
            var hAlign = null, vAlign = null;
            if (obj.orientation == "horizontal")
                hAlign = "stretch";
            else vAlign = "stretch";
            var success = false;
            var lane = ej.datavisualization.Diagram.Group({
                name: laneobj.name,
                type: "group",
                isLane: true,
                parent: obj.name + "_stack",
                offsetX: 0,
                offsetY: 0,
                borderColor: laneobj.borderColor ? laneobj.borderColor : "black",
                orientation: obj.orientation ? obj.orientation : "horizontal",
                fillColor: laneobj.fillColor,
                container: { type: ej.datavisualization.Diagram.ContainerType.Canvas, },
                horizontalAlign: hAlign ? hAlign : "left",
                verticalAlign: vAlign ? vAlign : "top",
                minHeight: laneobj.height ? laneobj.height : 100,
                maxHeight: laneobj.maxHeight ? laneobj.maxHeight : 1000,
                minWidth: laneobj.width ? laneobj.width : 100,
                maxWidth: laneobj.maxWidth ? laneobj.maxWidth : 1000,
                paddingTop: 20,
                paddingRight: 20,
                paddingBottom: 20,
                paddingLeft: 20,
                constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.ResizeNorth ^
                        ej.datavisualization.Diagram.NodeConstraints.ResizeWest ^ ej.datavisualization.Diagram.NodeConstraints.ResizeNorthWest ^
                    ej.datavisualization.Diagram.NodeConstraints.ResizeNorthEast ^ ej.datavisualization.Diagram.NodeConstraints.ResizeSouthWest ^
                     ej.datavisualization.Diagram.NodeConstraints.Connect,
            });
            if (!headAdded) {
                var laneHeader = laneobj._laneHeader ? laneobj._laneHeader : null;
                var header = this._iniLaneHeader(laneobj, lane.name, obj, diagram, laneHeader);
                if (header) {
                    diagram.nodes().push(header);
                    diagram.nameTable[header.name] = header;
                    lane.children.push(header.name);
                }
            }
            var laneChildren;
            laneChildren = this._initChildren(laneobj, lane.name, diagram);
            for (var i = 0; i < laneChildren.length; i++) {
                lane.children.push(laneChildren[i]);
            }

            return lane;
        },
        _iniLaneHeader: function (headObj, parentName, obj, diagram, laneHeader) {
            var node = null;
            if (headObj.header) {
                node = ej.datavisualization.Diagram.Node({
                    name: parentName + headObj.header.text + "_Headerr_",
                    type: "node",
                    labels: [
                    {
                        text: headObj.header.text ? headObj.header.text : "", offset: { x: 0.5, y: .5 }, width: 100, rotateAngle: 270, marginLeft: -10,
                        fontColor: headObj.header.fontColor ? headObj.header.fontColor : "black",
                        fontSize: headObj.header.fontSize ? headObj.header.fontSize : 11,
                        fontFamily: headObj.header.fontFamily ? headObj.header.fontFamily : "Arial",
                        bold: headObj.header.bold ? headObj.header.bold : false,
                        italic: headObj.header.italic ? headObj.header.italic : false,
                        textDecoration: headObj.header.textDecoration ? headObj.header.textDecoration : "none",
                    }],
                    height: laneHeader.height ? laneHeader.height : 50,
                    width: laneHeader.width ? laneHeader.width : 50,
                    fillColor: headObj.header.fillColor ? headObj.header.fillColor : "white",
                    rotateAngle: 0,
                    constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Select ^ ej.datavisualization.Diagram.NodeConstraints.Connect,
                    marginLeft: -20,
                    marginTop: -20,
                    marginRight: -20,
                    marginBottom: -20,
                    parent: parentName,
                });
                if (obj.orientation && obj.orientation == "horizontal") {
                    node.verticalAlign = "stretch";
                    node.height = 1;
                    node.width = laneHeader.width ? laneHeader.width : 50;
                }
                else if (obj.orientation && obj.orientation == "vertical") {
                    node.horizontalAlign = "stretch";
                    node.labels[0].rotateAngle = 0;
                    node.height = laneHeader.width ? laneHeader.width : 50;
                    node.width = 1;
                }
            }
            return node;
        },
        _initChildren: function (laneObj, parentName, diagram) {
            var children = [], child = null;
            if (laneObj.children) {
                for (var i = 0; i < laneObj.children.length; i++) {
                    child = this._initChild(laneObj.children[i], parentName, diagram);
                    if (child.shape)
                        diagram.nodes().push(child);
                    else if (child.type != "group")
                        diagram.connectors().push(child);
                    children.push(child.name);
                    diagram.nameTable[child.name] = child;
                }
            }
            return children;
        },
        _initChild: function (child, parentName, diagram) {
            var node = null;
            node = diagram._getNewNode(child);
            node.parent = parentName;
            return node;
        },
        _initphases: function (obj, diagram) {
            var phases = [];
            var phase = null;
            if (!diagram.model.phases)
                diagram.model.phases = [];
            if (obj.phases && obj.phases.length > 0) {
                for (var i = 0; i < obj.phases.length; i++) {
                    phase = ej.datavisualization.Diagram.phase(obj.phases[i]);
                    phase.parent = obj.name;
                    phase.orientation = obj.orientation;
                    diagram.model.phases.push(phase);
                    diagram.nameTable[phase.name] = phase;
                    phases.push(phase.name);
                }
            }
            return phases;
        },
        //#endregion

        //#region palette
        _createSwimlane: function (obj, diagram, data) {
            var children = [], child = null, headAdded = false;
            for (var i = 0; i < obj.children.length; i++) {
                child = diagram.nameTable[obj.children[i]];
                if (child)
                    children.push(child);
            }
            var nameTable = diagram.nameTable;
            var height = 500, width = 500;
            var headNode = null;
            if (obj.children[0]) {
                var node = nameTable[obj.children[0]];
                headNode = { text: "Title", width: 50, fillColor: node.fillColor, height: 50 };

            } else headNode = { text: "Title", width: 50, fillColor: "white", height: 50 };

            if (!obj.orientation) {
                if (obj.container)
                    obj.orientation = obj.container.orientation;
            }

            if (obj.orientation == "horizontal" && diagram._selectedSymbol) {
                height = obj.height ? Math.round(diagram._selectedSymbol.height) : 100;
                width = obj.width ? Math.round(diagram._selectedSymbol.width) : 650;
            } else {
                height = obj.height ? obj.height : 650;
                width = obj.width ? obj.width : 100;
            }

            var nSwimLane = {
                name: obj.name,
                header: headNode,
                fillColor: "white",
                minWidth: width,
                minHeight: height,
                height: height + 1,
                width: width + 1,
                maxHeight: height + 1000,
                maxWidth: width + 1000,
                offsetX: obj.offsetX,
                offsetY: obj.offsetY,
                orientation: obj.orientation ? obj.orientation : "horizontal",
                lanes: [
                    {
                        name: obj.name + "_canvas",
                        header: { text: node.labels[0].text ? node.labels[0].text : "Function", fontSize: node.labels[0].fontSize ? node.labels[0].fontSize : 11, width: 50, fillColor: node.fillColor },
                        fillColor: obj.fillColor ? obj.fillColor : "white",
                        height: height,
                        width: width,
                        children: children ? children : [],
                        _laneHeader: obj._laneHeader ? obj._laneHeader : null
                    },
                ]
            };

            var item = this._initSwimLane(ej.datavisualization.Diagram.SwimLane(nSwimLane), diagram, headAdded);

            return item;
        },
        _createDiagramLane: function (obj, nameTable) {
            var height = 0, width = 0, hAlign, vAlign, headerWidth = 0;
            if (obj.orientation == "horizontal") {
                height = obj.height ? obj.height : 1;
                width = obj.width ? obj.width : 150;
                hAlign = "stretch";
                vAlign = "top";
                headerWidth = 50;
            }
            else if (obj.orientation == "vertical") {
                height = obj.height ? obj.height : 1;
                width = obj.width ? obj.width : 120;
                hAlign = "left";
                vAlign = "stretch";
                headerWidth = 50;
            }
            var content = nameTable[obj.children[1]];

            var canvas = ej.datavisualization.Diagram.Group({
                name: obj.name,
                type: "group",
                isLane: true,
                borderColor: "black",
                offsetX: obj.offsetX,
                offsetY: obj.offsetY,
                fillColor: content.fillColor,
                container: { type: ej.datavisualization.Diagram.ContainerType.Canvas, },
                horizontalAlign: hAlign ? hAlign : "left",
                verticalAlign: vAlign ? vAlign : "top",
                minHeight: height ? height : 100,
                maxHeight: 1000,
                minWidth: width ? width : 100,
                orientation: obj.orientation ? obj.orientation : "horizontal",
                maxWidth: 1000,
                paddingTop: 20,
                paddingRight: 20,
                paddingBottom: 20,
                paddingLeft: 20,
                constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.ResizeNorth ^
                        ej.datavisualization.Diagram.NodeConstraints.ResizeWest ^ ej.datavisualization.Diagram.NodeConstraints.ResizeNorthWest ^
                    ej.datavisualization.Diagram.NodeConstraints.ResizeNorthEast ^ ej.datavisualization.Diagram.NodeConstraints.ResizeSouthWest ^
                ej.datavisualization.Diagram.NodeConstraints.Connect,
            });
            canvas._laneHeader = content._laneHeader ? content._laneHeader : null;
            var head = nameTable[obj.children[0]];
            var headObj = { header: { text: head.labels[0].text ? head.labels[0].text : "Function", fontSize: head.labels[0].fontSize ? head.labels[0].fontSize : 11, width: headerWidth, fillColor: head.fillColor } };

            var header = this._iniLaneHeader(headObj, canvas.name, { orientation: obj.orientation }, null, content._laneHeader);
            header.name = canvas.name + "_Headerr_";
            nameTable[header.name] = header;
            canvas.children.push(header.name);
            return canvas;
        },
        _createPaletteLane: function (obj, nameTable) {
            var height = 0, width = 0, offsetX = 0, offsetY = 0, rotateAngle = 0, mleft = 0, mTop = 0, align = "left";
            if (obj.orientation == "horizontal") {
                height = obj.height ? obj.height : 50;
                width = 25;
                offsetX = 15;
                offsetY = height / 2;
                rotateAngle = 270;
                align = "left";
            }
            else if (obj.orientation == "vertical") {
                height = 25;
                width = obj.width ? obj.width : 50;
                offsetX = width / 2;
                offsetY = 15;
                align = "left";
            }
            var name = obj.header.text ? obj.header.text : "";
            var header = ej.datavisualization.Diagram.Node({
                name: obj.name + "_" + name,
                type: "node",
                labels: [
                    { text: obj.header.text ? obj.header.text : "Function", fontSize: obj.header.fontSize ? obj.header.fontSize : 11, offset: { x: 0.5, y: .5 }, width: 100, rotateAngle: rotateAngle, }
                ],
                height: height,
                width: width,
                fillColor: obj.header.fillColor ? obj.header.fillColor : "white",
                //constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Select,
                parent: obj.name,
                offsetX: offsetX,
                offsetY: offsetY,
                constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Connect,
            });
            nameTable[header.name] = header;
            if (obj.orientation == "horizontal") {
                height = obj.height;
                width = obj.width - 25;
                offsetX = 25 + width / 2;
                offsetY = height / 2;
            }
            else if (obj.orientation == "vertical") {
                height = obj.height - 25;
                width = obj.width;
                offsetX = width / 2;
                offsetY = 25 + height / 2;
            }

            var content = ej.datavisualization.Diagram.Node({
                name: obj.name + "content",
                type: "node",
                height: height,
                width: width,
                fillColor: obj.fillColor ? obj.fillColor : "white",
                //constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Select,
                parent: obj.name,
                offsetX: offsetX,
                offsetY: offsetY,
            });
            content._laneHeader = obj.header;
            nameTable[content.name] = content;


            var group = ej.datavisualization.Diagram.Group({
                name: obj.name + "_group",
                height: obj.height,
                width: obj.width,
                offsetX: obj.offsetX,
                offsetY: obj.offsetY,
                children: [header.name, content.name, ]
            });
            group.isLane = true;
            group.orientation = obj.orientation;
            return group;
            //var lane = ej.datavisualization.Diagram.Group({
            //    name: obj.name, 
            //    parent: "",
            //    offsetX: 0,
            //    offsetY: 0,
            //    fillColor: obj.fillColor ? obj.fillColor : "white",
            //    container: { type: ej.datavisualization.Diagram.ContainerType.Canvas, },
            //    horizontalAlign: "left",
            //    verticalAlign: "top",
            //    minHeight: obj.height ? obj.height : 100,
            //    maxHeight: obj.maxHeight ? obj.maxHeight : 1000,
            //    minWidth: obj.width ? obj.width : 100,
            //    maxWidth: obj.maxWidth ? obj.maxWidth : 1000,
            //    paddingTop: 20,
            //    paddingRight: 20,
            //    paddingBottom: 20,
            //    paddingLeft: 20,
            //});

            //var tObj = {};
            //tObj.orientation = "horizontal";
            //var header = this._iniLaneHeader(obj, lane.name, tObj, diagram);
            //nameTable[header.name] = header;
            //lane.children.push(header.name);
            //return lane;

        },
        //#endregion
    };

})(jQuery, Syncfusion);

;

(function ($, ej) {
    "use strict";

    //#region SVG
    var Svg = (function () {
        function Svg(attr) {
            this.xmlns = "http://www.w3.org/2000/svg";
            this.document = document.createElementNS(this.xmlns, "svg");
            this.id = attr.id;
            if (attr) {
                ej.datavisualization.Diagram.Util.attr(this.document, attr);
            }
            return this;
        }
        Svg.prototype.element = function (attr, tag) {
            var element;
            if (attr && attr.id) {
                element = this.document.getElementById(attr.id);
            }
            if (!element) {
                element = document.createElementNS(this.xmlns, tag);
            }
            if (attr)
                ej.datavisualization.Diagram.Util.attr(element, attr);
            return element;
        };
        Svg.prototype.g = function (attr) {
            return this.element(attr, "g");
        };
        Svg.prototype.defs = function (attr) {
            return this.element(attr, "defs");
        };
        Svg.prototype.image = function (attr) {
            return this.element(attr, "image");
        };
        Svg.prototype.path = function (attr) {
            return this.element(attr, "path");
        };
        Svg.prototype.text = function (attr) {
            return this.element(attr, "text");
        };
        Svg.prototype.textPath = function (attr) {
            return this.element(attr, "textPath");
        };
        Svg.prototype.tspan = function (attr) {
            return this.element(attr, "tspan");
        };
        Svg.prototype.rect = function (attr) {
            return this.element(attr, "rect");
        };
        Svg.prototype.ellipse = function (attr) {
            return this.element(attr, "ellipse");
        };
        Svg.prototype.circle = function (attr) {
            return this.element(attr, "circle");
        };
        Svg.prototype.line = function (attr) {
            return this.element(attr, "line");
        };
        Svg.prototype.polyline = function (attr) {
            return this.element(attr, "polyline");
        };
        Svg.prototype.polygon = function (attr) {
            return this.element(attr, "polygon");
        };
        Svg.prototype.foreignObject = function (attr) {
            return this.element(attr, "foreignObject");
        };
        Svg.prototype.linearGradient = function (attr) {
            return this.element(attr, "linearGradient");
        };
        Svg.prototype.radialGradient = function (attr) {
            return this.element(attr, "radialGradient");
        };
        Svg.prototype.stop = function (attr) {
            return this.element(attr, "stop");
        };
        Svg.prototype.filter = function (attr) {
            return this.element(attr, "filter");
        };
        Svg.prototype.feGaussianBlur = function (attr) {
            return this.element(attr, "feGaussianBlur");
        };
        Svg.prototype.feBlend = function (attr) {
            return this.element(attr, "feBlend");
        };
        Svg.prototype.feOffset = function (attr) {
            return this.element(attr, "feOffset");
        };
        Svg.prototype.feColorMatrix = function (attr) {
            return this.element(attr, "feColorMatrix");
        };
        Svg.prototype.pattern = function (attr) {
            return this.element(attr, "pattern");
        };
        Svg.prototype.appendChild = function (element) {
            this.document.appendChild(element);
        };
        Svg.prototype.removeChild = function (element, parent) {
            if (parent) {
                parent.removeChild(element);
            } else {
                this.document.removeChild(element);
            }
        };
        Svg.prototype.getElementById = function (id) {
            return this.document.getElementById(id);
        };
        Svg.prototype.getElementsByClassName = function (name) {
            return this.document.getElementsByClassName(name);
        };
        Svg.prototype.getElementsByTagName = function (name) {
            return this.document.getElementsByTagName(name);
        };
        Svg.prototype.pathBounds = function (data) {
            var attributes = { d: data };
            var path = this.path(attributes);
            this.document.appendChild(path);
            var bounds = path.getBBox();
            this.document.removeChild(path);
            return bounds;
        };
        Svg.prototype.textBounds = function (text, attr, textElement) {
            var bounds = null;
            if (text && attr) {
                var svgText = this.text(attr);
                svgText.appendChild(document.createTextNode(text));
                this.document.appendChild(svgText);
                bounds = svgText.getBBox();
                this.document.removeChild(svgText);
            }
            else if (textElement) {
                this.document.appendChild(textElement);
                bounds = textElement.getBBox();
                this.document.removeChild(textElement);
            }
            return bounds;
        };
        Svg.prototype.absolutePath = function (path) {
            var x0, y0, x1, y1, x2, y2, segs = path.pathSegList;
            for (var x = 0, y = 0, i = 0, length = segs.numberOfItems; i < length; ++i) {
                var seg = segs.getItem(i), char = seg.pathSegTypeAsLetter;
                if (/[MLHVCSQTA]/.test(char)) {
                    if ('x' in seg) x = seg.x;
                    if ('y' in seg) y = seg.y;
                } else {
                    if ('x1' in seg) x1 = x + seg.x1;
                    if ('x2' in seg) x2 = x + seg.x2;
                    if ('y1' in seg) y1 = y + seg.y1;
                    if ('y2' in seg) y2 = y + seg.y2;
                    if ('x' in seg) x += seg.x;
                    if ('y' in seg) y += seg.y;
                    switch (char) {
                        case 'm': segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i); break;
                        case 'l': segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i); break;
                        case 'h': segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i); break;
                        case 'v': segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i); break;
                        case 'c': segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i); break;
                        case 's': segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i); break;
                        case 'q': segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i); break;
                        case 't': segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i); break;
                        case 'a': segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i); break;
                        case 'z': case 'Z': x = x0; y = y0; break;
                    }
                }
                if (char === 'M' || char === 'm') x0 = x, y0 = y;
            }
            return path;
        };
        return Svg;
    })();

    ej.datavisualization.Diagram.Svg = Svg;
    //#endregion

    //#region SVG Renderer
    ej.datavisualization.Diagram.SvgContext = {
        _renderDocument: function (view, diagram) {
            if (window.SVGSVGElement) {
                var attr = {
                    id: view.canvas.id + "_svg",
                    version: "1.1",
                    xlink: "http://www.w3.org/1999/xlink",
                    "style": "position:absolute",
                };
                var svg = new ej.datavisualization.Diagram.Svg(attr);
                view.svg = svg;
                if (diagram) {
                    diagram._svg = svg;
                    view.canvas.appendChild(svg.document);
                    diagram._view = this._renderView(view.canvas, view.svg);
                    diagram._page = this._renderPage(view.canvas, view.svg, diagram._view);
                    diagram._htmlLayer = this._renderHtmlLayer(view.canvas);
                    this._renderBackground(view.canvas, view.svg, diagram._page, diagram.model);
                    diagram._pageBackgroundLayer = this._renderBackgroundLayer(view.canvas, view.svg, diagram._page);
                    this._renderGrid(view.canvas, view.svg, diagram._page, diagram);
                    diagram._diagramLayer = view.diagramLayer = this._renderDiagramLayer(view.canvas, view.svg, diagram._page);
                    diagram._adornerLayer = this._renderAdornerLayer(view.canvas, view.svg, diagram._page);
                }
                else {


                }
            }
        },

        _renderView: function (canvas, svg) {
            var attr = { id: canvas.id + "_view" };
            var view = svg.g(attr);
            svg.appendChild(view);
            return view;
        },

        _renderHtmlLayer: function (canvas) {
            var div = document.createElement("div");
            var attr = { "id": canvas.id + "_htmlLayer", "class": "htmlLayer" };
            ej.datavisualization.Diagram.Util.attr(div, attr);
            var htmlLayer = div;
            div.style.pointerEvents = "none";
            canvas.appendChild(htmlLayer);
            return htmlLayer;
        },

        _renderPage: function (canvas, svg, parent) {
            var attr = { "id": canvas.id + "_page", "class": "page" };
            var page = svg.g(attr);
            parent.appendChild(page);
            return page;
        },

        _renderDiagramLayer: function (canvas, svg, parent) {
            var attr = { "id": canvas.id + "_diagramLayer", "class": "DiagramLayer" };
            var diagramLayer = svg.g(attr);
            parent.appendChild(diagramLayer);
            return diagramLayer;
        },

        _renderAdornerLayer: function (canvas, svg, parent) {
            var attr = { "id": canvas.id + "_adornerLayer", "class": "AdornerLayer" };
            var adornerLayer = svg.g(attr);
            parent.appendChild(adornerLayer);
            return adornerLayer;
        },

        _renderBackgroundLayer: function (canvas, svg, parent) {
            var attr = {
                "id": canvas.id + "_pageBackground",
                "class": "PageBackgroundLayer",
                "style": "pointer-events:none;",
            };
            var pageBackgroundLayer = svg.g(attr);
            parent.appendChild(pageBackgroundLayer);
            return pageBackgroundLayer;
        },

        _renderBackground: function (canvas, svg, parent, model) {
            svg.document.style.msTouchAction = "none";
            svg.document.style.display = "block";
            svg.document.style.backgroundColor = "white";
            var attr = { id: canvas.id + "_backgroundLayer" };
            var g = svg.g(attr);
            attr = { "id": canvas.id + "_background", "x": "0", "y": "0", "width": "100%", "height": "100%", "preserveAspectRatio": "none", "pointer-events": "none" };
            var image = svg.image(attr);
            if (model.backgroundImage) {
                image.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", model.backgroundImage);
                if (!svg.getElementById(canvas.id + "_background")) {
                    g.appendChild(image);
                }
            }
            else {
                if (svg.getElementById(image.id)) {
                    g.removeChild(svg.getElementById(image.id));
                }
            }
            var rect = svg.rect({
                "id": canvas.id + "_backgroundColor", "x": "0", "y": "0", "width": "100%", "height": "100%", "fill": model.backgroundColor, "preserveAspectRatio": "none", "pointer-events": "none"
            });
            if (model.backgroundColor) {
                if (!svg.getElementById(canvas.id + "_backgroundColor")) {
                    g.appendChild(rect);
                }
            }
            else {
                if (svg.getElementById(rect.id)) {
                    g.removeChild(svg.getElementById(rect.id));
                }
            }

            if (!svg.getElementById(g.id))
                parent.appendChild(g);

        },

        _renderGrid: function (canvas, svg, parent, diagram) {
            var defs = svg.defs({ "id": canvas.id + "patterndefinition" });
            var g;
            svg.appendChild(defs);
            if (diagram.model.snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.ShowHorizontalLines ||
                diagram.model.snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.ShowVerticalLines) {
                var grid = document.getElementById(canvas.id + "_grid");
                var rect = document.getElementById(canvas.id + "pattern_gridline");
                var pattern = document.getElementById(canvas.id + "pattern_grid");
                if (pattern)
                    defs.removeChild(pattern);
                var attr = { id: canvas.id + "_grid", "pointer-events": "none" };
                g = svg.g(attr);
                var height = 0;
                if (diagram.model.snapSettings.horizontalGridLines.linesInterval) {
                    diagram.model.snapSettings.horizontalGridLines.linesInterval.forEach(function (entry) {
                        height += entry;
                    });
                }
                var width = 0;
                if (diagram.model.snapSettings.verticalGridLines.linesInterval) {
                    diagram.model.snapSettings.verticalGridLines.linesInterval.forEach(function (entry) {
                        width += entry;
                    });
                }
                var scale = diagram._currZoom;

                attr = { id: canvas.id + "pattern_grid", x: 0, y: 0, width: width * scale, height: height * scale, patternUnits: "userSpaceOnUse" };
                var pattern = svg.pattern(attr);
                //pattern.setAttribute("patternUnits", "userSpaceOnUse");
                scale = this._scaleSnapInterval(diagram.model, scale);
                this._renderHorizontalGridlines(scale, pattern, width, diagram.model, svg);
                this._renderVerticalGridlines(scale, pattern, height, diagram.model, svg);
                defs.appendChild(pattern);
                var rect = svg.rect({ id: canvas.id + "pattern_gridline", "x": diagram._hScrollOffset, "y": diagram._vScrollOffset, "width": "100%", "height": "100%", "fill": "url(#" + canvas.id + "pattern_grid)" });
                g.appendChild(rect);
                if (!grid)
                    parent.appendChild(g);
            }
            else {
                g = document.getElementById(canvas.id + "_grid");
                if (g) {
                    var grid = document.getElementById(canvas.id + "pattern_gridline");
                    if (grid)
                        g.removeChild(grid);
                }
            }
        },

        _updateBackground: function (hoffset, voffset, scale, diagram) {
            var attr = {
                x: hoffset,
                y: voffset
            };
            var bgClr = document.getElementById(diagram._id + "_canvas_backgroundColor");
            if (bgClr)
                ej.datavisualization.Diagram.Util.attr(bgClr, attr);
            var bgImg = document.getElementById(diagram._id + "_canvas_background");
            if (bgImg)
                ej.datavisualization.Diagram.Util.attr(bgImg, { "transform": "scale(" + scale + ")" });
        },

        _updateGrid: function (hoffset, voffset, scale, diagram) {
            var grid = document.getElementById(diagram._canvas.id + "pattern_gridline");
            var i;
            if (grid) {
                var pattern = document.getElementById(diagram._canvas.id + "pattern_grid");
                var height = 0;
                if (diagram.model.snapSettings.horizontalGridLines.linesInterval) {
                    for (i = 0; i < diagram.model.snapSettings.horizontalGridLines.linesInterval.length; i++) {
                        height += diagram.model.snapSettings.horizontalGridLines.linesInterval[i];
                    }
                }
                var width = 0;
                if (diagram.model.snapSettings.verticalGridLines.linesInterval) {
                    for (i = 0; i < diagram.model.snapSettings.verticalGridLines.linesInterval.length; i++) {
                        width += diagram.model.snapSettings.verticalGridLines.linesInterval[i];
                    }
                }

                var attr = {
                    x: hoffset,
                    y: voffset
                };
                ej.datavisualization.Diagram.Util.attr(grid, attr);

                scale = this._scaleSnapInterval(diagram.model, scale);
                var svg = diagram._svg;
                var defs = svg.defs({ "id": diagram._canvas.id + "patterndefinition" });
                if (pattern)
                    defs.removeChild(pattern);
                var attr = { id: diagram._canvas.id + "pattern_grid", x: 0, y: 0, width: width * scale, height: height * scale, patternUnits: "userSpaceOnUse" };
                pattern = diagram._svg.pattern(attr);
                this._renderHorizontalGridlines(scale, pattern, width, diagram.model, diagram._svg);
                this._renderVerticalGridlines(scale, pattern, height, diagram.model, diagram._svg);
                defs.appendChild(pattern);
            }
        },
        _scaleSnapInterval: function (model, scale) {
            if (scale >= 2) {
                while (scale >= 2) {
                    scale /= 2;
                }
            }
            else if (scale <= 0.5) {
                while (scale <= 0.5) {
                    scale *= 2;
                }
            }
            var i;
            if (scale !== 1) {
                model.snapSettings.horizontalGridLines._snapinterval = [];
                for (i = 0; i < model.snapSettings.horizontalGridLines.snapInterval.length; i++) {
                    model.snapSettings.horizontalGridLines._snapinterval[i] =
                        model.snapSettings.horizontalGridLines.snapInterval[i] * scale;
                }
                model.snapSettings.verticalGridLines._snapinterval = [];
                for (i = 0; i < model.snapSettings.verticalGridLines.snapInterval.length; i++) {
                    model.snapSettings.verticalGridLines._snapinterval[i] =
                        model.snapSettings.verticalGridLines.snapInterval[i] * scale;
                }
            }
            return scale;
        },

        _renderHorizontalGridlines: function (scale, pattern, width, model, svg) {
            var snapSettings = model.snapSettings;
            if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.ShowHorizontalLines) {
                var space = 0;
                var cnt = 0;
                for (var i = 0; i < snapSettings.horizontalGridLines.linesInterval.length; i = i + 2) {
                    var thickness = snapSettings.horizontalGridLines.linesInterval[i];
                    var line = svg.line({
                        "x1": 0, "y1": space * scale, "x2": width * scale, "y2": space * scale, "stroke": snapSettings.horizontalGridLines.lineColor,
                        "stroke-width": thickness
                    });
                    //svg.appendChild(line);
                    space += snapSettings.horizontalGridLines.linesInterval[i + 1] + thickness;
                    pattern.appendChild(line);
                    cnt++;
                }
            }
        },

        _renderVerticalGridlines: function (scale, pattern, height, model, svg) {
            var snapSettings = model.snapSettings;
            if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.ShowVerticalLines) {
                var space = 0;
                var cnt = 0;
                for (var i = 0; i < snapSettings.verticalGridLines.linesInterval.length; i = i + 2) {
                    var thickness = model.snapSettings.verticalGridLines.linesInterval[i];
                    var line = svg.line({
                        "x1": space * scale, "y1": 0, "x2": space * scale, "y2": height * scale, "stroke": snapSettings.verticalGridLines.lineColor,
                        "stroke-width": thickness, "stroke-dasharray": snapSettings.verticalGridLines.lineDashArray
                    });
                    space += snapSettings.verticalGridLines.linesInterval[i + 1] + thickness;
                    pattern.appendChild(line);
                    cnt++;
                }
            }
        },
        //#region Transformation
        transformView: function (diagram, hOffset, vOffset) {
            var view = diagram._view;
            var attr = {
                "transform": "translate(" + hOffset + "," + vOffset + ")"
            };
            ej.datavisualization.Diagram.Util.attr(view, attr);
            if (ej.browserInfo().name === "msie") {
                if (diagram._htmlLayer && diagram._htmlLayer.children.length > 0) {
                    diagram._htmlLayer.style.left = hOffset + "px";
                    diagram._htmlLayer.style.top = vOffset + "px";
                    diagram._htmlLayer.style.position = "absolute";
                }
            }
        },
        scaleContent: function (diagram, scale) {
            var diagramLayer = diagram._diagramLayer;
            ej.datavisualization.Diagram.Util.attr(diagramLayer, { "transform": "scale(" + scale + ")" });
            if (ej.browserInfo().name === "msie") {
                if (diagram._htmlLayer && diagram._htmlLayer.children.length > 0) {
                    diagram._htmlLayer.style.transform = "scale(" + scale + ")";
                }
            }
            if (diagram.selectionList.length > 0)
                this.updateSelector(diagram.selectionList[0], diagram._svg, scale, diagram, diagram.model.selectedItems.constraints);
            if (diagram.selectionList[0]) {
                if ((diagram.model.selectedItems.userHandles && diagram.model.selectedItems.userHandles.length > 0)) {
                    var isMultipleSelection = false;
                    if (diagram.selectionList[0].type == "pseudoGroup")
                        isMultipleSelection = true;
                    if (diagram.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles)
                        ej.datavisualization.Diagram.SvgContext.updateUserHandles(diagram.model.selectedItems.userHandles, diagram.selectionList[0], diagram._svg, isMultipleSelection, false, scale);
                }
            }
        },
        setSize: function (svg, width, height) {
            ej.datavisualization.Diagram.Util.attr(svg.document, { width: width + "px", height: height + "px" });
        },
        //#endregion

        _findIndex: function (diagram, node) {
            var lastNode, newIndex = 1, index, elements;
            if (node.parent)
                elements = $("#" + node.parent.name).find(">.node,>.connector,>.group");
            else
                elements = $("#DiagramContent_canvas_svg").find(">.node,>.connector,>.group");
            if (node.name != "helper") {
                lastNode = elements[elements.length - 1];
                if (lastNode && lastNode.id == "helper")
                    lastNode = elements[elements.length - 2];
                if (lastNode) {
                    index = 0;
                    if (lastNode.className.animVal == "ej-d-node" || lastNode.className.animVal == "ej-d-group") {
                        newIndex = index + 1;
                    }
                    else if (lastNode.className.animVal == "ej-d-connector") {
                        newIndex = index + 1;
                    }
                }
            }
            return newIndex;
        },
        //#region Render Node

        //#region render
        renderNode: function (node, svg, parent) {
            var g;
            // if (node.visible) 
            {
                var name = node.name;
                var visible = node.visible ? "visible" : "hidden";
                var x = node.offsetX - node.width * node.pivot.x;
                var y = node.offsetY - node.height * node.pivot.y;
                g = svg.g({
                    "id": name, "class": "ej-d-node", "transform": "rotate(" + node.rotateAngle + "," + node.offsetX + "," + node.offsetY +
                        "),translate(" + x + "," + y + ")", "visibility": visible
                });
                if (parent) {
                    parent.appendChild(g);
                }
                else {
                    svg.appendChild(g);
                }
                this._renderNode(node, svg, g);
            }
            return g;
        },

        _renderNode: function (node, svg, g) {
            this._renderShape(node, svg, g);
            this._renderLabels(node, svg, g);
            this._renderPorts(node, svg, g);
        },

        _renderShadow: function (node, svg) {
            var filter = this._renderFilter(node, svg);
            if (node.type == "image" || node.type == "html" || node.type == "text") {
                var element = svg.document.getElementById(node.name + "_backrect");
            }
            else element = svg.document.getElementById(node.name + "_shape");
            element.setAttribute("filter", filter);
        },

        _removeShadow: function (node, svg) {
            if (node.type == "image" || node.type == "html" || node.type == "text") {
                var element = svg.document.getElementById(node.name + "_backrect");
            }
            else element = svg.document.getElementById(node.name + "_shape");
            element.removeAttribute("filter");
        },
        renderphase: function (node, svg, parent, diagram) {
            var g;
            g = svg.g({ "id": node.name, "class": "ej-d-sepetator" });
            if (node.parent) {
                //parent = svg.getElementById(node.parent);
                //if (parent)
                parent.appendChild(g);
            } else {
                svg.appendChild(g);
            }
            var visibility = "visible";
            var tx = 0, ty = 0;
            var parNode = diagram.nameTable[node.parent];
            if (parNode) {
                var children = diagram._getChildren(parNode.children);
                if (children.length > 1)
                    var header = diagram.nameTable[children[0]];
                var bounds = ej.datavisualization.Diagram.Util.bounds(parNode);
                var points = [], nPoint;
                var top = bounds.top + 50;
                var left = bounds.left + 50;
                if (node.orientation == "vertical") {
                    points.push({ x: 0, y: 0 });
                    points.push({ x: bounds.width, y: 0 });
                    nPoint = this._convertToSVGPoints(points);
                    tx = bounds.x;
                    ty = bounds.y + node.offset;
                    if (header)
                        top += header.height;
                    if (!(ty < bounds.bottom && ty > top)) {
                        visibility = "hidden";
                    }
                } else {
                    points.push({ x: 0, y: header.height ? header.height : 0 });
                    points.push({ x: 0, y: bounds.height });
                    nPoint = this._convertToSVGPoints(points);
                    tx = bounds.x + node.offset;
                    ty = bounds.y;

                    if (!(tx < bounds.right && tx > left)) {
                        visibility = "hidden";
                    }
                }


                var attr = {
                    "id": node.name + "_phase",
                    "stroke": node.lineColor,
                    "stroke-width": node.lineWidth,
                    "stroke-dasharray": node.lineDashArray,
                    "points": nPoint,
                    //"transform": "translate(" + tx + "," + ty + ")",
                };
                var line = svg.polyline(attr);
                g.appendChild(line);

                attr = {
                    "id": node.name + "_phase_hitTest",
                    "class": "hitTest",
                    "stroke-width": 10,
                    "points": nPoint,
                    //"transform": "translate(" + tx + "," + ty + ")",
                    "stroke": "transparent",

                };
                line = svg.polyline(attr);
                g.appendChild(line);
                g.setAttribute("transform", "translate(" + tx + "," + ty + ")");
            }

        },

        _renderGroupBackground: function (group, g, svg) {
            if (group.fillColor != "none") {
                var x = group.offsetX - group.width / 2;
                var y = group.offsetY - group.height / 2;

                var angle = group.rotateAngle;
                var pt = new ej.datavisualization.Diagram.Point(x + group.width / 2, y + group.height / 2);
                var attr = {
                    "id": group.name + "_shape",
                    "rx": group.shape.cornerRadius,
                    "ry": group.shape.cornerRadius,
                    "width": Math.round(group.width),
                    "height": Math.round(group.height),
                    "fill": group.fillColor,
                    "stroke": group.borderColor,
                    "stroke-width": group.borderWidth,
                    "opacity": group.opacity,
                    "stroke-dasharray": group.borderDashArray,
                    "transform": "rotate(" + angle + "," + pt.x + "," + pt.y + "),translate(" + x + "," + y + ")",
                };
                g.appendChild(svg.rect(attr));
            }
        },

        renderGroup: function (group, svg, parent, nameTable, diagram, isLoad, overView) {
            var g;
            var visible = group.visible ? "visible" : "hidden";
            //if (group.visible) 
            {
                g = svg.g({ "id": group.name, "class": "ej-d-group", "visibility": visible });
                if (parent) {
                    parent.appendChild(g);
                } else {
                    svg.appendChild(g);
                }
                if (group.parent == "" && group.container) {
                    if (isLoad || overView) {
                        group.height = 0;
                        group.width = 0;
                    }
                    this._alignOnContainer(group, diagram);
                }
                this._renderGroupBackground(group, g, svg);

                var children = diagram._getChildren(group.children);
                for (var i = 0, len = children.length; i < len; i++) {
                    var child = nameTable[children[i]];
                    if (child) {
                        if (child.type == "group") {
                            this.renderGroup(child, svg, g, nameTable, diagram, isLoad, overView);
                            ej.datavisualization.Diagram.Util._updateGroupBounds(child, diagram);
                            ej.datavisualization.Diagram.DiagramContext.update(child, diagram);
                        }
                        else if (child.segments)
                            this.renderConnector(child, svg, g, diagram);
                        else
                            this.renderNode(child, svg, g);
                    }
                }
                this._renderLabels(group, svg, g);
                this._renderPorts(group, svg, g);
            }
            return g;
        },
        _alignOnContainer: function (group, diagram, stretch) {
            switch (group.container && group.container.type) {
                case "canvas":
                    var angle = group.rotateAngle;
                    //group.rotateAngle = 0;
                    if (!(group.rotateAngle == 0 && angle == 0)) {
                        if (group.parent == "")
                            group.rotateAngle = 0;
                        else
                            diagram._rotate(group, -angle, diagram.nameTable);
                    }

                    this._alignOnCanvasContainer1(group, diagram, stretch);
                    if (!((group.rotateAngle == 0) && (angle == 0)))
                        diagram._rotate(group, angle, diagram.nameTable);
                    break;
                case "stack":
                    this._alignOnStackContainer(group, diagram);
                    break;
            }
        },

        _removeFromContainer: function (node, svg, parent) {
            var element = svg.getElementById(node.name);
            if (element)
                element.parentNode.removeChild(element);
        },

        _childrenBounds: function (group, diagram) {
            var children = diagram._getChildren(group.children);
            var bounds = new ej.datavisualization.Diagram.Rectangle();
            bounds = ej.datavisualization.Diagram.Util.bounds(diagram.nameTable[children[0]]);
            for (var i = 1, len = children.length; i < len; i++) {
                var rect = ej.datavisualization.Diagram.Util.bounds(diagram.nameTable[children[i]], diagram);
                if (rect)
                    bounds = diagram._union(bounds, rect);
            }
            return bounds;
        },

        _alignOnCanvasContainer1: function (group, diagram, stretch) {
            var rSize = this._measureCanvasSize1(group, diagram);
            var newSize = diagram._getMinMaxSize(group, rSize.width, rSize.height, stretch);
            group.width = newSize.width;
            group.height = newSize.height;
            this._alignOnCanvas1(group, diagram);
        },
        _alignOnCanvas1: function (group, diagram, resize) {
            var child = null;
            var children = diagram._getChildren(group.children);
            for (var i = 0; i < children.length; i++) {
                child = diagram.nameTable[children[i]];
                if (child) {
                    var pos = this._getCanvasPosition1(group, child, diagram, resize);
                    diagram._translate(child, pos.x, pos.y, diagram.nameTable);
                    ej.datavisualization.Diagram.SpatialUtil._updateQuad(diagram, diagram._spatialSearch, child);
                }
            }
        },
        _getCanvasPosition1: function (group, node, diagram, resize) {
            var dx = null, dy = null;
            var groupBounds = ej.datavisualization.Diagram.Util.bounds(group);
            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
            switch (node.horizontalAlign) {
                case "left":
                    dx = groupBounds.x - bounds.x + node.marginLeft + group.paddingLeft;
                    break;
                case "center":
                    dx = (groupBounds.x + groupBounds.width / 2) - (bounds.x + bounds.width / 2);
                    if (node.marginLeft)
                        dy = groupBounds.x - bounds.x + node.marginLeft + group.paddingLeft;
                    break;
                case "right":
                    dx = (groupBounds.x + groupBounds.width) - (bounds.x + bounds.width + group.paddingRight);
                    break;
                case "stretch":
                    var angle = node.rotateAngle;
                    if (!(node.rotateAngle == 0) && (angle == 0))
                        diagram._rotate(node, -node.rotateAngle, diagram.nameTable);

                    var deltaWidth = (group.width - group.paddingLeft - group.paddingRight - node.marginLeft - node.marginRight) / node.width;
                    diagram.scale(node, deltaWidth, 0, group.pivot, diagram.nameTable);
                    groupBounds = ej.datavisualization.Diagram.Util.bounds(group);
                    bounds = ej.datavisualization.Diagram.Util.bounds(node, diagram);
                    dx = (groupBounds.x + group.paddingLeft) - (bounds.x) + node.marginLeft;
                    if (!(node.rotateAngle == 0) && (angle == 0))
                        diagram._rotate(node, angle, diagram.nameTable);

                    if (node.container && node.container.type == "stack") {
                        var childBounds = ej.datavisualization.Diagram.Util._getChildrenBounds(node, diagram);
                        var stackWidth = diagram.nameTable[node.name].width;
                        //if (childBounds.width < stackWidth) {
                        var diffX = stackWidth - childBounds.width - group.paddingLeft - group.paddingRight;
                        var children = diagram._getChildren(node.children);
                        var lastChild = diagram.nameTable[children[children.length - 1]];
                        if (lastChild) {
                            var wid = lastChild.width;
                            lastChild.width += diffX;
                            lastChild.offsetX += diffX / 2;
                            lastChild.minWidth = lastChild.width;
                            if (wid != lastChild.width) {
                                this._updateCanvasChildren(lastChild, diagram);
                            }
                            if (resize && lastChild.container && lastChild.container.type == "canvas") {
                                this._alignOnCanvas1(lastChild, diagram);
                            }
                        }
                        //}
                    }
                    break;
            }
            switch (node.verticalAlign) {
                case "top":
                    dy = groupBounds.y - bounds.y + node.marginTop + group.paddingTop;
                    break;
                case "center":
                    dy = (groupBounds.y + groupBounds.height / 2) - (bounds.y + bounds.height / 2) + node.marginTop;
                    if (node.marginTop)
                        dy = groupBounds.y - bounds.y + node.marginTop + group.paddingTop;
                    break;
                case "bottom":
                    dy = (groupBounds.y + groupBounds.height) - (bounds.y + bounds.height + group.paddingBottom);
                    break;
                case "stretch":
                    var angle = node.rotateAngle; var height
                    var nodeBounds123 = ej.datavisualization.Diagram.Util.bounds(node);
                    if (!(node.rotateAngle == 0) && (angle == 0))
                        diagram._rotate(node, -node.rotateAngle, diagram.nameTable);
                    if (node.height == 0)
                        height = 1;
                    else height = node.height;
                    var deltaHeight = (group.height - group.paddingTop - group.paddingBottom - node.marginTop - node.marginBottom) / height;
                    diagram.scale(node, 0, deltaHeight, group.pivot, diagram.nameTable);
                    groupBounds = ej.datavisualization.Diagram.Util.bounds(group);
                    bounds = ej.datavisualization.Diagram.Util.bounds(node, diagram);
                    dy = (groupBounds.y + group.paddingTop) - (bounds.y) + node.marginTop;
                    if (!(node.rotateAngle == 0) && (angle == 0))
                        diagram._rotate(node, angle, diagram.nameTable);
                    if (node.container && node.container.type == "stack") {
                        childBounds = ej.datavisualization.Diagram.Util._getChildrenBounds(node, diagram);
                        var stackHeight = diagram.nameTable[node.name].height;
                        var diffY = stackHeight - childBounds.height - -group.paddingTop - group.paddingBottom;
                        var children = diagram._getChildren(node.children);
                        lastChild = diagram.nameTable[children[children.length - 1]];
                        if (lastChild) {
                            var hei = lastChild.height;
                            lastChild.height += diffY;
                            lastChild.offsetY += diffY / 2;
                            lastChild.minHeight = lastChild.height;
                            if (hei != lastChild.height) {
                                this._updateCanvasChildren(lastChild, diagram);
                            }

                            if (resize && lastChild.container && lastChild.container.type == "canvas") {
                                this._alignOnCanvas1(lastChild, diagram);
                            }
                        }
                    }
                    break;
            }
            return { x: dx, y: dy };
        },

        _updateCanvasChildren: function (group, diagram) {
            var children = diagram._getChildren(group.children), child;
            for (var i = 0; i < children.length; i++) {
                child = diagram.nameTable[children[i]];
                if (child) {
                    if (child.horizontalAlign == "stretch") {
                        var dx = group.width - child.width;
                        child.width += dx;
                        child.offsetX += dx / 2;
                    }
                    else if (child.verticalAlign == "stretch") {
                        var dy = group.height - child.height;
                        child.height += dy;
                        child.offsetY += dy / 2;
                    }
                }
            }
        },
        _measureCanvasSize1: function (group, diagram) {
            var child = null;
            var bounds = ej.datavisualization.Diagram.Rectangle(0, 0, 0, 0), transX = 0, transY = 0;
            var rect = ej.datavisualization.Diagram.Rectangle(0, 0, 0, 0);
            var children = diagram._getChildren(group.children);
            for (var i = 0; i < children.length; i++) {
                child = diagram.nameTable[children[i]];
                if (child) {
                    if (child.type != "group") {
                        var bounds1 = ej.datavisualization.Diagram.Util.bounds(child);
                        if (!bounds1.left < 0)
                            bounds = ej.datavisualization.Diagram.Geometry.rect([bounds1.topLeft, bounds1.topRight, bounds1.bottomRight, bounds1.bottomLeft]);
                        else
                            bounds = bounds1;
                        bounds.y = 0;
                        bounds.x = 0;
                    } else {
                        this._alignOnContainer(child, diagram);
                        bounds1 = ej.datavisualization.Diagram.Util.bounds(child);
                        bounds = ej.datavisualization.Diagram.Geometry.rect([bounds1.topLeft, bounds1.topRight, bounds1.bottomRight, bounds1.bottomLeft]);
                        bounds.y = 0;
                        bounds.x = 0;
                        if (child.rotateAngle == 0) {
                            bounds.width = bounds1.width;
                            bounds.height = bounds1.height;
                        }
                    }
                }
                if (child) {
                    if (child.container && child.container.type == "stack") {
                        bounds.width += child.marginLeft;
                        bounds.height += child.marginTop;
                    } else {
                        bounds.width += child.marginLeft + child.marginRight;
                        bounds.height += child.marginTop + child.marginBottom;
                    }
                }
                if (bounds) {
                    rect = diagram._union(bounds, rect);
                }
            }
            rect.width += group.paddingLeft + group.paddingRight;
            rect.height += group.paddingTop + group.paddingBottom;
            return rect;
        },

        _updateMargin: function (node, group) {
            if (group && group.container && group.container.type == "canvas") {
                var groupBounds = ej.datavisualization.Diagram.Util.bounds(group); //ej.datavisualization.Diagram.SvgContext.getCanvasBoundingBox(group, this.diagram, node, true);
                var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                node.marginLeft = bounds.x - (groupBounds.x + group.paddingLeft);
                node.marginRight = (groupBounds.x + group.width) - (bounds.x + bounds.width) - group.paddingRight;
                node.marginTop = bounds.y - (groupBounds.y + group.paddingTop);
                node.marginBottom = (groupBounds.y + group.height) - (bounds.y + bounds.height) - group.paddingBottom;
            }
        },
        _alignOnStackContainer: function (group, diagram) {

            var angle = group.rotateAngle;
            if (group.parent == "")
                group.rotateAngle = 0;
            else
                diagram._rotate(group, -angle, diagram.nameTable);
            var rSize = this._measureStackSize(group, diagram);
            var newSize = diagram._getMinMaxSize(group, rSize.width, rSize.height);
            group.width = newSize.width;
            group.height = newSize.height;// - group.marginTop;
            this._alignOnStack(group, diagram);
            diagram._rotate(group, angle, diagram.nameTable);

        },

        _alignOnStack: function (group, diagram) {
            var child = null, bounds, transX = 0, transY = 0;
            var children = diagram._getChildren(group.children);
            for (var i = 0; i < children.length; i++) {
                child = diagram.nameTable[children[i]];
                if (child) {
                    var grAngle = child.rotateAngle;
                    if (!((child.rotateAngle == 0) && (grAngle == 0)))
                        diagram._rotate(child, -child.rotateAngle, diagram.nameTable);
                    var pos = this._getStackPosition(group, child, transX, transY, diagram);

                    diagram._translate(child, pos.x, pos.y, diagram.nameTable);
                    if (group.container.orientation == "vertical")
                        transY += child.height + child.marginTop + child.marginBottom;
                    else
                        transX += child.width + child.marginLeft + child.marginRight;
                    if (!((child.rotateAngle == 0) && (grAngle == 0)))
                        diagram._rotate(child, grAngle, diagram.nameTable);
                    ej.datavisualization.Diagram.SpatialUtil._updateQuad(diagram, diagram._spatialSearch, child);
                }
            }
        },
        _getStackPosition: function (group, node, transX, transY, diagram) {
            var groupBounds = ej.datavisualization.Diagram.Util.bounds(group);
            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
            var dx = null, dy = null;
            if (group.container.orientation == "vertical") {
                dy = groupBounds.y - bounds.y + transY + node.marginTop + group.paddingTop;
                switch (node.horizontalAlign) {
                    case "left":
                        dx = groupBounds.x - bounds.x + node.marginLeft + group.paddingLeft;
                        break;
                    case "center":
                        dx = groupBounds.center.x - bounds.center.x;
                        break;
                    case "right":
                        dx = (groupBounds.x + groupBounds.width) - (bounds.x + bounds.width + group.paddingRight);
                        break;
                    case "stretch":
                        var deltaWidth = (group.width - group.paddingLeft - group.paddingRight) / node.width;
                        diagram.scale(node, deltaWidth, 1, group.pivot, diagram.nameTable);
                        groupBounds = ej.datavisualization.Diagram.Util.bounds(group);
                        bounds = ej.datavisualization.Diagram.Util.bounds(node, diagram);
                        dx = (groupBounds.x + group.paddingLeft) - (bounds.x);
                        break;
                }
            }
            else {
                dx = groupBounds.x - bounds.x + transX + node.marginLeft + group.paddingLeft;
                switch (node.verticalAlign) {
                    case "top":
                        dy = groupBounds.y - bounds.y + node.marginTop + group.paddingTop;
                        break;
                    case "center":
                        dy = groupBounds.center.y - bounds.center.y;
                        break;
                    case "bottom":
                        dy = (groupBounds.y + groupBounds.height) - (bounds.y + bounds.height + group.paddingBottom);
                        break;
                    case "stretch":
                        var deltaHeight = (group.height - group.paddingTop - group.paddingBottom) / node.height;
                        diagram.scale(node, 1, deltaHeight, group.pivot, diagram.nameTable);
                        groupBounds = ej.datavisualization.Diagram.Util.bounds(group);
                        bounds = ej.datavisualization.Diagram.Util.bounds(node, diagram);
                        dy = (groupBounds.y + group.paddingTop) - (bounds.y);
                        break;
                }
            }
            return { x: dx, y: dy }
        },
        _measureStackSize: function (group, diagram, stretch) {
            var child = null;
            var bounds = new ej.datavisualization.Diagram.Rectangle(), transX = 0, transY = 0;
            var rect = ej.datavisualization.Diagram.Rectangle(0, 0, 0, 0);
            var children = diagram._getChildren(group.children);
            for (var i = 0; i < children.length; i++) {
                child = diagram.nameTable[children[i]];
                if (child) {
                    if (child.type != "group") {
                        bounds = ej.datavisualization.Diagram.Util.bounds(child);
                        bounds.y = 0;
                        bounds.x = 0;
                    } else {
                        bounds = this._measureContainerSize(child, diagram, stretch);
                        bounds.y = 0;
                        bounds.x = 0;
                    }

                    bounds.width += transX + child.marginLeft + child.marginRight;
                    bounds.height += transY + child.marginTop + child.marginBottom;
                }
                if (bounds) {
                    rect = diagram._union(bounds, rect);
                }
                if (group.container.orientation == "horizontal") {
                    transX = bounds.width;
                }
                else {
                    transY = bounds.height;
                }
            }
            rect.width += group.paddingLeft + group.paddingRight;
            rect.height += group.paddingTop + group.paddingBottom;
            return rect;
        },

        _measureContainerSize: function (node, diagram, stretch) {
            var bounds = null;
            if (node.type == "group" && node.container) {
                switch (node.container.type) {
                    case "canvas":
                        this._alignOnContainer(node, diagram, stretch);
                        return ej.datavisualization.Diagram.Util.bounds(node);
                        break;
                    case "stack":
                        return this._measureStackSize(node, diagram);
                        break;
                }
            }
        },

        _renderFilter: function (node, svg) {
            if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
                var defs = svg.getElementsByTagName("defs")[0];
                var width = node.width + 10; var height = node.height + 10;
                if (ej.browserInfo().name === "chrome") { width = node.width / 3; height = node.height / 3; }
                var filter = svg.filter({ id: node.name + "_filter", width: width, height: height });
                var offset = svg.feOffset({ result: "offOut", "in": "SourceAlpha", dx: "5", dy: "5" });
                filter.appendChild(offset);
                var matrix = svg.feColorMatrix({ result: "matrixOut", "in": "offOut", type: "matrix", values: "0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.3 0" });
                filter.appendChild(matrix);
                var blur = svg.feGaussianBlur({ result: "blurOut", "in": "matrixOut", stdDeviation: "5" });
                filter.appendChild(blur);
                var blend = svg.feBlend({ "in": "SourceGraphic", in2: "blurOut", mode: "normal" });
                filter.appendChild(blend);
                defs.appendChild(filter);
                return "url(#" + node.name + "_filter)";
            }
            return null;
        },
        _renderGradient: function (name, gradient, svg) {
            var fill;
            var id;
            if (gradient.type === "linear") {
                id = this._renderLinearGradient(name, gradient, svg);
                fill = "url(#" + id + ")";
            }
            else if (gradient.type === "radial") {
                id = this._renderRadialGradient(name, gradient, svg);
                fill = "url(#" + id + ")";
            }
            return fill;
        },

        _renderLinearGradient: function (name, gradient, svg) {
            var defs = svg.getElementsByTagName("defs")[0];
            if (defs) {
                var attr = { "id": name + "_gradient", "x1": gradient.x1 + "%", "y1": gradient.y1 + "%", "x2": gradient.x2 + "%", "y2": gradient.y2 + "%" };
                var linear = svg.linearGradient(attr);
                this._renderStops(gradient, svg, linear);
                defs.appendChild(linear);
                return linear.id;
            }
            return null;
        },

        _renderRadialGradient: function (name, gradient, svg) {
            var defs = svg.getElementsByTagName("defs")[0];
            if (defs) {
                var attr = {
                    "id": name + "_gradient", "cx": gradient.cx + "%", "cy": gradient.cy + "%",
                    "fx": gradient.fx + "%", "fy": gradient.fy + "%", "r": gradient.r + "%"
                };
                var radial = svg.radialGradient(attr);
                this._renderStops(gradient, svg, radial);
                defs.appendChild(radial);
                return radial.id;
            }
            return null;
        },

        _renderStops: function (gradient, svg, element) {
            if (svg.getElementById(element.getAttribute("id")) === element) {
                while (element.firstChild) {
                    element.removeChild(element.firstChild);
                }
            }
            var stops = gradient.stops;
            var stop;
            for (var i = 0, len = stops.length; i < len; i++) {
                stop = stops[i];
                element.appendChild(svg.stop({ "offset": stop.offset + "%", "stop-color": stop.color, "stop-opacity": stop.opacity }));
            }
        },

        _renderShape: function (node, svg, g) {
            switch (node.shape.type) {
                case "rectangle":
                    this._renderRect(node, svg, g);
                    break;
                case "ellipse":
                    this._renderEllipse(node, svg, g);
                    break;
                case "image":
                    this._renderImage(node, svg, g);
                    break;
                case "path":
                    this._renderPath(node, svg, g);
                    break;
                case "polygon":
                    this._renderPolygon(node, svg, g);
                    break;
                case "text":
                    this._renderTextElement(node, svg, g);
                    break;
                case "html":
                    this._renderHtmlElement(node, svg, g);
                    break;
                case "native":
                    this._rendercontent(node, svg, g);
                    break;
            }
        },

        _renderHTMLTemplate: function (node) {
            if (node.shape.templateId && $.templates) {
                var templates;
                templates = $.templates("#" + node.shape.templateId);
                return templates.render(node);
            }
        },

        _renderSvgTemplate: function (node, svg, g, html) {
            var div = document.createElement('div');
            div.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg"><g id="tempNative">' + html + '</g></svg>';
            document.body.appendChild(div);
            var content = document.getElementById("tempNative").cloneNode(true);
            content.id = node.name + "_shape";
            g.appendChild(content);
            var bounds = content.getBBox();
            var delwidth = bounds.width ? node.width / bounds.width : 1;
            var delheight = bounds.height ? node.height / bounds.height : 1;
            content.setAttribute("transform", "scale(" + delwidth + "," + delheight + ")");
            content.setAttribute("id", node.name + "_shape");
            content.setAttribute("filter", this._renderFilter(node, svg));
            div.parentNode.removeChild(div);
        },



        _rendercontent: function (node, svg, g) {
            //if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
            //    var fill = node.fillColor;
            //    var shadow = {
            //        "id": node.name + "_shadow", "width": node.width, "height": node.height, "stroke": "lightgrey", "fill": fill != "none" || fill != "transparent" ? "lightgrey" : "none",
            //        "transform": "translate(" + 5 + "," + 5 + ")", "opacity": 0.7
            //    };
            //    g.appendChild(svg.rect(shadow));
            //}
            if (node.shape && node.shape.templateId && $.templates) {
                var templates;
                templates = $.templates("#" + node.shape.templateId);
                var html = templates.render(node);
                this._renderSvgTemplate(node, svg, g, html);
            }
        },

        _fill: function (node, svg) {
            var fill;
            if (node.gradient) {
                fill = this._renderGradient(node.name, node.gradient, svg);
            }
            if (!fill) {
                fill = node.fillColor;
            }
            return fill;
        },

        _renderRect: function (node, svg, g) {
            var fill = this._fill(node, svg);
            var attr = {
                "id": node.name + "_shape", "rx": node.shape.cornerRadius, "ry": node.shape.cornerRadius,
                "width": node.width, "height": node.height, "fill": fill, "stroke": node.borderColor,
                "stroke-width": node.borderWidth, "opacity": node.opacity, "stroke-dasharray": node.borderDashArray, "filter": this._renderFilter(node, svg)
            };
            //if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
            //    var shadow = {
            //        "id": node.name + "_shadow", "rx": node.shape.cornerRadius, "ry": node.shape.cornerRadius,
            //        "width": node.width, "height": node.height, "stroke": "lightgrey", "fill": fill != "none" || fill != "transparent" ? "lightgrey" : "none",
            //        "transform": "translate(" + 5 + "," + 5 + ")", "opacity": 0.7
            //    };
            //    g.appendChild(svg.rect(shadow));
            //}
            g.appendChild(svg.rect(attr));
        },

        _renderEllipse: function (node, svg, g) {
            var fill = this._fill(node, svg);
            var attr = {
                "id": node.name + "_shape", "rx": node.width / 2, "ry": node.height / 2,
                "cx": node.width / 2, "cy": node.height / 2,
                "fill": fill, "stroke": node.borderColor, "stroke-width": node.borderWidth,
                "opacity": node.opacity, "stroke-dasharray": node.borderDashArray, "filter": this._renderFilter(node, svg)

            };
            //if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
            //    var shadow = {
            //        "id": node.name + "_shadow", "rx": node.width / 2, "ry": node.height / 2,
            //        "cx": node.width / 2, "cy": node.height / 2, "stroke": "lightgrey", "fill": fill != "none" || fill != "transparent" ? "lightgrey" : "none",
            //        "transform": "translate(" + 5 + "," + 5 + ")", "opacity": 0.7
            //    };
            //    g.appendChild(svg.ellipse(shadow));
            //}
            g.appendChild(svg.ellipse(attr));
        },

        _renderImage: function (node, svg, g) {
            var fill = node.fillColor;
            var backRect = this._renderBackgroundRect(node, svg);
            g.appendChild(backRect);
            var attr = {
                "id": node.name + "_shape", "width": node.width, "height": node.height,
                "opacity": node.opacity, "preserveAspectRatio": "none",
            };
            var shape = svg.image(attr);
            shape.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", node.shape.src);
            g.appendChild(shape);
        },

        _renderPolygon: function (node, svg, g) {
            var fill = this._fill(node, svg);
            ej.datavisualization.Diagram.Geometry.updatePolygonPoints(node);
            var points = this._convertToSVGPoints(node.shape.points);
            var attr = {
                "id": node.name + "_shape", "fill": fill, "stroke": node.borderColor,
                "stroke-width": node.borderWidth, "opacity": node.opacity,
                "stroke-dasharray": node.borderDashArray, "points": points, "filter": this._renderFilter(node, svg)
            };
            g.appendChild(svg.polygon(attr));
        },

        _renderPath: function (node, svg, g) {
            var fill = this._fill(node, svg);
            var d = ej.datavisualization.Diagram.Geometry.updatePath(0, 0, node.width, node.height, node.shape.pathData, svg);
            node._absolutePath = d;
            var attr = {
                "id": node.name + "_shape", "width": node.width,
                "height": node.height, "d": d, "opacity": node.opacity,
                "stroke-dasharray": node.borderDashArray, "stroke": node.borderColor,
                "stroke-width": node.borderWidth, "fill": fill, "filter": this._renderFilter(node, svg)

            };
            g.appendChild(svg.path(attr));
        },

        _renderHtmlElement: function (node, svg, g) {
            var backRect = this._renderBackgroundRect(node, svg);
            g.appendChild(backRect);
            if (node.shape && node.shape.templateId) {
                var x = node.offsetX - node.width * node.pivot.x;
                var y = node.offsetY - node.height * node.pivot.y;
                var div = document.createElement("div");
                var style = "width:" + node.width + "px;height:" + node.height + "px;padding:1px; opacity:" + node.opacity + ";left:" + x + "px; top:" + y + "px; ";
                if (ej.browserInfo().name === "msie")
                    style += "display: block; position: absolute; border:0px;";
                var attr = { "id": node.name + "_html", "class": "foreignObject", "style": style };
                ej.datavisualization.Diagram.Util.attr(div, attr);
                if (node.shape && node.shape.templateId) {
                    var tmplString = this._renderHTMLTemplate(node)
                    div.innerHTML = tmplString;
                }
                if (ej.browserInfo().name === "msie") {
                    var parentdiv = document.createElement("div");
                    var attr1 = { "id": node.name + "_parentdiv", "class": "ej-d-node" };
                    ej.datavisualization.Diagram.Util.attr(parentdiv, attr1);
                    parentdiv.appendChild(div);
                    var htmlLayer = svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                    if (htmlLayer)
                        htmlLayer.appendChild(parentdiv);
                    else
                        svg.document.parentNode.appendChild(div);
                }
                else {
                    attr = { "id": node.name + "_shape", "width": node.width, "height": node.height, "style": "pointer-events:none" };
                    var shape = svg.foreignObject(attr);
                    shape.appendChild(div);
                    g.appendChild(shape);
                }
            }
        },

        _initializeGuidelines: function (svg, attr, parent) {
            var g = svg.g(attr);
            parent.appendChild(g);
            return g;
        },

        _renderSideAlignmentLines: function (start, end, g, svg, scale) {
            var line = svg.line({
                "x1": start.x * scale, "y1": start.y * scale,
                "x2": end.x * scale, "y2": end.y * scale, "stroke": "#07EDE1", "stroke-width": 1
            });
            g.appendChild(line);
        },

        _renderCenterAlignmentLines: function (start, end, g, svg, scale) {
            var line = svg.line({
                "x1": start.x * scale, "y1": start.y * scale,
                "x2": end.x * scale, "y2": end.y * scale, "stroke": "#07EDE1", "stroke-width": 1,
            });
            g.appendChild(line);
        },

        _renderSpacingLines: function (start, end, g, svg, scale) {
            var d, d1;
            var div1 = svg.g({});
            if (start.x == end.x) {
                d = "M" + (start.x * scale - 5) + " " + (start.y * scale + 5) + " L" + start.x * scale + " " + start.y * scale + " L" + (start.x * scale + 5) + " " + (start.y * scale + 5) + "z";
                d1 = "M" + (end.x * scale - 5) + " " + (end.y * scale - 5) + " L" + end.x * scale + " " + end.y * scale + " L" + (end.x * scale + 5) + " " + (end.y * scale - 5) + "z";
                div1.appendChild(svg.line({ "x1": start.x * scale - 8, "x2": start.x * scale + 8, "y1": start.y * scale - 1, "y2": start.y * scale - 1, "stroke": "#07EDE1", "stroke-width": 1 }));
                div1.appendChild(svg.line({ "x1": end.x * scale - 8, "x2": end.x * scale + 8, "y1": end.y * scale + 1, "y2": end.y * scale + 1, "stroke": "#07EDE1", "stroke-width": 1 }));
            }
            else {
                d = "M" + (start.x * scale + 5) + " " + (start.y * scale + 5) + " L" + start.x * scale + " " + start.y * scale + " L" + (start.x * scale + 5) + " " + (start.y * scale - 5) + "z";
                d1 = "M" + (end.x * scale - 5) + " " + (end.y * scale - 5) + " L" + end.x * scale + " " + end.y * scale + " L" + (end.x * scale - 5) + " " + (end.y * scale + 5) + "z";
                div1.appendChild(svg.line({ "x1": start.x * scale - 1, "x2": start.x * scale - 1, "y1": start.y * scale - 8, "y2": start.y * scale + 8, "stroke": "#07EDE1", "stroke-width": 1 }));
                div1.appendChild(svg.line({ "x1": end.x * scale + 1, "x2": end.x * scale + 1, "y1": end.y * scale - 8, "y2": end.y * scale + 8, "stroke": "#07EDE1", "stroke-width": 1 }));
            }
            div1.appendChild(svg.path({ "d": d, "fill": "#07EDE1" }));
            var line = svg.line({
                "x1": start.x * scale, "y1": start.y * scale,
                "x2": end.x * scale, "y2": end.y * scale, "stroke": "#07EDE1", "stroke-width": 0.6, "fill": "#07EDE1"
            });
            div1.appendChild(line);
            div1.appendChild(svg.path({ "d": d1, "fill": "#07EDE1" }));
            g.appendChild(div1);
        },

        _removeGuidelines: function (parent, g) {
            if (g != null) {
                parent.removeChild(g);
            }
        },

        //#endregion

        //#region update
        update: function (data, diagram) {
            var svg = diagram._svg;
            if (data.type == "group")
                this.updateGroup(data, svg, diagram);
            else if (data.segments)
                this.updateConnector(data, svg, diagram);
            else
                this.updateNode(data, svg, diagram);
        },

        _updateGoupBackground: function (group, svg) {
            var x = group.offsetX - group.width / 2;
            var y = group.offsetY - group.height / 2;
            var angle = group.rotateAngle;
            var pt = new ej.datavisualization.Diagram.Point(x + group.width / 2, y + group.height / 2);
            var attr = {
                "id": group.name + "_shape",
                "rx": group.shape.cornerRadius,
                "ry": group.shape.cornerRadius,
                "width": group.width,
                "height": group.height,
                "fill": group.fillColor,
                "stroke": group.borderColor,
                "stroke-width": group.borderWidth,
                "opacity": group.opacity,
                "stroke-dasharray": group.borderDashArray,
                "transform": "rotate(" + angle + "," + pt.x + "," + pt.y + "),translate(" + x + "," + y + ")",
            };
            if (svg.getElementById((group.name + "_shape")))
                ej.datavisualization.Diagram.Util.attr(svg.getElementById((group.name + "_shape")), attr);
        },

        updateGroup: function (group, svg, diagram, layout) {
            var children = diagram._getChildren(group.children);
            var visible = group.visible ? "visible" : "hidden";
            var style = "display:block;"
            if (!(group.visible))
                style = "display:none;"


            svg.g({ "id": group.name, "visibility": "visible", "style": "display:block" });
            for (var i = 0, len = children.length; i < len; i++) {
                var child = diagram.nameTable[children[i]];
                if (child) {
                    if (child.type == "group")
                        this.updateGroup(child, svg, diagram, layout);
                    else if (child.segments)
                        this.updateConnector(child, svg, diagram);
                    else
                        this.updateNode(child, svg, diagram, layout);
                }
            }
            svg.g({ "id": group.name, "visibility": visible, "style": style });
            this._updateGoupBackground(group, svg);

            this._updateAssociatedConnector(group, svg, diagram);
            this._updateLabels(group, svg);
            this._updatePorts(group, svg);
            if (group.isSwimlane && diagram.model.phases && diagram.model.phases.length > 0) {
                var des = null;
                for (var j = 0; j < diagram.model.phases.length; j++) {
                    des = diagram.model.phases[j];
                    if (des.parent == group.name)
                        this._updatephase(des, diagram);
                }
            }
        },

        _removephases: function (group, diagram) {
            if (group.isSwimlane && diagram.model.phases && diagram.model.phases.length > 0) {
                var des = null;
                for (var j = diagram.model.phases.length - 1; j >= 0; j--) {
                    des = diagram.model.phases[j];
                    if (des) {
                        var element = diagram._svg.getElementById(des.name + "_phase");
                        if (element)
                            element.parentNode.removeChild(element);
                        ej.datavisualization.Diagram.Util.removeItem(diagram.model.phases, des);
                    }
                }
            }
        },

        _updatephase: function (node, diagram) {
            var parNode = diagram.nameTable[node.parent];
            if (parNode) {
                var tx = 0, ty = 0, transform = null;
                var points = [], nPoint;
                var bounds = ej.datavisualization.Diagram.Util.bounds(parNode);
                var children = diagram._getChildren(parNode.children);
                if (children.length > 1)
                    var header = diagram.nameTable[children[0]];
                var top = bounds.top + 50;
                var left = bounds.left + 50;
                var visibility = "visible";
                if (node.orientation == "vertical") {
                    tx = bounds.x;
                    ty = bounds.y + node.offset;
                    if (header)
                        top += header.height;
                    if (ty < bounds.bottom && ty > top) {
                        transform = "translate(" + tx + "," + ty + ")";
                    } else {
                        visibility = "hidden";
                    }
                    points.push({ x: 0, y: 0 });
                    points.push({ x: bounds.width, y: 0 });
                    nPoint = this._convertToSVGPoints(points);
                }
                else {
                    tx = bounds.x + node.offset;
                    ty = bounds.y;
                    if (tx < bounds.right && tx > left) {
                        transform = "translate(" + tx + "," + ty + ")";
                    }
                    else {
                        visibility = "hidden";
                    }
                    points.push({ x: 0, y: header.height });
                    points.push({ x: 0, y: bounds.height });
                    nPoint = this._convertToSVGPoints(points);
                }

                var attr = {
                    "points": nPoint,
                    "id": node.name + "_phase",
                };
                diagram._svg.polyline(attr);
                attr = {
                    "points": nPoint,
                    "id": node.name + "_phase_hitTest",
                };
                diagram._svg.polyline(attr);
                attr = {
                    "id": node.name,
                    "transform": transform,
                    "visibility": visibility
                }
                diagram._svg.g(attr);
                if (diagram._svg.getElementById(attr.id))
                    $('#' + attr.id).insertAfter($('#' + attr.id)[0].parentNode.lastChild);
            }
        },
        updateLabelStyle: function (node, label, svg) {
            var attr = {};
            if (node && svg && label) {
                if (label.bold)
                    attr["font-weight"] = "bold";
                else
                    attr["font-weight"] = "";

                if (label.italic)
                    attr["font-style"] = "italic";
                else
                    attr["font-style"] = "";

                if (label.textDecoration)
                    attr["text-decoration"] = label.textDecoration;
                attr["font-family"] = label.fontFamily;
                attr["font-size"] = label.fontSize;
                attr["fill"] = label.fontColor;
            }
            ej.datavisualization.Diagram.Util.attr(svg.getElementById(node.name + "_" + label.name), attr);
        },

        _updateNodeStyle: function (node, svg) {
            if (node && svg) {
                var attr = {};
                attr["opacity"] = node.opacity;
                attr["fill"] = node.fillColor;
                attr["stroke"] = node.borderColor;
                attr["stroke-width"] = node.borderWidth;
                attr["stroke-dasharray"] = node.borderDashArray;
                if (node.gradient)
                    attr["fill"] = this._renderGradient(node.name, node.gradient, svg);
                if (node.shape)
                    var type = node.shape.type == "text" ? "_backRect" : "_shape";
                if (ej.browserInfo().name === "msie" && node.shape && node.shape.type == "html") {
                    //ej.datavisualization.Diagram.Util.attr(svg.getElementById(node.name + "_html"), attr);
                } else {
                    if (svg.getElementById(node.name + type))
                        ej.datavisualization.Diagram.Util.attr(svg.getElementById(node.name + type), attr);
                }
            }
        },

        _updateConnectorStyle: function (connector, svg) {
            if (connector && svg) {
                var attr = {};
                attr["stroke"] = connector.lineColor;
                attr["stroke-width"] = connector.lineWidth;
                attr["stroke-dasharray"] = connector.lineDashArray;
                ej.datavisualization.Diagram.Util.attr(svg.getElementById(connector.name + "_segments"), attr);
            }
        },

        updateTargetDecoratorStyle: function (connector, svg) {
            if (svg) {
                var attr = {};
                attr["stroke"] = connector.targetDecorator.borderColor;
                attr["fill"] = connector.targetDecorator.fillColor;
                ej.datavisualization.Diagram.Util.attr(svg.getElementById(connector.name + "_targetDecorator"), attr);
            }
        },

        updateSourceDecoratorStyle: function (connector, svg) {
            if (svg) {
                var attr = {};
                attr["stroke"] = connector.sourceDecorator.borderColor;
                attr["fill"] = connector.sourceDecorator.fillColor;
                ej.datavisualization.Diagram.Util.attr(svg.getElementById(connector.name + "_sourceDecorator"), attr);
            }
        },

        updateNode: function (node, svg, diagram, layout) {
            var g, bounds;
            if (node.shape.type === "html" && ej.browserInfo().name === "msie") {
                g = document.getElementById(node.name + "_html").getBoundingClientRect();
                bounds = { x: g.left, y: g.top, width: g.width, height: g.height };
            }
            else
                g = svg.getElementById(node.name + "_shape");
            if (g && !bounds)
                bounds = g.getBBox();
            this._updateNode(node, svg);
            if (diagram._layoutInAction) return;
            this._updateAssociatedConnector(node, svg, diagram);
            if (!diagram.activeTool.inAction || diagram.activeTool.name !== "move" && diagram.activeTool.name !== "rotate") {
                this._updateLabels(node, svg);
                if (bounds && (bounds && bounds.width != node.width || bounds.height != node.height)) {
                    this._updatePorts(node, svg);
                }
            }
        },

        updateTextBlock: function (node, label, svg) {
            var attr = {};
            var label = node.shape.textBlock;
            node.shape.textBlock = label;
            if (node && svg && label) {
                if (label.bold)
                    attr["font-weight"] = "bold";
                else
                    attr["font-weight"] = "";

                if (label.italic)
                    attr["font-style"] = "italic";
                else
                    attr["font-style"] = "";

                if (label.textDecoration)
                    attr["text-decoration"] = label.textDecoration;
                attr["font-family"] = label.fontFamily;
                attr["font-size"] = label.fontSize;
                attr["fill"] = label.fontColor;
            }
            ej.datavisualization.Diagram.Util.attr(svg.getElementById(node.name + "_shape"), attr);
            this._updateTextElement(node, svg);
        },

        _updateAssociatedConnector: function (node, svg, diagram) {
            var i, len;
            for (i = 0, len = node.inEdges.length; i < len; i++) {
                if (diagram.nameTable[node.inEdges[i]]) {
                    if (diagram.nameTable[node.inEdges[i]] && ej.datavisualization.Diagram.Util.canBridge(diagram.nameTable[node.inEdges[i]], diagram)) {
                        ej.datavisualization.Diagram.Util.updateBridging(diagram.nameTable[node.inEdges[i]], diagram);
                        diagram._updateConnectorBridging(diagram.nameTable[node.inEdges[i]]);
                    }
                    ej.datavisualization.Diagram.DiagramContext.update(diagram.nameTable[node.inEdges[i]], diagram);
                }
            }
            for (i = 0, len = node.outEdges.length; i < len; i++) {
                if (diagram.nameTable[node.outEdges[i]]) {
                    if (diagram.nameTable[node.outEdges[i]] && ej.datavisualization.Diagram.Util.canBridge(diagram.nameTable[node.outEdges[i]], diagram)) {
                        ej.datavisualization.Diagram.Util.updateBridging(diagram.nameTable[node.outEdges[i]], diagram);
                        diagram._updateConnectorBridging(diagram.nameTable[node.outEdges[i]]);
                    }
                    ej.datavisualization.Diagram.DiagramContext.update(diagram.nameTable[node.outEdges[i]], diagram);
                }
            }
        },

        _updateNode: function (node, svg, layout) {
            var x = node.offsetX - node.width * node.pivot.x;
            var y = node.offsetY - node.height * node.pivot.y;
            var angle = node.rotateAngle;
            var pt = ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY);
            var visible = node.visible ? "visible" : "hidden";
            var attr = ({
                "id": node.name, "transform": "rotate(" + angle + "," + pt.x + "," + pt.y + "),translate(" + x + "," + y + ")",
                "visibility": visible
            });
            svg.g(attr);
            switch (node.shape.type) {
                case "rectangle":
                    svg.rect({
                        "id": node.name + "_shape", "width": node.width, "height": node.height,
                    });
                    break;
                case "ellipse":
                    svg.ellipse({
                        "id": node.name + "_shape", "rx": node.width / 2, "ry": node.height / 2,
                        "cx": node.width / 2, "cy": node.height / 2
                    });
                    break;
                case "image":
                    this._updateBackgroundRect(node, svg);
                    svg.image({
                        "id": node.name + "_shape", "width": node.width, "height": node.height,
                    });
                    break;
                case "path":
                    var d = ej.datavisualization.Diagram.Geometry.updatePath(0, 0, node.width, node.height, node.shape.pathData, svg);
                    node._absolutePath = d;
                    svg.path({
                        "id": node.name + "_shape", "d": d,
                    });
                    break;
                case "polygon":
                    this._updatePolygon(node, svg);
                    break;
                case "text":
                    this._updateTextElement(node, svg);
                    break;
                case "html":
                    this._updateHtmlElement(node, svg);
                    break;
                case "native":
                    if (!$("#" + node.name + "_shape")[0]) {
                        var bounds = { width: node.width, height: node.height };
                    } else {
                        var bounds = $("#" + node.name + "_shape")[0].getBBox();
                    }
                    var delwidth = bounds.width ? node.width / bounds.width : 1;
                    var delheight = bounds.height ? node.height / bounds.height : 1;
                    svg.g({
                        "id": node.name + "_shape", "width": node.width, "height": node.height,
                        "transform": "scale(" + delwidth + "," + delheight + ")"
                    });
                    break;
            }
        },

        _updateHtmlElement: function (node, svg) {
            this._updateBackgroundRect(node, svg);
            var div;
            if (ej.browserInfo().name === "msie") {
                var x = node.offsetX - node.width * node.pivot.x;
                var y = node.offsetY - node.height * node.pivot.y;
                div = document.getElementById(node.name + "_html");
                div.style.left = x + "px";
                div.style.top = y + "px";
                div.style.transform = "rotate(" + node.rotateAngle + "deg)";
            }
            else {
                div = svg.getElementById(node.name + "_shape");
                svg.foreignObject({
                    "id": node.name, "width": node.width, "height": node.height
                });
            }
            div.style.width = node.width.toString() + "px";
            div.style.height = node.height.toString() + "px";
        },

        _updatePolygon: function (node, svg) {
            ej.datavisualization.Diagram.Geometry.updatePolygonPoints(node);
            svg.polygon({
                "id": node.name + "_shape", "points": this._convertToSVGPoints(node.shape.points)
            });
        },

        _convertToSVGPoints: function (points) {
            var pts = "";
            for (var i = 0, len = points.length; i < len; i++) {
                pts += points[i].x + "," + points[i].y + " ";
            }
            return pts.trim();
        },

        _renderTextElement: function (node, svg, g) {
            var textElement = node.shape.textBlock;
            if (textElement) {
                var backRect = this._renderBackgroundRect(node, svg);
                g.appendChild(backRect);
                var attr = {
                    "id": node.name + "_shape", "class": "ej-d-label", "font-family": textElement.fontFamily,
                    "font-size": textElement.fontSize, "fill": textElement.fontColor,
                    "text-decoration": textElement.textDecoration, "opacity": node.opacity,
                    "alignment-baseline": "middle"
                };
                if (textElement.bold)
                    attr["font-weight"] = "bold";
                if (textElement.italic)
                    attr["font-style"] = "italic";
                var text = svg.text(attr);
                text.appendChild(document.createTextNode(textElement.text));
                g.appendChild(text);
                var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                this._wrapText(node, bounds, text, node.shape.textBlock, svg);
                this._alignTextOnLabel(node, bounds, text, node.shape.textBlock, svg);
                this._renderShadow(node, svg, g);
            }
        },

        _updateTextElement: function (node, svg) {
            this._updateBackgroundRect(node, svg);
            var text = svg.getElementById(node.name + "_shape");
            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
            this._wrapText(node, bounds, text, node.shape.textBlock, svg);
            this._alignTextOnLabel(node, bounds, text, node.shape.textBlock, svg);
        },

        _renderBackgroundRect: function (node, svg) {
            var fill = this._fill(node, svg);
            var attr = {
                "id": node.name + "_backRect", "class": "backrect", "x": 0, "y": 0,
                "width": node.width, "height": node.height, "fill": fill,
                "stroke": node.borderColor, "stroke-width": node.borderWidth, "opacity": node.opacity,
                "stroke-dasharray": node.borderDashArray, "filter": this._renderFilter(node, svg)
            };
            return svg.rect(attr);
        },

        _updateBackgroundRect: function (node, svg) {
            var attr = {
                "id": node.name + "_backRect", "x": 0, "y": 0,
                "width": node.width, "height": node.height,
            };
            svg.rect(attr);
        },

        _hideNode: function (node, svg) {
            var attr = { "id": node.name, "style": "pointer-events:none;" };
            svg.rect(attr);
        },

        _showNode: function (node, svg) {
            var attr = { "id": node.name, "style": "pointer-events:auto;" };
            svg.rect(attr);
        },

        _drawContainerHelper: function (diagram) {
            var shape = diagram.activeTool.helper;
            var svg = diagram._svg;
            var scale = diagram._currZoom;
            if (shape)
                var bounds = ej.datavisualization.Diagram.Util.bounds(shape);
            var height = shape.height ? shape.height : bounds.height;
            var width = shape.width ? shape.width : bounds.width;
            var offsetX = shape.offsetX ? (shape.offsetX) : (bounds.x + bounds.width / 2);
            var offsetY = shape.offsetY ? (shape.offsetY) : (bounds.y + bounds.height / 2);
            var rotateAngle = shape.rotateAngle ? shape.rotateAngle : 0;
            var rect = svg.rect({
                "id": "helper", "class": "helper",
                "stroke-width": 1, "stroke-dasharray": "3,3", "pointer-events": "none",
                "width": width * scale, "height": height * scale, "fill": "transparent", "stroke": "red",
                "transform": "translate(" + (offsetX - width / 2) * scale + "," + (offsetY - height / 2) * scale + "),rotate(" + rotateAngle + "," + (width / 2) * scale + "," + (height / 2) * scale + ")"
            });
            diagram._adornerLayer.appendChild(rect);
        },

        _updateContainerHelper: function (diagram) {

            var attr = null;
            var shape = diagram.activeTool.helper;
            var scale = diagram._currZoom;
            if (shape)
                var bounds = ej.datavisualization.Diagram.Util.bounds(shape);
            var height = shape.height ? shape.height : bounds.height;
            var width = shape.width ? shape.width : bounds.width;
            var offsetX = shape.offsetX ? (shape.offsetX) : (bounds.x + bounds.width / 2);
            var offsetY = shape.offsetY ? (shape.offsetY) : (bounds.y + bounds.height / 2);
            var rotateAngle = shape.rotateAngle ? shape.rotateAngle : 0;
            attr = {
                "id": "helper", "class": "helper",
                "width": width * scale, "height": height * scale, "fill": "transparent", "stroke": "red",
                "transform": "translate(" + (offsetX - width / 2) * scale + "," + (offsetY - height / 2) * scale + "),rotate(" + rotateAngle + "," + (width / 2) * scale + "," + (height / 2) * scale + ")"
            };
            diagram._svg.rect(attr);
        },

        _removeContainerHelper: function (node, svg, parent) {
            if (svg.getElementById("helper"))
                svg.removeChild(svg.getElementById("helper"), parent);
        },
        //#endregion

        setNodeShape: function (node, svg, parent) {
            var g;
            if (parent) {
                var parentg = svg.getElementById(parent.name);
                g = $(parentg).find("#" + node.name)[0];
            }
            else {
                g = svg.getElementById(node.name);
            }
            $(g).empty();
            this._renderNode(node, svg, g);
        },

        setLine: function (connector, svg, parent, diagram) {
            var g;
            if (parent) {
                var parentg = svg.getElementById(parent.name);
                g = $(parentg).find("#" + connector.name)[0];
            }
            else {
                g = svg.getElementById(connector.name);
            }
            $(g).empty();

            this.renderConnector(connector, svg, g, diagram);
        },

        addNodeLabel: function (node, label, svg, parent) {
            var g;
            if (parent) {
                var parentg = svg.getElementById(parent.name);
                g = $(parentg).find("#" + node.name)[0];
            }
            else {
                g = svg.getElementById(node.name);
            }
            this._renderLabel(node, label, svg, g);
        },
        //#endregion

        //#region Render Connector
        renderConnector: function (connector, svg, parent, diagram) {
            var g;
            var line;
            var visible = connector.visible ? "visible" : "hidden";
            //if (connector.visible) 
            {
                g = svg.g({ "id": connector.name, "class": "ej-d-connector", "visibility": visible });
                if (parent) {
                    if (parent.id !== g.id) {
                        parent.appendChild(g);
                    }
                }
                else {
                    svg.appendChild(g);
                }
                var seg = svg.g({ "id": connector.name + "segments" });
                this._renderSegments(connector, svg, seg, diagram);

                g.appendChild(seg);
                this._renderLabels(connector, svg, g);
                this._renderDecorators(connector, svg, g, diagram);
            }
            return g;
        },
        _renderSegments: function (connector, svg, g, diagram) {
            var visibility = (ej.browserInfo().name === "msie") ? "collapse" : "hidden";

            var path = this._findPath(connector, diagram);
            var attr = {
                "id": connector.name + "_segments",
                "d": path, "fill": "none", "stroke": connector.lineColor,
                "stroke-width": connector.lineWidth, "stroke-dasharray": connector.lineDashArray, "opacity": connector.opacity
            };
            var line = svg.path(attr);
            g.appendChild(line);
            attr = { "id": connector.name + "_hitTest", "class": "hitTest", "stroke-width": connector.lineHitPadding, "d": path, "pointer-events": "stroke", "stroke": "transparent", "visibility": visibility };
            line = svg.path(attr);
            g.appendChild(line);
        },

        _findPath: function (connector, diagram) {
            var st, end, path;
            for (var i = 0; i < connector.segments.length; i++) {
                var seg = connector.segments[i];
                if (seg._bridges.length > 0) {
                    for (var n = 0; n < seg._bridges.length; n++) {
                        var bridge = seg._bridges[n];
                        bridge._rendered = false;
                    }
                }
                var points = seg.points;
                if (i == 0) {
                    if (diagram && connector.sourceNode) var node = diagram._findNode(connector.sourceNode);
                    points = this._clipDecorators(connector, seg, true, node);
                    if (seg.type == "bezier" && connector.sourceDecorator && connector.sourceDecorator.shape !== ej.datavisualization.Diagram.DecoratorShapes.None) {
                        points[0] = ej.datavisualization.Diagram.Util._adjustPoint(points[0], seg._point1, true, connector.lineWidth);
                    }
                    path = "M" + points[0].x + " " + points[0].y;
                }
                if (i == connector.segments.length - 1) {
                    if (diagram && connector.targetNode) var node = diagram._findNode(connector.targetNode);
                    points = this._clipDecorators(connector, seg, false, node);
                }
                if (seg.type != "bezier") {
                    if (connector.cornerRadius > 0) {
                        for (var j = 0; j < points.length - 1; j++) {
                            var segLength = ej.datavisualization.Diagram.Geometry.distance(points[j], points[j + 1]);
                            if (segLength > 0) {
                                if (i < connector.segments.length - 1 || j < points.length - 2) {
                                    if (segLength < connector.cornerRadius * 2) {
                                        end = ej.datavisualization.Diagram.Util._adjustPoint(points[j], points[j + 1], false, segLength / 2);
                                    }
                                    else end = ej.datavisualization.Diagram.Util._adjustPoint(points[j], points[j + 1], false, connector.cornerRadius);
                                }
                                else end = points[j + 1];

                                if (i > 0 || j > 0) {
                                    if (segLength < connector.cornerRadius * 2) {
                                        st = ej.datavisualization.Diagram.Util._adjustPoint(points[j], points[j + 1], true, segLength / 2);
                                        if (i < connector.segments.length - 1 || j < points.length - 2)
                                            end = null;
                                    }
                                    else st = ej.datavisualization.Diagram.Util._adjustPoint(points[j], points[j + 1], true, connector.cornerRadius);
                                }

                                if (st) {
                                    path += " Q" + points[j].x + " " + points[j].y + " " + st.x + " " + st.y;
                                }
                                if (end) {
                                    if (seg._bridges.length > 0) {
                                        path = this._updateBridging(seg, path, j);
                                        if (seg.type === "orthogonal")
                                            path = this._updateBridging(seg, path, j + 1);
                                    }
                                    path += " L" + end.x + " " + end.y;
                                }
                            }
                        }
                    }
                    else {
                        for (var j = 0; j < points.length; j++) {
                            if (j > 0) {
                                path = this._updateBridging(seg, path, j);
                                path += " L" + points[j].x + " " + points[j].y;
                            }
                        }
                    }
                }
                else {
                    var endPoint = seg._endPoint;
                    if (connector.targetDecorator && connector.targetDecorator.shape !== ej.datavisualization.Diagram.DecoratorShapes.None) {
                        endPoint = ej.datavisualization.Diagram.Util._adjustPoint(seg._endPoint, seg._point2, true, connector.lineWidth);
                    }
                    if (connector.targetNode && diagram) {
                        var targetNode = diagram._findNode(connector.targetNode);
                        if (node.borderColor != "none")
                            endPoint = ej.datavisualization.Diagram.Util._adjustPoint(endPoint, seg._point2, true, targetNode.borderWidth / 2);
                    }
                    path += " C" + seg._point1.x + " " + seg._point1.y + " " + seg._point2.x + " " + seg._point2.y + " " + endPoint.x + " " + endPoint.y;
                }
            }
            return path;
        },

        _updateBridging: function (seg, path, pointIndex) {
            var pathData = path;
            if (seg._bridges.length > 0) {
                if (seg.type === "straight") {
                    for (var n = 0; n < seg._bridges.length; n++) {
                        var bridge = seg._bridges[n];
                        if (!bridge._rendered) {
                            pathData += " L" + bridge.startPoint.x + " " + bridge.startPoint.y;
                            pathData += bridge.path;
                        }
                    }
                }
                else if (seg.type === "orthogonal") {
                    for (var n = 0; n < seg._bridges.length; n++) {
                        var bridge = seg._bridges[n];
                        if (bridge.segmentPointIndex === pointIndex && !bridge._rendered) {
                            pathData += " L" + bridge.startPoint.x + " " + bridge.startPoint.y;
                            pathData += bridge.path;
                            bridge._rendered = true;
                        }
                    }
                }
            }
            return pathData;
        },

        _refreshSegments: function (connector, svg, diagram) {
            this._updateConnector(connector, svg, diagram);
            this._updateDecorators(connector, svg, diagram);
        },

        _clipDecorators: function (connector, segment, source, node) {
            var points = $.extend(true, [], segment.points);
            if (!source && connector.targetDecorator && connector.targetDecorator.shape !== ej.datavisualization.Diagram.DecoratorShapes.None) {
                var start, end;
                start = points[points.length - 1];
                end = points[points.length - 2];
                var len = ej.datavisualization.Diagram.Geometry.distance(start, end);
                len = (len == 0) ? 1 : len;
                var width = 2 * connector.lineWidth;
                var newPoint = ej.datavisualization.Diagram.Point();
                newPoint.x = start.x + width * (end.x - start.x) / len;
                newPoint.y = start.y + width * (end.y - start.y) / len;
                if (node && node.borderColor != "none")
                    newPoint = ej.datavisualization.Diagram.Util._adjustPoint(newPoint, end, true, node.borderWidth / 2);
                points[points.length - 1] = newPoint;
            }
            else if (source && connector.sourceDecorator && connector.sourceDecorator.shape !== ej.datavisualization.Diagram.DecoratorShapes.None) {
                start = points[0];
                end = points[1];
                var len = ej.datavisualization.Diagram.Geometry.distance(start, end);
                len = (len == 0) ? 1 : len;
                var width = 2 * connector.lineWidth;
                var newPoint = ej.datavisualization.Diagram.Point();
                newPoint.x = start.x + width * (end.x - start.x) / len;
                newPoint.y = start.y + width * (end.y - start.y) / len;
                if (segment.type == "bezier") {
                    var len = ej.datavisualization.Diagram.Geometry.distance(start, end);
                    newPoint.x = start.x + (segment._point1.x - start.x) / len;
                    newPoint.y = start.y + (segment._point1.y - start.y) / len;
                }
                if (node && node.borderColor != "none")
                    newPoint = ej.datavisualization.Diagram.Util._adjustPoint(newPoint, segment.type != "bezier" ? end : segment._point1, true, node.borderWidth / 2);
                points[0] = newPoint;
            }
            else if (source) {
                if (node && node.borderColor != "none")
                    points[0] = ej.datavisualization.Diagram.Util._adjustPoint(points[0], points[1], true, node.borderWidth / 2);
            }
            else {
                if (node && node.borderColor != "none")
                    points[points.length - 1] = ej.datavisualization.Diagram.Util._adjustPoint(points[points.length - 1], points[points.length - 2], true, node.borderWidth / 2);
            }
            return points;
        },

        _updateConnector: function (connector, svg, diagram) {
            var path = this._findPath(connector, diagram);
            svg.path({ "id": connector.name + "_segments", "d": path });
            svg.path({ "id": connector.name + "_hitTest", "d": path });
        },

        updateConnector: function (connector, svg, diagram) {
            //var svg = diagram._svg;
            var visible = connector.visible ? "visible" : "hidden";
            svg.g({ "id": connector.name, "visibility": visible });
            this._updateConnector(connector, svg, diagram);
            this._updateLabels(connector, svg);
            this._updateDecorators(connector, svg, diagram);
        },

        renderDecorators: function (connector, svg, diagram) {
            var g = svg.getElementById(connector.name);
            this._renderDecorators(connector, svg, g, diagram);
        },
        clearDecorators: function (connector, svg, diagram) {
            this._updateConnector(connector, svg, diagram);
            var g = svg.getElementById(connector.name);
            var dec = svg.getElementById(connector.name + "_targetDecorator");
            if (dec)
                svg.removeChild(dec, g);
            dec = svg.getElementById(connector.name + "_sourceDecorator");
            if (dec)
                svg.removeChild(dec, g);
        },
        //#endregion

        //#region Render Decorator
        _renderDecorators: function (connector, svg, g, diagram) {
            var startPoint;
            var endPoint;
            if (connector.targetDecorator && connector.targetDecorator.shape) {
                var segment = connector.segments[connector.segments.length - 1];
                startPoint = segment.points[segment.points.length - 2];
                endPoint = connector.targetPoint;
                if (segment.type == "bezier") {
                    startPoint = segment._point2;
                }
                if (connector.targetNode && diagram) {
                    var targetNode = diagram._findNode(connector.targetNode);
                    if (targetNode && targetNode.borderColor != "none")
                        endPoint = ej.datavisualization.Diagram.Util._adjustPoint(endPoint, startPoint, true, targetNode.borderWidth / 2);
                }
                this._renderDecorator(connector.name + "_targetDecorator", endPoint,
                    startPoint, connector, connector.targetDecorator, svg, g);
            }
            if (connector.sourceDecorator && connector.sourceDecorator.shape) {
                var segment = connector.segments[0];
                startPoint = connector.sourcePoint;
                endPoint = segment.points[1];
                if (segment.type == "bezier") {
                    endPoint = segment._point1;
                }
                if (connector.sourceNode && diagram) {
                    var sourceNode = diagram._findNode(connector.sourceNode);
                    if (sourceNode && sourceNode.borderColor != "none")
                        startPoint = ej.datavisualization.Diagram.Util._adjustPoint(startPoint, endPoint, true, sourceNode.borderWidth / 2);
                }
                this._renderDecorator(connector.name + "_sourceDecorator", startPoint,
                    endPoint, connector, connector.sourceDecorator, svg, g);
            }
        },

        _renderDecorator: function (name, point1, point2, connector, decorator, svg, g) {
            var shape;
            var attr;
            var d, x;
            var size = ej.datavisualization.Diagram.Size(decorator.width, decorator.height);
            switch (decorator.shape) {
                case "arrow":
                    d = this._constructArrow(point1, size);
                    attr = { "id": name, "class": "decorator", "d": d, "fill": decorator.fillColor, "stroke": decorator.borderColor, "stroke-width": connector.lineWidth };
                    shape = svg.path(attr);
                    x = 1.1 * connector.lineWidth;
                    break;
                case "openarrow":
                    d = this._constructArrow(point1, size, true);
                    attr = { "id": name, "class": "decorator", "d": d, "fill": "transparent", "stroke": decorator.borderColor, "stroke-width": connector.lineWidth };
                    shape = svg.path(attr);
                    x = 1.1 * connector.lineWidth;
                    break;
                case "circle":
                    var rx = size.width / 2;
                    var ry = size.height / 2;
                    attr = {
                        "id": name, "class": "decorator", "rx": rx, "ry": ry, "cx": (point1.x + size.width / 2), "cy": (point1.y),
                        "fill": decorator.fillColor, "stroke": decorator.borderColor, "stroke-width": connector.lineWidth
                    };
                    shape = svg.ellipse(attr);
                    x = 0.5 * connector.lineWidth;
                    break;
                case "diamond":
                    d = this._constructDiamond(point1, size, svg);
                    attr = {
                        "id": name, "class": "decorator", "x": point1.x, "y": point1.y, "width": size.width,
                        "height": size.height, "d": d, "fill": decorator.fillColor, "stroke": decorator.borderColor, "stroke-width": connector.lineWidth
                    };
                    shape = svg.path(attr);
                    x = 0.7 * connector.lineWidth;
                    break;
                case "path":
                    d = ej.datavisualization.Diagram.Geometry.updatePath(point1.x, point1.y - size.height / 2, size.width, size.height, decorator.pathData, svg);
                    attr = {
                        "id": name, "class": "decorator", "x": point1.x, "y": point1.y, "width": size.width,
                        "height": size.height, "d": d, "fill": decorator.fillColor, "stroke": decorator.borderColor, "stroke-width": connector.lineWidth
                    };
                    shape = svg.path(attr);
                    x = 0.5 * connector.lineWidth;
                    break;
            }
            //apply translate matrix and rotate matrix here
            if (shape) {
                if (decorator.borderColor != "none") {
                    var angle = ej.datavisualization.Diagram.Geometry.findAngle(point1, point2);
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, angle);
                    var extra = ej.Matrix.transform(matrix, { x: x, y: 0 });
                    shape.setAttribute("transform", "translate(" + extra.x + "," + extra.y + "),rotate(" + angle + " " + point1.x + " " + point1.y + ")");
                }
                else
                    shape.setAttribute("transform", "rotate(" + ej.datavisualization.Diagram.Geometry.findAngle(point1, point2) + " " + point1.x + " " + point1.y + ")");
                g.appendChild(shape);
            }
        },

        _updateDecorators: function (connector, svg, diagram) {
            var startPoint;
            var endPoint;
            if (connector.targetDecorator && connector.targetDecorator.shape !== ej.datavisualization.Diagram.DecoratorShapes.None) {
                var segment = connector.segments[connector.segments.length - 1];
                var points = segment.points;
                startPoint = points[points.length - 2];
                endPoint = connector.targetPoint;
                if (segment.type == "bezier") {
                    startPoint = segment._point2;
                }
                if (connector.targetNode && diagram) {
                    var targetNode = diagram._findNode(connector.targetNode);
                    if (targetNode && targetNode.borderColor != "none")
                        endPoint = ej.datavisualization.Diagram.Util._adjustPoint(connector.targetPoint, startPoint, true, targetNode.borderWidth / 2);
                }
                this._updateDecorator(connector.name + "_targetDecorator", endPoint, startPoint, connector, connector.targetDecorator, svg);
            }
            if (connector.sourceDecorator && connector.sourceDecorator.shape !== ej.datavisualization.Diagram.DecoratorShapes.None) {
                var segment = connector.segments[0];
                var points = segment.points;
                startPoint = connector.sourcePoint;
                endPoint = points[1];
                if (segment.type == "bezier") {
                    endPoint = segment._point1;
                }
                if (connector.sourceNode && diagram) {
                    var sourceNode = diagram._findNode(connector.sourceNode);
                    if (sourceNode.borderColor != "none")
                        startPoint = ej.datavisualization.Diagram.Util._adjustPoint(connector.sourcePoint, endPoint, true, sourceNode.borderWidth / 2);
                }
                this._updateDecorator(connector.name + "_sourceDecorator", startPoint, endPoint, connector, connector.sourceDecorator, svg);
            }
        },

        _updateDecorator: function (name, point1, point2, connector, decorator, svg) {
            var shape;
            var attr;
            var d, x;
            var size = ej.datavisualization.Diagram.Size(decorator.width, decorator.height);

            switch (decorator.shape) {
                case "arrow":
                    d = this._constructArrow(point1, size);
                    attr = { "id": name, "d": d };
                    shape = svg.path(attr);
                    x = 1.1 * connector.lineWidth;
                    break;
                case "openarrow":
                    d = this._constructArrow(point1, size, true);
                    attr = { "id": name, "d": d };
                    shape = svg.path(attr);
                    x = 1.1 * connector.lineWidth;
                    break;
                case "circle":
                    var rx = size.width / 2;
                    var ry = size.height / 2;
                    attr = { "id": name, "rx": rx, "ry": ry, "cx": (point1.x + size.width / 2), "cy": (point1.y) };
                    shape = svg.ellipse(attr);
                    x = 0.5 * connector.lineWidth;
                    break;
                case "diamond":
                    d = this._constructDiamond(point1, size, svg);
                    attr = { "id": name, "x": point1.x, "y": point1.y, "width": size.width, "height": size.height, "d": d };
                    shape = svg.path(attr);
                    x = 0.7 * connector.lineWidth;
                    break;
                case "path":
                    d = ej.datavisualization.Diagram.Geometry.updatePath(point1.x, point1.y - size.height / 2, size.width, size.height, decorator.pathData, svg);
                    attr = {
                        "id": name, "x": point1.x, "y": point1.y, "width": size.width, "height": size.height, "d": d
                    };
                    shape = svg.path(attr);
                    x = 0.5 * connector.lineWidth;
                    break;
            }
            //apply translate matrix and rotate matrix here
            if (shape) {
                if (decorator.borderColor != "none") {
                    var angle = ej.datavisualization.Diagram.Geometry.findAngle(point1, point2);
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, angle);
                    var extra = ej.Matrix.transform(matrix, { x: x, y: 0 });
                    shape.setAttribute("transform", "translate(" + extra.x + "," + extra.y + "),rotate(" + angle + " " + point1.x + " " + point1.y + ")");
                }
                else
                    shape.setAttribute("transform", "rotate(" + ej.datavisualization.Diagram.Geometry.findAngle(point1, point2) + " " + point1.x + " " + point1.y + ")");
            }
        },

        _constructArrow: function (point, size, isOpen) {
            var path = new ej.datavisualization.Diagram.Path();
            path.moveTo(point.x + size.width, point.y + size.height / 2);
            path.lineTo(point.x, point.y);
            path.lineTo(point.x + size.width, point.y - size.height / 2);
            if (!isOpen) {
                path.close();
            }
            return path.toString();
        },

        _constructDiamond: function (point, size, svg) {
            var path = new ej.datavisualization.Diagram.Path();
            path.moveTo(point.x + size.width, point.y);
            path.lineTo(point.x + size.width / 2, point.y + size.height / 2);
            path.lineTo(point.x, point.y);
            path.lineTo(point.x + size.width / 2, point.y - size.height / 2);
            path.lineTo(point.x + size.width, point.y);
            var d = path.toString();
            return d;
        },
        //#endregion

        //#region Render Label
        _renderLabels: function (node, svg, g) {
            var labels = node.labels;
            for (var i = 0, len = labels.length; i < len; ++i) {
                this._renderLabel(node, labels[i], svg, g);
            }
        },

        _renderLabelBackground: function (label, node, text, svg) {
            var bounds;
            //if (ej.browserInfo().name === "mozilla")
            //    bounds = text.getBoundingClientRect();
            //else
            bounds = text.getBBox();
            var attr = {
                "id": node.name + "_" + label.name + "_lblbg",
                "width": bounds.width, "height": bounds.height, "fill": label.fillColor,
                "stroke": label.borderColor, "stroke-width": label.borderWidth, "transform": "translate(" + 0 + "," + 0 + ")"
            };
            return svg.rect(attr);
        },

        _renderLabel: function (node, label, svg, g) {
            var attr = {
                "id": node.name + "_" + label.name, "class": "ej-d-label", "font-family": label.fontFamily,
                "font-size": label.fontSize, "fill": label.fontColor, "text-decoration": label.textDecoration,
                "dominant-baseline": "middle", "pointer-events": "none"
            };
            if (label.bold)
                attr["font-weight"] = "bold";
            if (label.italic)
                attr["font-style"] = "italic";
            var text = svg.text(attr);
            text.textContent = label.text;
            g.appendChild(text);
            var bg = this._renderLabelBackground(label, node, text, svg);
            g.insertBefore(bg, text);
            if (!label.text)
                return;
            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
            this._wrapText(node, bounds, text, label, svg);
            this._alignTextOnLabel(node, bounds, text, label, svg);
        },

        _updateLabels: function (node, svg) {
            var labels = node.labels;
            for (var i = 0, len = labels.length; i < len; ++i) {
                var label = labels[i];
                var text = svg.getElementById(node.name + "_" + label.name);
                if (text && text.textContent != "") {
                    text.setAttribute("fill", label.fontColor);
                    var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                    this._wrapText(node, bounds, text, label, svg);
                    this._alignTextOnLabel(node, bounds, text, label, svg);
                }
            }
        },

        updateLabel: function (node, label, svg) {
            var text = svg.getElementById(node.name + "_" + label.name);
            if (text) {
                text.setAttribute("fill", label.fontColor);
                if (!label.text)
                    return;
                text.textContent = label.text;
                var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                this._wrapText(node, bounds, text, label, svg);
                this._alignTextOnLabel(node, bounds, text, label, svg);
            }
        },

        _alignTextOnLabel: function (node, nodeBounds, text, label, svg) {
            var bounds = text.getBBox();
            var offset = ej.datavisualization.Diagram.Util._getLabelPosition(label, nodeBounds);
            var point = { x: 0, y: 0 };
            var y = 0;

            if (label.verticalAlignment == ej.datavisualization.Diagram.VerticalAlignment.Top)
                y = offset.y;
            else if (label.verticalAlignment == ej.datavisualization.Diagram.VerticalAlignment.Center)
                y = offset.y - bounds.height / 2;
            else
                y = offset.y - bounds.height;
            point.y = y;

            switch (label.horizontalAlignment) {
                case ej.datavisualization.Diagram.HorizontalAlignment.Left:
                    switch (label.textAlign) {
                        case ej.datavisualization.Diagram.TextAlign.Left:
                            point.x = offset.x;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Center:
                            point.x = offset.x + bounds.width / 2;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Right:
                            point.x = offset.x + bounds.width;
                            break;
                    }
                    break;
                case ej.datavisualization.Diagram.HorizontalAlignment.Center:
                    switch (label.textAlign) {
                        case ej.datavisualization.Diagram.TextAlign.Left:
                            point.x = offset.x - bounds.width / 2;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Center:
                            point.x = offset.x;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Right:
                            point.x = offset.x + bounds.width / 2;
                            break;
                    }
                    break;
                case ej.datavisualization.Diagram.HorizontalAlignment.Right:
                    switch (label.textAlign) {
                        case ej.datavisualization.Diagram.TextAlign.Left:
                            point.x = offset.x - bounds.width;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Center:
                            point.x = offset.x - bounds.width / 2;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Right:
                            point.x = offset.x;
                            break;
                    }
                    break;
            }
            if (node.segments || node.type == "group") {
                point.x = point.x + nodeBounds.x;
                point.y = point.y + nodeBounds.y;
                offset.x += nodeBounds.x;
                offset.y += nodeBounds.y;
            }
            if (ej.browserInfo().name === "mozilla")
                point.y = point.y - label.fontSize / 2;
            text.setAttribute("transform", "translate(" + point.x + "," + point.y + "), rotate(" + label.rotateAngle + "," + (offset.x - point.x) + "," + (offset.y - point.y) + ")");
            //Updates the label background
            var background = svg.getElementById(node.name + "_" + label.name + "_lblbg");
            if (background) {
                var x = point.x + bounds.x;
                y = point.y;
                if (ej.browserInfo().name === "mozilla")
                    y = point.y + label.fontSize / 2;
                var attr = {
                    "width": bounds.width, "height": bounds.height, "transform": "translate(" + x + "," + y + "), rotate(" + label.rotateAngle + "," + (offset.x - x) + "," + (offset.y - y) + ")", "fill": label.fillColor,
                    "stroke": label.borderColor, "stroke-width": label.borderWidth
                };
                ej.datavisualization.Diagram.Util.attr(background, attr);
            }
        },

        _wrapText: function (node, textBBox, text, label, svg) {
            var str = label.text; var attr = null;
            while (text.hasChildNodes()) {
                text.removeChild(text.lastChild);
            }
            var bbWidth, bbHeight;
            if (node.segments) {
                bbWidth = textBBox.width;
                bbHeight = textBBox.height;
            }
            else {

                bbWidth = textBBox.width - label.margin.left - label.margin.right;
                bbHeight = textBBox.height - label.margin.top - label.margin.bottom;
            }
            bbWidth = bbWidth < label.width ? label.width : bbWidth;
            var eachLine = str.split('\n');
            var x, y, tspan, j, string = "", posX, posY, childNodes, bounds, i;
            if (svg.getElementById(text.id))
                childNodes = svg.getElementById(text.id).childNodes;
            if (childNodes) {
                for (j = 0; j < eachLine.length; j++) {
                    tspan = svg.tspan();
                    tspan.style.fontSize = label.fontSize;
                    text.appendChild(tspan);
                    if (label.wrapText) {
                        for (i = 0; i < eachLine[j].length; i++) {
                            if (label.wrapText) {
                                bounds = childNodes[childNodes.length - 1].getComputedTextLength();
                                if (bounds >= (bbWidth - label.fontSize)) {
                                    tspan.textContent += eachLine[j][i];
                                    posX = -bounds;
                                    if (!(i == eachLine[j].length - 1)) {
                                        tspan = svg.tspan();
                                        text.appendChild(tspan);
                                    }
                                }
                                else {
                                    tspan.textContent += eachLine[j][i];
                                }
                            }
                            else {
                                tspan.textContent += eachLine[j][i];
                            }
                        }
                    }
                    else tspan.textContent += eachLine[0];
                }
                this._wrapTextAlign(text, childNodes, label.fontSize, label.textAlign);
            }
        },

        _wrapTextAlign: function (text, childNodes, height, textAlign) {
            for (var i = 0; i < childNodes.length; i++) {
                var x = childNodes[i].getComputedTextLength();
                switch (textAlign) {
                    case "left":
                        x = 0;
                        break;
                    case "center":
                        x = -x / 2;
                        break;
                    case "right":
                        x = -x;
                        break;
                }
                var attr = { "x": Number(x), "dy": height };
                var tspan = childNodes[i];
                ej.datavisualization.Diagram.Util.attr(tspan, attr);
            }
        },
        //#endregion

        //#region Render Port
        _renderPorts: function (node, svg, g) {
            var ports = node.ports;
            var port;
            for (var i = 0, len = ports.length; i < len; ++i) {
                port = ports[i];
                var shape = this._renderPort(node, port, svg);
                g.appendChild(shape);
                if (port.visibility & ej.datavisualization.Diagram.PortVisibility.Hidden || port.visibility & ej.datavisualization.Diagram.PortVisibility.Hover || port.visibility & ej.datavisualization.Diagram.PortVisibility.Connect) {
                    shape.setAttribute("visibility", "hidden");
                }
            }
        },

        _renderPort: function (node, port, svg) {
            var shape;
            var attr;
            var size = ej.datavisualization.Diagram.Size(port.size, port.size);
            var point;
            if (node.type == "group")
                point = ej.datavisualization.Diagram.Util._getPortPosition(port, ej.datavisualization.Diagram.Util.bounds(node, true), false);
            else
                point = ej.datavisualization.Diagram.Util._getPortPosition(port, ej.datavisualization.Diagram.Util.bounds(node, true), true);
            switch (port.shape) {
                case "x":
                    var d = this._constructX(point, port.size);
                    attr = {
                        "id": node.name + "_" + port.name, "class": "ej-d-port", "fill": port.fillColor,
                        "stroke": port.borderColor, "stroke-width": port.borderWidth, "d": d
                    };
                    shape = svg.path(attr);
                    break;
                case "circle":
                    var rx = size.width / 2;
                    var ry = size.height / 2;
                    attr = {
                        "id": node.name + "_" + port.name, "class": "ej-d-port", "rx": rx, "ry": ry,
                        "cx": point.x, "cy": point.y, "fill": port.fillColor, "stroke": port.borderColor,
                        "stroke-width": port.borderWidth
                    };
                    shape = svg.ellipse(attr);
                    break;
                case "square":
                    attr = {
                        "id": node.name + "_" + port.name, "class": "ej-d-port", "x": point.x - port.size / 2,
                        "y": point.y - port.size / 2, "width": size.width, "height": size.height,
                        "fill": port.fillColor, "stroke": port.borderColor, "stroke-width": port.borderWidth
                    };
                    shape = svg.rect(attr);
                    break;
            }
            return shape;
        },
        _insertPort: function (node, port, svg) {
            var g;
            g = document.getElementById(node.name);
            var portshape = ej.datavisualization.Diagram.SvgContext._renderPort(node, port, svg);
            g.appendChild(portshape);
            if (port.visibility & ej.datavisualization.Diagram.PortVisibility.Hidden || port.visibility & ej.datavisualization.Diagram.PortVisibility.Hover || port.visibility & ej.datavisualization.Diagram.PortVisibility.Connect) {
                portshape.setAttribute("visibility", "hidden");
            }

        },
        _updatePort: function (node, port, svg) {
            var size = ej.datavisualization.Diagram.Size(port.size, port.size);
            var point = null;
            if (node.type == "group")
                point = ej.datavisualization.Diagram.Util._getPortPosition(port, ej.datavisualization.Diagram.Util.bounds(node, true), false);
            else
                point = ej.datavisualization.Diagram.Util._getPortPosition(port, ej.datavisualization.Diagram.Util.bounds(node, true), true);
            var id = node.name + "_" + port.name;
            switch (port.shape) {
                case "x":
                    var d = this._constructX(point, port.size);
                    svg.path({ "id": id, "d": d });
                    break;
                case "circle":
                    var rx = size.width / 2;
                    var ry = size.height / 2;
                    svg.ellipse({ "id": id, "rx": rx, "ry": ry, "cx": point.x, "cy": point.y });
                    break;
                case "square":
                    svg.rect({ "id": id, "x": point.x - port.size / 2, "y": point.y - port.size / 2 });
                    break;
            }
        },

        _updatePorts: function (node, svg) {
            var ports = node.ports;
            for (var i = 0, len = ports.length; i < len; ++i) {
                var port = ports[i];
                this._updatePort(node, port, svg);
            }
        },

        _constructX: function (point, size) {
            var path = new ej.datavisualization.Diagram.Path();
            path.moveTo((point.x - size / 2), (point.y - size / 2));
            path.lineTo((point.x + size / 2), (point.y + size / 2));
            path.moveTo((point.x + size / 2), (point.y - size / 2));
            path.lineTo((point.x - size / 2), (point.y + size / 2));
            return path.toString();
        },
        _enableSelectedNode: function (node, svg, diagram) {
            if (node) {
                if (node.type == "pseudoGroup") {
                    var children = diagram._getChildren(node.children);
                    for (var i = 0, len = children.length; i < len; i++) {
                        var child = diagram.nameTable[children[i]];
                        if (child)
                            this._enableSelectedNode(child, svg, diagram);
                    }
                } else {
                    var attr = {
                        "id": node.name,
                        "pointer-events": "auto",
                        "style": "pointer-events:block",
                    }
                    svg.g(attr);
                }
            }
            $(".decorator").attr('pointer-events', "block");
            $(".handle").attr('pointer-events', "block");
            $(".hitTest").attr('pointer-events', "block");
        },
        _disableSelectedNode: function (node, svg, diagram) {
            if (node.type == "pseudoGroup") {
                var children = diagram._getChildren(node.children);
                for (var i = 0, len = children.length; i < len; i++) {
                    var child = diagram.nameTable[children[i]];
                    if (child)
                        this._disableSelectedNode(child, svg, diagram);
                }
            } else {
                var attr = {
                    "id": node.name,
                    "style": "pointer-events:none",
                    "pointer-events": "none",
                }
                $(".decorator").attr('pointer-events', "none");
                $(".handle").attr('pointer-events', "none");
                $(".hitTest").attr('pointer-events', "none");
                svg.g(attr);
            }
        },
        _drawNodeHighlighter: function (node, svg, parent, scale) {
            var shape;
            var x = node.offsetX - node.width * node.pivot.x;
            var y = node.offsetY - node.height * node.pivot.y;
            var center = ej.datavisualization.Diagram.Point(node.offsetX - node.width * node.pivot.x + node.width / 2, node.offsetY - node.height * node.pivot.y + node.height / 2);
            var transform = "rotate(" + node.rotateAngle + "," + center.x * scale + "," + center.y * scale + ")";
            var attr = {
                "id": "nodeHighlighter",
                "class": "ej-d-node",
                "x": x * scale,
                "y": y * scale,
                "width": node.width * scale,
                "height": node.height * scale,
                "fill": "transparent",
                "stroke": "red",
                "stroke-width": 3,
                "pointer-events": "none",
                "transform": transform,
                "style": "pointer-events: none",
            };
            shape = svg.rect(attr);
            parent.appendChild(shape);
            return shape;
        },

        _removeNodeHighlighter: function (svg, parent) {
            var highlighter = svg.getElementById("nodeHighlighter");
            if (highlighter) {
                svg.removeChild(highlighter, parent);
            }
        },
        _drawPortHighlighter: function (port, node, svg, parent, scale) {
            var shape, size, point, x, y, transform;
            var bounds;
            var fill = "#8CC63F";
            var border = "#1A1A1A";
            var borderWidth = 0.5;
            if (!port) {
                bounds = ej.datavisualization.Diagram.Util.bounds(node, true);
                size = ej.datavisualization.Diagram.Size(bounds.width, bounds.height);
                point = ej.datavisualization.Diagram.Point(bounds.x, bounds.y);
                x = point.x * scale;
                y = point.y * scale;
                border = fill;
                fill = "transparent";
                borderWidth = 2;
                var center = ej.datavisualization.Diagram.Point(node.offsetX - node.width * node.pivot.x + node.width / 2, node.offsetY - node.height * node.pivot.y + node.height / 2);
                transform = "rotate(" + node.rotateAngle + "," + center.x * scale + "," + center.y * scale + ")";
            }
            else {
                size = ej.datavisualization.Diagram.Size(port.size * 2, port.size * 2);
                point = ej.datavisualization.Diagram.Util._getPortPosition(port, ej.datavisualization.Diagram.Util.bounds(node, true));
                var matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, node.rotateAngle, node.offsetX, node.offsetY);
                point = ej.Matrix.transform(matrix, point);
                x = (point.x - port.size) * scale;
                y = (point.y - port.size) * scale;
                transform = "rotate(" + 0 + "," + (x + size.width / 2) + "," + (y + size.height / 2) + ")";
            }
            var attr = {
                "id": "portHighlighter", "class": "ej-d-port", "x": x,
                "y": y, "width": size.width * scale, "height": size.height * scale,
                "fill": fill, "stroke": border, "stroke-width": borderWidth, "pointer-events": "none", "transform": transform
            };
            shape = svg.rect(attr);
            parent.appendChild(shape);
            return shape;
        },

        _removePortHighlighter: function (svg, parent) {
            var highlighter = svg.getElementById("portHighlighter");
            if (highlighter) {
                svg.removeChild(highlighter, parent);
            }
        },
        //#endregion

        //#region Render Selector

        renderSelector: function (shape, svg, parent, scale, constraints) {
            if (shape.segments) {
                var g = svg.g({
                    "id": svg.document.id + "handle_g", "class": "handle"
                });
                parent.appendChild(g);
                this._renderEndPointHandle(shape, svg, scale);
            }
            else {
                var g = svg.g({
                    "id": svg.document.id + "handle_g", "class": "handle",
                    "transform": "translate(" + (shape.offsetX - shape.width / 2) * scale + "," + (shape.offsetY - shape.height / 2) * scale + "),rotate(" + shape.rotateAngle + "," + (shape.width / 2) * scale + "," + (shape.height / 2) * scale + ")"
                });
                parent.appendChild(g);
                this._renderResizeHandle(shape, svg, scale, constraints);
            }
        },

        _renderResizeHandle: function (node, svg, scale, constraints) {

            var rotate = ej.datavisualization.Diagram.Point(node.width / 2, -20 / scale);
            if (constraints & ej.datavisualization.Diagram.SelectorConstraints.Rotator) {
                this._renderPivotLine(node, svg, scale);
                this._renderRotateThumb("rotate", node, rotate.x, rotate.y, scale, svg);
            }
            if (constraints & ej.datavisualization.Diagram.SelectorConstraints.Resizer) {
                this._renderResizeBorder("resizeBorder", node, svg, scale);

                this._renderResizeCorner("nw-resize", node, 0, 0, svg, !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeNorthWest));
                this._renderResizeCorner("n-resize", node, (node.width / 2) * scale, 0, svg, !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeNorth));
                this._renderResizeCorner("ne-resize", node, node.width * scale, 0, svg, !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeNorthEast));
                this._renderResizeCorner("w-resize", node, 0, (node.height / 2) * scale, svg, !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeWest));
                this._renderResizeCorner("e-resize", node, node.width * scale, (node.height / 2) * scale, svg, !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeEast));
                this._renderResizeCorner("sw-resize", node, 0, node.height * scale, svg, !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeSouthWest));
                this._renderResizeCorner("s-resize", node, (node.width / 2) * scale, node.height * scale, svg, !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeSouth));
                this._renderResizeCorner("se-resize", node, node.width * scale, node.height * scale, svg, !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeSouthEast));
            }
        },

        renderUserHandles: function (handles, shape, svg, isMultipleSelection, scale, parent) {
            for (var handleIndex = 0; handleIndex < handles.length; handleIndex++) {
                if ((isMultipleSelection && handles[handleIndex].enableMultiSelection) || !isMultipleSelection) {
                    if (handles[handleIndex].visible)
                        this._renderUserHandle(handles[handleIndex], shape, svg, scale, parent);
                }
            }
        },

        _renderUserHandle: function (handle, node, svg, scale, parent) {
            var g = svg.g({ "id": svg.document.id + "userHandle_g", "class": "userHandle" });
            parent.appendChild(g);
            var position = this._getHandlePosition(handle, node, scale);
            var d = ej.datavisualization.Diagram.Geometry.updatePath(position.x * scale - handle.size / 4, position.y * scale - handle.size / 4, (handle.size / 2), (handle.size / 2), handle.pathData, svg);
            var shape = this._getHandleShape(handle, position.x * scale, position.y * scale);
            var icon = this._getHandleIcon(handle, d, position.x, position.y);
            g.appendChild(svg.circle(shape));
            g.appendChild(svg.path(icon));
        },

        _getHandleIcon: function (handle, d) {
            var icon = {
                "id": handle.name + "_icon", "class": "userHandle-icon", "d": d, "fill": handle.pathColor
            };
            return icon;
        },

        _getHandlePosition: function (handle, node, scale) {
            var positionPoints = ej.datavisualization.Diagram.Point();
            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
            var position = handle.position;
            var distance = 10;
            var matrix = ej.Matrix.identity();
            if (node.rotateAngle)
                ej.Matrix.rotate(matrix, node.rotateAngle);
            var point = new ej.datavisualization.Diagram.Point();
            switch (position) {
                case "topleft":
                    point = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(distance + (handle.size / 2), distance + (handle.size / 2)));
                    positionPoints.x = bounds.topLeft.x - (point.x / scale);
                    positionPoints.y = bounds.topLeft.y - (point.y / scale);
                    break;
                case "topcenter":
                    point = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(0, distance + (handle.size / 2)));
                    positionPoints.x = bounds.topCenter.x - (point.x / scale);
                    positionPoints.y = bounds.topCenter.y - point.y / scale;
                    break;
                case "topright":
                    point = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(distance + (handle.size / 2), (distance / 2) - (handle.size)));
                    positionPoints.x = bounds.topRight.x + (point.x / scale);
                    positionPoints.y = bounds.topRight.y + (point.y / scale);
                    break;
                case "middleleft":
                    point = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(-(distance + (handle.size / 2)), 0));
                    positionPoints.x = bounds.middleLeft.x + (point.x / scale);
                    positionPoints.y = bounds.middleLeft.y + (point.y / scale);
                    break;
                case "middleright":
                    point = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(distance + (handle.size / 2), 0));
                    positionPoints.x = bounds.middleRight.x + (point.x / scale);
                    positionPoints.y = bounds.middleRight.y + (point.y / scale);
                    break;
                case "bottomleft":
                    point = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(-(distance + (handle.size / 2)), distance + (handle.size / 2)));
                    positionPoints.x = bounds.bottomLeft.x + (point.x / scale);
                    positionPoints.y = bounds.bottomLeft.y + (point.y / scale);
                    break;
                case "bottomcenter":
                    point = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(0, ((distance / 2) - (handle.size))));
                    positionPoints.x = bounds.bottomCenter.x - (point.x / scale);
                    positionPoints.y = bounds.bottomCenter.y - (point.y / scale);
                    break;
                case "bottomright":
                    point = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(distance + (handle.size / 2), distance + (handle.size / 2)));
                    positionPoints.x = bounds.bottomRight.x + (point.x / scale);
                    positionPoints.y = bounds.bottomRight.y + (point.y / scale);
                    break;
            }
            return positionPoints;
        },

        _getHandleShape: function (handle, cx, cy) {
            var shape = {
                "id": handle.name + "_shape", "class": "userHandle", "cx": cx, "cy": cy, "r": handle.size / 2, "fill": handle.backgroundColor,
                "stroke": handle.borderColor, "stroke-width": handle.borderWidth, "title": handle.name
            };
            return shape;
        },

        _updateHandleShape: function (handle, cx, cy, svg) {
            var attr = { "id": handle.name + "_shape", "cx": cx, "cy": cy };
            svg.circle(attr);
        },

        _updateHanleIcon: function (handle, d, svg) {
            var attr = { "id": handle.name + "_icon", "d": d };
            svg.path(attr);
        },

        _getHanleIcon: function (handle, d, cx, cy) {
            var icon = {
                "id": handle.name, "d": d, "stroke": handle.borderColor,
                "stroke-width": handle.borderWidth, "fill": handle.fillColor
            };
            return icon;
        },

        renderPivotPoint: function (node, scale, svg) {
            if (!svg.getElementById("pivot")) {
                ej.datavisualization.Diagram.SvgContext._renderResizeCorner("pivot", node,
                      node.offsetX * scale, node.offsetY * scale, svg);
                this._updatePivotLine(node, svg, scale);
            }
        },

        _renderPivotLine: function (node, svg, scale) {
            if (!node.container) {
                var rotateThumb = ej.datavisualization.Diagram.Point(node.width / 2, -20 / scale);
                var pivot = ej.datavisualization.Diagram.Point(node.width / 2, 0);
                var handle = svg.getElementById(svg.document.id + "handle_g");
                var line = svg.line({
                    "id": "pivotLine", "x1": rotateThumb.x * scale, "y1": rotateThumb.y * scale, "x2": pivot.x * scale, "y2": pivot.y * scale,
                    "stroke": "black", "stroke-width": 1, "stroke-dasharray": "2,3", "fill": "none"
                });
                handle.appendChild(line);
            }
        },

        _renderResizeBorder: function (id, node, svg, scale) {
            var handle = svg.getElementById(svg.document.id + "handle_g");
            var rect = svg.rect({
                "id": id, "width": node.width * scale, "height": node.height * scale, "stroke": "#097F7F", "stroke-width": 0.6, "stroke-dasharray": "6,3", "fill": "none"
            });
            handle.appendChild(rect);
        },

        _renderResizeCorner: function (corner, node, cx, cy, svg, state) {
            var handle = svg.getElementById(svg.document.id + "handle_g");
            var pEvnts = "default";
            var fill = "white";
            if (!(ej.datavisualization.Diagram.Util.canResize(node))) {
                fill = "darkgray";
            }
            if (state) {
                fill = "darkgray";
                pEvnts = "none";
            }
            var attr = { "id": corner, "fill": fill, "stroke": "black", "stroke-width": 1, "cx": cx, "cy": cy, "r": 7, "pointer-events": pEvnts };
            handle.appendChild(svg.circle(attr));
            attr = { "id": corner + "_transparent", "class": corner, "fill": "transparent", "cx": cx, "cy": cy, "r": 10, "pointer-events": pEvnts };
            handle.appendChild(svg.circle(attr));
        },

        _renderRotateThumb: function (corner, node, cx, cy, scale, svg) {
            if (!node.container) {
                var handle = svg.getElementById(svg.document.id + "handle_g");
                var d = "M 16.856 10.239 L 18 3.438 l -2.189 0.817 c -0.974 -1.694 -2.482 -2.995 -4.326 -3.696 C 9.375 -0.245 7.071" +
                    "-0.18 5.01 0.744 C 2.942 1.668 1.365 3.342 0.558 5.453 c -0.803 2.115 -0.738 4.414 0.185 6.478 c 0.925 2.064 " +
                "2.6 3.645 4.714 4.45 c 0.969 0.371 1.993 0.554 3.013 0.554 c 1.345 0 2.685 -0.317 3.897 -0.948 l -1.016 -1.962 c -1.584 0.822" +
                "-3.445 0.929 -5.114 0.293 c -1.56 -0.596 -2.793 -1.762 -3.479 -3.289 C 2.078 9.502 2.031 7.803 2.622 6.244 C 3.216 4.68 4.387" +
                " 3.443 5.914 2.761 C 7.437 2.079 9.137 2.03 10.7 2.626 c 1.246 0.475 2.271 1.328 2.986 2.424 L 11.54 5.851 L 16.856 10.239 Z";
                var fill = "#231f20";
                if (!(ej.datavisualization.Diagram.Util.canRotate(node)))
                    fill = "darkgray";
                var width = 20;
                var height = 20;
                var dist = 20;
                var attr = {
                    "id": "rotatehandle", "class": corner, "fill": fill, "stroke": "black", "stroke-width": 0.5, "width": width, "height": height, "d": d,
                    "transform": "translate(" + (cx * scale - width / 2) + "," + (cy * scale - height) + ")"
                };
                var path = svg.path(attr);
                var circle = svg.circle({
                    "id": "rotate", "class": corner, "fill": "transparent", "stroke": "none", "cx": width / 2, "cy": height / 2, "r": 13,
                    "transform": "translate(" + (cx * scale - width / 2) + "," + (cy * scale - height) + ")"
                });
                handle.appendChild(path);
                handle.appendChild(circle);
            }
        },

        _refreshEndPointHandles: function (shape, svg, scale) {
            if (shape.segments) {
                var handle = svg.getElementById(svg.document.id + "handle_g");
                $(handle).empty();
                this._renderEndPointHandle(shape, svg, scale);
            }
        },
        _renderEndPointHandle: function (connector, svg, scale) {
            for (var i = 0; i < connector.segments.length; i++) {
                var segment = connector.segments[i];
                if (segment.type == "bezier") {
                    var enabled = ej.datavisualization.Diagram.Util.canDragSegmentThumbs(connector);
                    this._renderBezierLine("bezierline1", segment._startPoint, segment._point1, scale, svg);
                    this._renderBezierLine("bezierline2", segment._endPoint, segment._point2, scale, svg);
                    this._renderEndPointCorner("bezierpoint1_" + i, segment._point1.x * scale, segment._point1.y * scale, false, svg, enabled);
                    this._renderEndPointCorner("bezierpoint2_" + i, segment._point2.x * scale, segment._point2.y * scale, false, svg, enabled);
                }
                var points = segment.points;
                if (i == 0) {
                    this._renderEndPointCorner("sourceEndPoint", segment._startPoint.x * scale, segment._startPoint.y * scale, ej.datavisualization.Diagram.Util.isSourceConnected(connector), svg,
                          ej.datavisualization.Diagram.Util.canDragSourceEnd(connector));
                }
                if (i == connector.segments.length - 1) {
                    this._renderEndPointCorner("targetEndPoint", segment._endPoint.x * scale, segment._endPoint.y * scale, ej.datavisualization.Diagram.Util.isTargetConnected(connector), svg,
                        ej.datavisualization.Diagram.Util.canDragTargetEnd(connector));
                    if (segment.type == "orthogonal") {
                        this._renderTerminalOrthoThumbs(segment, svg, scale, i);
                    }
                }
                else {
                    if (segment.type != 'orthogonal') {
                        this._renderSegmentEndThumb("segmentEnd_" + i, segment._endPoint.x * scale, segment._endPoint.y * scale, ej.datavisualization.Diagram.Util.isSourceConnected(connector), svg,
                               ej.datavisualization.Diagram.Util.canDragSourceEnd(connector));
                    } else {
                        this._renderTerminalOrthoThumbs(segment, svg, scale, i);
                    }

                }
            }
        },

        _renderTerminalOrthoThumbs: function (segment, svg, scale, index, orientation) {
            if (segment.points.length > 2)
                for (var i = 0; i < segment.points.length - 1; i++) {
                    var length = ej.datavisualization.Diagram.Geometry.distance(segment.points[i], segment.points[i + 1]);
                    if (segment.points[i].y == segment.points[i + 1].y) {
                        orientation = "horizontal";
                    }
                    else orientation = "vertical";
                    var visible;
                    if (length >= 50) visible = "visible"; else visible = "hidden";
                    this._renderOrthogonalThumb(("OrthoThumb_" + i) + "_" + index, ((segment.points[i].x + segment.points[i + 1].x) / 2) * scale, ((segment.points[i].y + segment.points[i + 1].y) / 2) * scale, svg, visible, orientation);
                }
            else {
                var length = segment.length || ej.datavisualization.Diagram.Geometry.distance(segment._startPoint, segment._endPoint);
                if (length >= 50) visible = "visible"; else visible = "hidden";
                if (segment._startPoint.y == segment._endPoint.y) {
                    orientation = "horizontal";
                }
                else orientation = "vertical";
                this._renderOrthogonalThumb("OrthoThumb_" + index, ((segment._endPoint.x + segment._startPoint.x) / 2) * scale, ((segment._endPoint.y + segment._startPoint.y) / 2) * scale, svg, visible, orientation);
            }
        },

        _renderEndPointCorner: function (corner, x, y, isConnected, svg, isenabled) {
            var handle = svg.getElementById(svg.document.id + "handle_g");
            var fill = isConnected ? "#8CC63F" : "white";
            if (!isenabled) fill = "darkgray";
            var attr = { "id": corner, "class": corner, opacity: 0.75, "fill": fill, "stroke": "black", "stroke-width": 2, "cx": x, "cy": y, "r": 7 };
            handle.appendChild(svg.circle(attr));
        },

        _renderSegmentEndThumb: function (corner, x, y, isConnected, svg, isenabled) {
            var handle = svg.getElementById(svg.document.id + "handle_g");
            var fill = "#e2e2e2";
            var attr = { "id": corner, "class": "segmentEnd", "fill": fill, "stroke": "black", "stroke-width": 2, "cx": x, "cy": y, "r": 5 };
            handle.appendChild(svg.circle(attr));
        },
        _renderOrthogonalThumb: function (corner, x, y, svg, visibility, orientation) {
            var path, h, v; if (orientation == "horizontal") {
                path = "M0,7 L15,0 L30,7 L15,14 z"; h = -15; v = -7;
            } else { path = "M7,0 L0,15 L7,30 L14,15 z"; h = -7; v = -15; };
            var handle = svg.getElementById(svg.document.id + "handle_g");
            var fill = "#e2e2e2";
            var attr = {
                "id": corner, "class": "segmentEnd", "fill": fill, "stroke": "black", "stroke-width": 1, d: path, transform: "translate(" + (x + h) + "," + (y + v) + ")",
                "visibility": visibility
            };
            handle.appendChild(svg.path(attr));
        },
        _renderBezierLine: function (id, start, end, scale, svg) {
            var line = svg.line({
                "id": id, "x1": start.x * scale, "y1": start.y * scale, "x2": end.x * scale, "y2": end.y * scale,
                "stroke": "black", "stroke-width": 1, "stroke-dasharray": "3,3", "fill": "none"
            });
            var handle = svg.getElementById(svg.document.id + "handle_g");
            handle.appendChild(line);
        },
        _renderControlPointCorner: function (corner, point, index, svg) {
            var g = svg.g({ "class": corner });
            svg.getElementById(svg.document.id + "handle_g").appendChild(g);
            var attr = {
                "id": corner + "_" + index, "fill": "white", "stroke": "black", "stroke-width": 2,
                "cx": point.x, "cy": point.y, "r": 5
            };
            g.appendChild(svg.circle(attr));
        },
        _removePivotPoint: function (node, svg, scale) {
            var parent = svg.getElementById(svg.document.id + "handle_g");
            if (parent != null && svg.getElementById("pivot")) {
                parent.removeChild(svg.getElementById("pivot"));
                this._updatePivotLine(node, svg, scale);
            }
        },
        updateSelector: function (shape, svg, scale, diagram, constraints) {
            if (shape.segments) {
                this._updateEndPointHandle(shape, svg, scale);
                if (constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles)
                    this.updateUserHandles(diagram.model.selectedItems.userHandles, shape, svg, false, false, scale);
            } else {
                var g = svg.g({
                    "id": svg.document.id + "handle_g",
                    "transform": "translate(" + (shape.offsetX - shape.width / 2) * scale + "," + (shape.offsetY - shape.height / 2) * scale + "),rotate(" + shape.rotateAngle + "," + (shape.width / 2) * scale + "," + (shape.height / 2) * scale + ")"
                });
                //if ((diagram.activeTool.name != "move" && diagram.activeTool.name != "rotate") || shape.line || shape.type == "group" || shape.type == "pseudoGroup")
                this._updateResizeHandle(shape, svg, scale, constraints);
                if (diagram.model.selectedItems.userHandles && diagram.model.selectedItems.userHandles.length > 0) {
                    var isMultipleSelection = false;
                    if (diagram.selectionList[0] && diagram.selectionList[0].name == "multipleSelection")
                        isMultipleSelection = true;
                    if (constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles)
                        this.updateUserHandles(diagram.model.selectedItems.userHandles, shape, svg, isMultipleSelection, false, scale);
                }
            }
        },
        _updateResizeHandle: function (node, svg, scale, constraints) {
            var corner = node._corners;
            var rotate = ej.datavisualization.Diagram.Point(node.width / 2, -20 / scale);
            if (constraints & ej.datavisualization.Diagram.SelectorConstraints.Rotator) {
                this._updateRotateHandle("rotate", rotate.x, rotate.y, scale, svg, node);
                this._updatePivotLine(node, svg, scale);
            }
            //this._updateResizeCorner("pivot", node.offsetX * scale, node.offsetY * scale, svg);
            if (constraints & ej.datavisualization.Diagram.SelectorConstraints.Resizer) {
                this._updateResizeCorner("nw-resize", 0, 0, svg);
                this._updateResizeCorner("n-resize", (node.width / 2) * scale, 0, svg);
                this._updateResizeCorner("ne-resize", node.width * scale, 0, svg);
                this._updateResizeCorner("w-resize", 0, (node.height / 2) * scale, svg);
                this._updateResizeCorner("e-resize", node.width * scale, (node.height / 2) * scale, svg);
                this._updateResizeCorner("sw-resize", 0, node.height * scale, svg);
                this._updateResizeCorner("s-resize", (node.width / 2) * scale, node.height * scale, svg);
                this._updateResizeCorner("se-resize", node.width * scale, node.height * scale, svg);
                this._updateResizeBorder("resizeBorder", node, svg, scale);
            }
        },
        _updateRotateHandle: function (thumb, cx, cy, scale, svg, node) {
            var width = 20;
            var height = 20;
            var dist = 20;
            var attr = {
                "id": "rotatehandle",
                "transform": "translate(" + (cx * scale - width / 2) + "," + (cy * scale - height) + ")"
            };
            svg.path(attr);
            svg.circle({
                "id": "rotate",
                "transform": "translate(" + (cx * scale - width / 2) + "," + (cy * scale - height) + ")"
            });
        },
        _updatePivotLine: function (node, svg, scale) {
            var rotateThumb = ej.datavisualization.Diagram.Point(node.width / 2, -20 / scale);
            var pivot = ej.datavisualization.Diagram.Point(node.width / 2, 0);
            var line = svg.line({
                "id": "pivotLine", "x1": rotateThumb.x * scale, "y1": rotateThumb.y * scale, "x2": pivot.x * scale, "y2": pivot.y * scale
            });
        },
        _updateResizeBorder: function (id, node, svg, scale) {
            svg.rect({
                "id": id, "width": node.width * scale, "height": node.height * scale,
            });
        },

        _updateResizeCorner: function (corner, cx, cy, svg) {
            var attr = { "id": corner, "cx": cx, "cy": cy };
            svg.circle(attr);
            var attr = { "id": corner + "_transparent", "cx": cx, "cy": cy };
            svg.circle(attr);
        },

        _updateEndPointHandle: function (connector, svg, scale) {
            for (var i = 0; i < connector.segments.length; i++) {
                var segment = connector.segments[i];
                var points = segment.points;
                if (i == connector.segments.length - 1) {
                    this._updateEndPointCorner("targetEndPoint", points[points.length - 1].x * scale, points[points.length - 1].y * scale, ej.datavisualization.Diagram.Util.isTargetConnected(connector), svg,
                ej.datavisualization.Diagram.Util.canDragTargetEnd(connector));
                    if (segment.type == "orthogonal") {
                        this._updateTerminalOrthoThumbs(segment, svg, scale, i);
                    }
                }
                else {
                    if (segment.type != "orthogonal") {
                        this._updateSegmentEndThumb("segmentEnd_" + i, segment._endPoint.x * scale, segment._endPoint.y * scale, ej.datavisualization.Diagram.Util.isSourceConnected(connector), svg,
                            ej.datavisualization.Diagram.Util.canDragSourceEnd(connector));
                    }
                    else {
                        this._updateTerminalOrthoThumbs(segment, svg, scale, i);
                    }
                }
                if (i == 0)
                    this._updateEndPointCorner("sourceEndPoint", points[0].x * scale, points[0].y * scale, ej.datavisualization.Diagram.Util.isSourceConnected(connector), svg,
                        ej.datavisualization.Diagram.Util.canDragSourceEnd(connector));
                if (segment.type == "bezier") {
                    var enabled = ej.datavisualization.Diagram.Util.canDragSegmentThumbs(connector);
                    this._updateEndPointCorner("bezierpoint1_" + i, segment._point1.x * scale, segment._point1.y * scale, false, svg, enabled);
                    this._updateEndPointCorner("bezierpoint2_" + i, segment._point2.x * scale, segment._point2.y * scale, false, svg, enabled);
                    this._updateBezierLine("bezierline1", segment._startPoint, segment._point1, scale, svg);
                    this._updateBezierLine("bezierline2", segment._endPoint, segment._point2, scale, svg);
                }

            }
            //if (points.length > 2) {
            //    for (var i = 1, len = points.length; i < len - 1; ++i) {
            //        this._updateControlPointCorner("controlPoint", points[i], i, svg);
            //    }
            //}
        },

        _updateEndPointCorner: function (corner, x, y, isConnected, svg, isenabled) {
            var fill = isConnected ? "#8CC63F" : "white";
            if (!isenabled) fill = "darkgray";
            var attr = { "id": corner, "fill": fill, "cx": x, "cy": y };
            svg.circle(attr);
        },
        _updateSegmentEndThumb: function (corner, x, y, isConnected, svg, isenabled) {
            var attr = { "id": corner, "cx": x, "cy": y };
            svg.circle(attr);
        },
        _updateOrthoThumb: function (corner, x, y, svg, visibility, orientation) {
            var path, h, v; if (orientation == "horizontal") {
                path = "M0,7 L15,0 L30,7 L15,14 z"; h = -15; v = -7;
            } else { path = "M7,0 L0,15 L7,30 L14,15 z"; h = -7; v = -15; };
            var attr = { "id": corner, visibility: visibility, transform: "translate(" + (x + h) + "," + (y + v) + ")", d: path };
            svg.path(attr);
        },
        _updateTerminalOrthoThumbs: function (segment, svg, scale, index) {
            var orientation;
            if (segment.points.length > 2)
                for (var i = 0; i < segment.points.length - 1; i++) {
                    var length = ej.datavisualization.Diagram.Geometry.distance(segment.points[i], segment.points[i + 1]);
                    if (segment.points[i].y == segment.points[i + 1].y) {
                        orientation = "horizontal";
                    }
                    else orientation = "vertical";
                    var visible;
                    if (length >= 50) visible = "visible"; else visible = "hidden";
                    this._updateOrthoThumb(("OrthoThumb_" + i) + "_" + index, ((segment.points[i].x + segment.points[i + 1].x) / 2) * scale, ((segment.points[i].y + segment.points[i + 1].y) / 2) * scale, svg, visible, orientation);

                }
            else {
                var length = segment.length || ej.datavisualization.Diagram.Geometry.distance(segment._startPoint, segment._endPoint);
                if (segment._startPoint.y == segment._endPoint.y) {
                    orientation = "horizontal";
                }
                else orientation = "vertical";
                if (length >= 50) visible = "visible"; else visible = "hidden";
                this._updateOrthoThumb("OrthoThumb_" + index, ((segment._endPoint.x + segment._startPoint.x) / 2) * scale, ((segment._endPoint.y + segment._startPoint.y) / 2) * scale, svg, visible, orientation);
            }
        },
        _updateBezierLine: function (id, start, end, scale, svg) {
            var line = svg.line({
                "id": id, "x1": start.x * scale, "y1": start.y * scale, "x2": end.x * scale, "y2": end.y * scale
            });
        },
        _updateControlPointCorner: function (corner, point, index, svg) {
            svg.circle({ "id": corner + "_" + index, "cx": point.x, "cy": point.y });
        },

        updateUserHandles: function (handles, node, svg, isMultipleSelection, isDragging, scale) {
            if (handles && handles.length > 0) {
                for (var handleIndex = 0; handleIndex < handles.length; handleIndex++) {
                    if ((isMultipleSelection && handles[handleIndex].enableMultiSelection) || !isMultipleSelection)
                        this._updateHandle(handles[handleIndex], node, svg, isDragging, scale);
                }
            }
        },

        _updateHandle: function (handle, node, svg, isDragging, scale) {
            if (!isDragging && handle.visible) {
                var position = this._getHandlePosition(handle, node, scale);
                var d = ej.datavisualization.Diagram.Geometry.updatePath((position.x * scale) - (handle.size) / 4, (position.y * scale) - (handle.size) / 4, (handle.size / 2), (handle.size / 2), handle.pathData, svg);
                this._updateHandleShape(handle, position.x * scale, position.y * scale, svg);
                this._updateHanleIcon(handle, d, svg);
                if (svg.getElementById(handle.name + "_shape") && handle.visible) {
                    svg.getElementById(handle.name + "_shape").style.display = "block";
                    svg.getElementById(handle.name + "_icon").style.display = "block";
                }
            }
            else {
                if (svg.getElementById(handle.name + "_shape")) {
                    svg.getElementById(handle.name + "_shape").style.display = "none";
                    svg.getElementById(handle.name + "_icon").style.display = "none";
                }
            }
        },

        clearSelector: function (svg, parent) {
            var handle = svg.getElementById(svg.document.id + "handle_g");
            if (handle)
                parent.removeChild(handle);
            handle = svg.getElementById(svg.document.id + "userHandle_g");
            if (handle)
                parent.removeChild(handle);
        },

        _initializePageBreaks: function (svg, attr, g) {
            var g1 = svg.g(attr);
            g.appendChild(g1);
            return g1;
        },

        _renderVPageBreakLine: function (start, end, svg, g) {
            var line = svg.line({
                "x1": start.x, "y1": start.y,
                "x2": end.x, "y2": end.y,
                "style": "stroke:#aaaaaa;stroke-width:1;stroke-dasharray:10,10 "
            });
            g.appendChild(line);
        },

        _renderPageSettingsRect: function (start, end, svg, g, _stroke, _fill, _strokewidth) {
            var rect = svg.rect({
                "id": "pageback",
                "x": start.x, "y": start.y, "width": end.x, "height": end.y,
                "style": "fill:" + _fill + ";stroke:" + _stroke + ";stroke-width:" + _strokewidth + ""
            });
            g.appendChild(rect);
        },

        _updatePageBakground: function (start, end, svg, g, _stroke, _fill, _strokewidth) {
            var rect = document.getElementById("pageback");
            var attr = {
                "x": start.x, "y": start.y, "width": end.x, "height": end.y,
                "style": "fill:" + _fill + ";stroke:" + _stroke + ";stroke-width:" + _strokewidth + ""
            };
            if (rect)
                ej.datavisualization.Diagram.Util.attr(rect, attr);
        },

        _renderHPageBreakLine: function (start, end, svg, g) {
            var line = svg.line({
                "x1": start.x, "y1": start.y,
                "x2": end.x, "y2": end.y,
                "style": "stroke:#aaaaaa;stroke-width:1;stroke-dasharray:10,10 "
            });
            g.appendChild(line);
        },

        _removePageBreaks: function (svg, g, layer) {
            if (g != null) {
                if (layer != null) {
                    layer.removeChild(g);
                }
            }
        },
        removeChild: function (element, view) {
            var elementTar = view.svg.document.getElementById(element.name);
            if (elementTar)
                elementTar.parentNode.removeChild(elementTar)
        }
        //#endregion
    };
    //#endregion

    //#region Common Renderer
    ej.datavisualization.Diagram.DiagramContext = {
        updateViewPort: function (diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                if (view.context == ej.datavisualization.Diagram.SvgContext && view.type == "mainview") {
                    ej.datavisualization.Diagram.PageUtil._updatePageSize(diagram);
                }
            });
        },
        renderNode: function (node, diagram, parent) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view._canvas;
                view.context.renderNode(node, panel, parent || view.diagramLayer);
            });
        },

        renderPort: function (node, port, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view._canvas;
                view.context._insertPort(node, port, panel);
            });
        },
        renderConnector: function (connector, diagram, parent) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view._canvas;
                view.context.renderConnector(connector, panel, parent || view.diagramLayer, diagram);
            });
        },

        renderGroup: function (group, diagram, parent) {
            var view, panel;

            diagram._views.forEach(function (viewid) {
                var isOverView
                view = diagram._views[viewid];
                panel = view.svg || view._canvas;
                parent = view.svg.getElementById(group.parent);
                if (view.type == "overview") {
                    isOverView = true;
                }
                view.context.renderGroup(group, panel, parent || view.diagramLayer, diagram.nameTable, diagram, null, isOverView);
            });
        },
        update: function (data, diagram, layout) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view._canvas;
                if (data.type == "group" || data.type == "pseudoGroup")
                    view.context.updateGroup(data, panel, diagram, layout);
                else if (data.segments)
                    view.context.updateConnector(data, panel, diagram);
                else
                    view.context.updateNode(data, panel, diagram, layout);
            });
        },
        _refreshSegments: function (connector, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                if (connector.segments)
                    view.context._refreshSegments(connector, panel, diagram);
            });
        },
        renderShadow: function (node, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view._canvas;
                view.context._renderShadow(node, panel);
            });
        },
        removeShadow: function (node, diagram) {
            var view, panel;

            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view._canvas;
                view.context._removeShadow(node, panel);
            });
        },
        addNodeLabel: function (shape, label, parent, diagram) {
            var view, panel;
            if (diagram._views) {
                diagram._views.forEach(function (viewid) {
                    view = diagram._views[viewid];
                    panel = view.svg || view.canvas;
                    view.context.addNodeLabel(shape, label, panel, parent);
                });
            }
        },

        updateLabel: function (node, label, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context.updateLabel(node, label, panel);
            });
        },

        setNodeShape: function (node, diagram, parent) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context.setNodeShape(node, panel, parent);
            });
        },

        setLine: function (connector, diagram, parent) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context.setLine(connector, panel, parent, diagram);
            });
        },

        renderDecorators: function (connector, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context.renderDecorators(connector, panel, diagram);
            });
        },

        clearDecorators: function (connector, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context.clearDecorators(connector, panel, diagram);
            });
        },

        updateTargetDecoratorStyle: function (node, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context.updateTargetDecoratorStyle(node, panel);
            });
        },

        updateSourceDecoratorStyle: function (node, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context.updateSourceDecoratorStyle(node, panel);
            });
        },

        updateNodeStyle: function (node, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context._updateNodeStyle(node, panel);
            });
        },

        updateLabelStyle: function (node, label, diagram) {
            diagram._views.forEach(function (viewid) {
                var view = diagram._views[viewid];
                var panel = view.svg || view.canvas;
                view.context.updateLabelStyle(node, label, panel);
            });
        },

        updateConnectorStyle: function (connector, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context._updateConnectorStyle(connector, panel);
            });
        },

        updateTextBlock: function (node, label, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context.updateTextBlock(node, label, panel);
            });

        }
    };
    //#endregion
})(jQuery, Syncfusion);;
/// <reference path="ej.diagramcommon.js" />
/// <reference path="ej.diagramsvg.js" />
/**
* @fileOverview Plugin to style the Html Button elements
* @copyright Copyright Syncfusion Inc. 2001 - 2013. All rights reserved.
*  Use of this code is subject to the terms of our license.
*  A copy of the current license can be obtained at any time by e-mailing
*  licensing@syncfusion.com. Any infringement will be prosecuted under
*  applicable laws. 
* @version 12.1 
* @author <a href="mailto:licensing@syncfusion.com">Syncfusion Inc</a>
*/
(function ($, ej, undefined) {
    /**
* @namespace ej
* @class ejSymbolPalette
* @requires jQuery.js
* @requires ej.common.all
* @requires ej.widgets.all
* @requires jquery.easing.js
* @requires jquery.globalize.js
* @requires jsrender.js
* @requires jquery.validate.js
* @requires jquery.validate.unobtrusive.js
* @classdesc defined values to render symbolpalette
* @example 
* &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
* &lt;script&gt;
* //Create symbolpalette
$("#symbolpalette").ejSymbolPalette();
* &lt;/script&gt
*/
    "use strict";
    //#region SymbolPalette widget
    ej.widget("ejSymbolPalette", "ej.datavisualization.SymbolPalette", {
        // widget element will be automatically set in this
        element: null,

        // user defined model will be automatically set in this
        model: null,
        nameTable: {},

        //#region Initialization
        defaults: {
            /**The width of the palette 
          * @default 250
          * @type {Number}
          * @example
          * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
          * &lt;script&gt;
          * $("#symbolpalette").ejSymbolPalette({width:300});
          * &lt;/script&gt
          * @memberof ejSymbolPalette
          * @instance
          */
            width: 250,
            /**The height of the palette 
        * @default 400
        * @type {Number}
        * @example
        * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * $("#symbolpalette").ejSymbolPalette({height:500});
        * &lt;/script&gt
        * @memberof ejSymbolPalette
        * @instance
        */
            height: 400,
            /**Width of the palette item
        * @default 50
        * @type {Number}
        * @example
        * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * $("#symbolpalette").ejSymbolPalette({paletteItemWidth: 50});
        * &lt;/script&gt
        * @memberof ejSymbolPalette
        * @instance
        */
            paletteItemWidth: 50,
            /**Height of the items in palette
        * @default 50
        * @type {Number}
        * @example
        * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * $("#symbolpalette").ejSymbolPalette({paletteItemHeight: 50});
        * &lt;/script&gt
        * @memberof ejSymbolPalette
        * @instance
        */
            paletteItemHeight: 50,
            /**Preview width of the palette items
        * @default 100
        * @type {Number}
        * @example
        * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * $("#symbolpalette").ejSymbolPalette({previewWidth: 100});
        * &lt;/script&gt
        * @memberof ejSymbolPalette
        * @instance
        */
            previewWidth: 110,
            /**Preview height of the palette items
       * @default 100
       * @type {Number}
       * @example
       * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
       * &lt;script&gt;
       * $("#symbolpalette").ejSymbolPalette({previewHeight: 100});
       * &lt;/script&gt
       * @memberof ejSymbolPalette
       * @instance
       */
            previewHeight: 110,
            /**The preview offset for the palette items
     * @default (102, 102)
     * @type {Object}
     * @example
     * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
     * &lt;script&gt;
     * $("#symbolpalette").ejSymbolPalette({previewOffset: {x: 102, y: 102 }});
     * &lt;/script&gt
     * @memberof ejSymbolPalette
     * @instance
     */
            previewOffset: { x: 112, y: 112 },
            /**The diagramId of the palette 
      * @default null
      * @type {}
      * @example
      * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * $("#symbolpalette").ejSymbolPalette({diagramId: "diagram"});
      * &lt;/script&gt
      * @memberof ejSymbolPalette
      * @instance
      */
            diagramId: null,
            /**Height of the palette header
      * @default 30
      * @type {Number}
      * @example
      * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * $("#symbolpalette").ejSymbolPalette({headerHeight: 30});
      * &lt;/script&gt
      * @memberof ejSymbolPalette
      * @instance
      */
            headerHeight: 30,
            /** The selectedPaletteName of the symbol palette
      * @default 0
      * @type {Number}
      * @example
      * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
      * &lt;script&gt;
      * $("#symbolpalette").ejSymbolPalette({selectedPaletteName: "paletteName"});
      * &lt;/script&gt
      * @memberof ejSymbolPalette
      * @instance
      */
            selectedPaletteName: 0,
            /** Used to change the style of the node 
         * @default "e-symbolpalette"
         * @type {String}
         * @example
         * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
         * &lt;script&gt;
         * $("#symbolpalette").ejSymbolPalette({cssClass: "e-symbolpalette"});
         * &lt;/script&gt
         * @memberof ejSymbolPalette
         * @instance
         */
            cssClass: "e-datavisualization-symbolpalette",
            /** Enable or disable the palette item text 
       * @default true
       * @type {Boolean}
       * @example
       * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
       * &lt;script&gt;
       * $("#symbolpalette").ejSymbolPalette({showPaletteItemText: true});
       * &lt;/script&gt
       * @memberof ejSymbolPalette
       * @instance
       */
            showPaletteItemText: true,
            /** Enable or disable the Drag function of items in the palette 
       * @default true
       * @type {Boolean}
       * @example
       * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
       * &lt;script&gt;
       * $("#symbolpalette").ejSymbolPalette({allowDrag: true});
       * &lt;/script&gt
       * @memberof ejSymbolPalette
       * @instance
       */
            allowDrag: true,
            /** Collection of palette items 
        * @default null
        * @type {Array}
        * @example
        * &lt;div id="symbolpalette"&gt;&lt;/div&gt;<br>
        * &lt;script&gt;
        * $("#symbolpalette").ejSymbolPalette({palettes: palette});
        * &lt;/script&gt
        * @memberof ejSymbolPalette
        * @instance
        */
            palettes: []
        },

        dataTypes: {
            paletteItemWidth: "number",
            paletteItemHeight: "number",
            previewWidth: "number",
            previewHeight: "number",
            headerHeight: "number",
            showPaletteItemText: "boolean",
            allowDrag: "boolean",
            palettes: "array"
        },

        _canvas: null,

        _init: function () {
            if (!(ej.browserInfo().name === "msie" && Number(ej.browserInfo().version) < 9)) {
                this.selectedItem = null;
                this.activePalette = null;
                this._selectedElement = null;
                this._renderSymbolPalette();
                this._wireEvents();
                this.updateScrollerViewport();
            }
        },

        _setModel: function (options) {
            for (var option in options) {
                switch (option) {
                    case "width":
                        this._setWidth(options[option]);
                        break;
                    case "height":
                        this._setHeight(options[option]);
                        break;
                    case "paletteItemWidth":
                        this.model.paletteItemWidth = options[option];
                        this._redrawContent();
                        break;
                    case "paletteItemHeight":
                        this.model.paletteItemHeight = options[option];
                        this._redrawContent();
                        break;
                    case "headerHeight":
                        this._setHeaderHeight(options[option]);
                        break;
                    case "cssClass":
                        this._setCssClass(options[option]);
                        break;
                    case "showPaletteItemText":
                        this._showItemText(options[option]);
                        break;
                }
            }
        },

        _destroy: function () {
            this.element.empty().removeClass(this.model.cssClass);
        },
        //#endregion

        //#region Rendering
        _renderSymbolPalette: function () {
            this._canvas = document.createElement("div");
            this._canvas.setAttribute("class", "e-scanvas");
            this._canvas.setAttribute("id", this.element[0].id + "_canvas");

            this.element[0].setAttribute("style", "height:" + this.model.height + "; width:" + this.model.width + ";");
            this.element.append(this._canvas);
            this.element.ejScroller({ width: this._setViewPortWidth(), height: this._setViewPortHeight() });
            var palettes = this.model.palettes;
            if (palettes) {
                for (var i = 0, len = palettes.length; i < len; i++) {
                    palettes[i] = ej.datavisualization.Diagram.Palette(palettes[i], this);
                    this._renderPalette(palettes[i]);
                }
            }
        },
        _initGroupNode: function (group) {
            var child = null;
            for (var i = 0; i < group.children.length; i++) {
                child = group.children[i];
                if (typeof (child) == "object") {
                    if (child.type == "group") {
                        child = ej.datavisualization.Diagram.Group(child);
                        palette._initGroupNode(child);
                    }
                    else if (child.segments)
                        child = ej.datavisualization.Diagram.Connector(child);
                    else
                        child = ej.datavisualization.Diagram.Node(child);
                    child.parent = group.name;
                    this.nameTable[child.name] = child;
                }
            }
        },
        _setViewPortWidth: function () {
            this.element[0].setAttribute("style", "width:" + this.model.width + ";");
            var w = this.element.width();
            // var left = this.element[0].offsetLeft;
            return Math.abs(w);
        },

        _setViewPortHeight: function () {
            this.element[0].setAttribute("style", "height:" + this.model.height + ";");
            var h = this.element.height();
            //var top = this.element[0].offsetTop;
            return Math.abs(h);
        },
        _renderPalette: function (palette) {
            this._renderHeader(palette);
            this._renderContent(palette);
            this._collapse(palette);
        },

        _renderHeader: function (palette) {
            var header = document.createElement("div");
            var attr = { "id": palette.name + "_header", "class": "e-header", "style": "height:" + this.model.headerHeight + "px;" };
            ej.datavisualization.Diagram.Util.attr(header, attr);
            this._renderHeaderArrow(header, palette.expanded, palette.name);
            this._renderHeaderText(header, palette.name);
            this._addExpandedClass(header, palette.expanded);
            if (this.model.selectedPaletteName === palette.name) {
                $(header).addClass("selected");
                this.activePalette = palette;
            }
            this._canvas.appendChild(header);
        },

        _renderHeaderText: function (header, text) {
            var span = document.createElement("span");
            span.setAttribute("class", "e-header-text");
            span.innerHTML = text;
            header.appendChild(span);
        },

        _renderHeaderArrow: function (header, expanded, index) {
            var arrow = document.createElement("span");
            arrow.setAttribute("class", "e-header-arrow e-icon");
            arrow.setAttribute("style", "top:" + (this.model.headerHeight - 16) / 2 + "px;");
            this._addExpandedClass(arrow, expanded);
            if (this.model.selectedPaletteName === name)
                $(arrow).addClass("selected");
            header.appendChild(arrow);
        },

        _renderContent: function (palette) {
            var content = document.createElement("div");
            content.setAttribute("id", palette.name + "_content");
            content.setAttribute("class", "e-scontent");
            if ((this.model.palettes.length - 1) === this.model.palettes.indexOf(palette))
                content.setAttribute("style", "border-bottom-width: 0px;");
            this._canvas.appendChild(content);
            var paletteItems = palette.items;
            if (paletteItems && paletteItems.length > 0) {
                for (var i = 0, len = paletteItems.length; i < len; i++) {
                    if (paletteItems[i].parent)
                        this.nameTable[paletteItems[i].name] = paletteItems[i];
                    else {
                        this._renderItem(paletteItems[i], content);
                        this.nameTable[paletteItems[i].name] = paletteItems[i];
                    }
                }
            }
        },

        _renderItem: function (paletteItem, content) {
            var svg = this._renderItemContainer(paletteItem.name, content);
            if (paletteItem.segments)
                this._renderConnector(paletteItem, svg);
            else if (paletteItem.type == "node")
                this._renderNode(paletteItem, svg);
            else
                this._renderGroup(paletteItem, svg);
        },

        _renderItemContainer: function (id, content, isDrag) {
            var container = document.createElement("div");
            var attr = { "id": id + "_paletteItem", "draggable": "true", "height": this.model.paletteItemHeight + "px", "width": this.model.paletteItemWidth + "px", "class": "e-paletteItem", "style": "-ms-touch-action: none;touch-action: none;" };
            ej.datavisualization.Diagram.Util.attr(container, attr);
            content.appendChild(container);
            var paletteId = this.element[0].id;
            var context = this;
            if (!isDrag) {
                $(container).ejDraggable({
                    clone: true,
                    cursorAt: { top: context.model.previewOffset.y, left: context.model.previewOffset.x },
                    helper: function (event) {
                        var diagram = $("#" + context.model.diagramId).ejDiagram("instance");
                        var paletteItemWidth, paletteItemHeight;
                        paletteItemWidth = context.model.paletteItemWidth;
                        paletteItemHeight = context.model.paletteItemHeight;
                        context.model.paletteItemWidth = context.model.previewWidth;
                        context.model.paletteItemHeight = context.model.previewHeight;
                        var svg = context._renderItemContainer(context.selectedItem.name + "_clone", document.body, true);
                        svg.document.setAttribute("drag", "true");
                        var item = $.extend(true, {}, context.selectedItem);
                        diagram._selectedSymbol = item;
                        diagram._paletteTable = context.nameTable;
                        diagram._palNameTable = $.extend(true, {}, context.nameTable);
                        if (item.segments) {
                            var bounds = ej.datavisualization.Diagram.Util.bounds(item);
                            var delWidth = (context.model.previewWidth - 10) / bounds.width;
                            var delHeight = (context.model.previewHeight - 10) / bounds.height;
                            diagram.scale(item, delWidth, delHeight, bounds.topLeft, diagram.nameTable);
                            context._renderConnector(item, svg);
                        }
                        else {
                            item.width = context.model.previewWidth - 10;
                            item.height = context.model.previewHeight - 10;
                            item.offsetX = item.width / 2 + 5;
                            item.offsetY = item.height / 2 + 5;
                            if (item.type == "node")
                                context._renderNode(item, svg);
                            else {
                                context._renderGroup(item, svg);

                            }
                        }
                        var helper = document.getElementById(context.selectedItem.name + "_clone_paletteItem");
                        $(helper).addClass("dragClone");
                        context.model.paletteItemWidth = paletteItemWidth;
                        context.model.paletteItemHeight = paletteItemHeight;
                        return $(helper);
                    },
                    drag: function () {
                        var proxy = this;
                        var element = $(".dragClone")[0];
                        if (element) {
                            element.setAttribute("paletteId", paletteId);
                        }
                    },
                    dragStop: function (event, ui) {
                        var diagram = $("#" + context.model.diagramId).ejDiagram("instance");
                        diagram._selectedSymbol = null;
                        $(".dragClone").remove();
                    }
                });
            }
            return this._renderAnchor(container, id);
        },

        _renderAnchor: function (container, id) {
            var anchor = document.createElement("div");
            var attr = { "id": id + "_anchor", "height": this.model.paletteItemHeight + "px", "width": this.model.paletteItemWidth + "px", "class": "e-anchor" };
            ej.datavisualization.Diagram.Util.attr(anchor, attr);
            container.appendChild(anchor);
            var svg = this._renderSvg(anchor, id);
            this._renderText(anchor, id);
            return svg;
        },

        _renderSvg: function (anchor, id) {
            var wrapper = document.createElement("div");
            var attr = {
                "id": id + "_svgWrapper", "width": this.model.paletteItemWidth + "px;",
                "height": +this.model.paletteItemHeight + "px;", "class": "e-svg-container"
            };
            ej.datavisualization.Diagram.Util.attr(wrapper, attr);
            attr = {
                "id": id + "_svg", "width": this.model.paletteItemWidth, "height": this.model.paletteItemHeight,
                "version": "1.1", "xlink": "http://www.w3.org/1999/xlink"
            };
            var svg = new ej.datavisualization.Diagram.Svg(attr);
            wrapper.appendChild(svg.document);
            anchor.appendChild(wrapper);
            return svg;
        },

        _renderText: function (anchor, text) {
            var div = document.createElement("div");
            div.setAttribute("class", "e-text-container");
            div.setAttribute("style", "width:" + this.model.paletteItemWidth + "px;");
            var span = document.createElement("span");
            span.setAttribute("class", "e-paletteItemText");
            span.innerHTML = text;
            div.appendChild(span);
            if (!this.model.showPaletteItemText)
                div.style.display = "none";
            anchor.appendChild(div);
        },

        _renderNode: function (node, svg) {
            var group = ej.datavisualization.Diagram.SvgContext.renderNode(node, svg);
            var isDrag = false;
            if (svg.document.getAttribute("drag") != null) {
                isDrag = true;
            }
            this._transformItem(group, node.width, node.height, node, isDrag);
        },

        _updateChildBounds: function (node, nameTable) {
            var child = null;
            if (node.type == "group") {
                var children = this._getChildren(node.children);
                for (var i = 0; i < children.length; i++) {
                    child = nameTable[children[i]];
                    if (child.type == "group")
                        this._updateChildBounds(child, nameTable);
                }
                ej.datavisualization.Diagram.Util._updateChildBounds(node, this);
            }
        },
        _getChildren: function (children) {
            if (children) {
                var children1 = [];
                for (var i = 0; i < children.length; i++) {
                    var child = children[i];
                    if (child) {
                        if (typeof (child) == "object") {
                            children1.push(child.name);
                        }
                        else if (typeof (child) == "string") {
                            children1.push(child);
                        }
                    }
                }
                return children1;
            }
        },
        _renderGroup: function (node, svg) {
            this._updateChildBounds(node, this.nameTable);
            var group = ej.datavisualization.Diagram.SvgContext.renderGroup(node, svg, null, this.nameTable, this);
            var isDrag = false;
            if (svg.document.getAttribute("drag") != null) {
                isDrag = true;
            }
            this._transformItem(group, node.width, node.height, node, isDrag);

        },
        _renderConnector: function (connector, svg) {
            var group = ej.datavisualization.Diagram.SvgContext.renderConnector(connector, svg);
            var bounds = ej.datavisualization.Diagram.Util.bounds(connector);
            var isDrag = false;
            if (svg.document.getAttribute("drag") != null) {
                isDrag = true;
            }
            this._transformItem(group, bounds.width, bounds.height, null, isDrag);
        },

        //#endregion

        //#region Events
        _wireEvents: function () {
            this._on(this.element, ej.eventType.click, ".e-header", this._headerClick);
            this._on(this.element, ej.eventType.mouseDown, ".e-header", this._headerMouseDown);
            this._on(this.element, "mouseover", ".e-header", this._headerMouseOver);
            this._on(this.element, "mouseout", ".e-header", this._headerMouseOut);
            this._on(this.element, ej.eventType.mouseDown, ".e-paletteItem", this._itemMouseDown);
            this._on(this.element, "mouseover", ".e-paletteItem", this._itemMouseOver);
            this._on(this.element, "mouseout", ".e-paletteItem", this._itemMouseOut);
            this._on(this.element, ej.eventType.click, ".e-anchor", this._itemClick);
        },

        _headerClick: function (evt) {
            var proxy = this;
            $(evt.currentTarget).next(".e-scontent").slideToggle(200, function () {
                proxy._refresh();
            });
            this._updateHeaderState(evt.currentTarget);
            var palette = this._getActivePalette(evt.currentTarget.id);
            if (palette && palette !== this.activePalette)
                this.activePalette = palette;


        },

        _headerMouseDown: function (evt) {
            evt.preventDefault();
            evt.stopPropagation();
        },

        _headerMouseOver: function (evt) {
            $(evt.currentTarget).addClass("hover");
            $(evt.currentTarget).find(".e-header-arrow").addClass("hover");
        },

        _headerMouseOut: function (evt) {
            $(evt.currentTarget).removeClass("hover");
            $(evt.currentTarget).find(".e-header-arrow").removeClass("hover");
        },

        _itemMouseDown: function (evt) {
            if (this.model.diagramId) {
                var diagram = $("#" + this.model.diagramId).ejDiagram("instance");
                if (diagram.activeTool instanceof ej.datavisualization.Diagram.LineTool) {
                    diagram.activeTool._showAllPorts(true);
                    diagram.deactivateTool();
                }
            }
            if (!this.model.allowDrag) {
                evt.preventDefault();
                evt.stopPropagation();
            }
            if (this._selectedElement) {
                if (this._selectedElement !== evt.currentTarget) {
                    $(this._selectedElement).removeClass("selected");
                    this._selectedElement = evt.currentTarget;
                }
            }
            else
                this._selectedElement = evt.currentTarget;
            if (!($(evt.currentTarget).hasClass("selected")))
                $(evt.currentTarget).addClass("selected");

            var palette = this._getActivePalette(evt.currentTarget.parentElement.id);
            if (palette && palette !== this.activePalette) {
                this._clearHeaderSelection();
                this._updateHeaderSelection($(evt.currentTarget.parentElement).prev());
                this.activePalette = palette;
            }

            if (this.activePalette && this._selectedElement) {
                var name = this._selectedElement.id.slice(0, this._selectedElement.id.lastIndexOf('_'));
                var items = this.activePalette.items;
                for (var i = 0, len = items.length; i < len; i++) {
                    var item = items[i];
                    if (item.name === name)
                        this.selectedItem = item;
                }
            }
        },

        _itemMouseOver: function (evt) {
            $(evt.currentTarget).addClass("hover");
        },

        _itemMouseOut: function (evt) {
            $(evt.currentTarget).removeClass("hover");
        },

        _itemDraStart: function (evt) {
            var dataTransfer = evt.originalEvent.dataTransfer;
            dataTransfer.setData("Text", this.element[0].id);
            dataTransfer.effectAllowed = "copy";
        },

        _itemClick: function (evt) {
            if (this.model.diagramId) {
                if (evt.type === "click" || (evt.type === "touchend" && !$(".dragClone")[0])) {
                    var diagram = $("#" + this.model.diagramId).ejDiagram("instance");
                    var item = $.extend(true, {}, this.selectedItem);
                    item.name += ej.datavisualization.Diagram.Util.randomId();
                    if (item.type == "group") {
                        for (var j = 0; j < item.children.length; j++) {
                            var newObj = $.extend(true, {}, this.nameTable[item.children[j]]);
                            newObj.parent = item.name;
                            newObj.name = item.name + newObj.name;
                            item.children[j] = newObj.name;
                            diagram.nameTable[newObj.name] = newObj;
                            diagram.nodes().push(newObj);
                            ej.datavisualization.Diagram.SpatialUtil._updateQuad(diagram, diagram._spatialSearch, newObj);
                        }
                        item.height = item.width = 0;
                        diagram._updateChildBounds(item, diagram.nameTable);
                    }
                    if (item) {
                        if (!item.isLane)
                            diagram.add(item);
                        else {
                            var randomId = ej.datavisualization.Diagram.Util.randomId();
                            diagram._selectedSymbol = item;
                            diagram._cloneGroupNode(item, randomId);
                            var obj = ej.datavisualization.Diagram.SwimLaneHelper._createDiagramLane(item, diagram.nameTable);
                            obj.isLane = item.isLane;
                            obj.orientation = item.orientation;
                            diagram.add(obj);
                            var swimlane = ej.datavisualization.Diagram.SwimLaneHelper._createSwimlane(obj, diagram);
                            if (swimlane) {
                                diagram.remove(obj);
                                swimlane.offsetX += 10;
                                swimlane.offsetY += 40;
                                diagram.add(swimlane);
                            }
                            diagram._selectedSymbol = null;
                        }
                    }
                }
            }
        },

        _collectionChanged: function (args) {
            if (args.changeType == "insert") {
                this._renderPalette(args.element);
            }
            else if (args.changeType == "remove") {
                var palette = args.element;
                if (palette != null) {
                    var paletteHeader = document.getElementById(palette.name + "_header");
                    if (paletteHeader)
                        paletteHeader.parentNode.removeChild(paletteHeader);
                    var paletteContent = document.getElementById(palette.name + "_content");
                    if (paletteContent)
                        paletteContent.parentNode.removeChild(paletteContent);
                }
            }
        },
        //#endregion

        //#region Public methods

        addPaletteItem: function (paletteName, item) {
            var content, palette;
            for (var i = 0; i < this.model.palettes.length; i++) {
                palette = this.model.palettes[i];
                if (palette.name === paletteName) {
                    palette.items.push(item);
                    content = document.getElementById(paletteName + "_content");
                    this._renderItem(item, content);
                }
            }
        },

        removePaletteItem: function (paletteName, item) {
            var content, palette;
            for (var i = 0; i < this.model.palettes.length; i++) {
                palette = this.model.palettes[i];
                if (palette.name === paletteName) {
                    ej.datavisualization.Diagram.Util.removeItem(palette.items, item);
                    content = document.getElementById(paletteName + "_content");
                    content.removeChild(content.getElementsByClassName("e-paletteItem e-draggable e-js").item(item.name + "_paletteItem"));
                    this.selectedItem = null;
                }
            }
        },

        addPalette: function (palette) {
            this.model.palettes.push(palette);
            this._renderPalette(palette);
        },

        removePalette: function (paletteName) {
            var paletteHeader, paletteContent, palette;
            for (var i = 0; i < this.model.palettes.length; i++) {
                palette = this.model.palettes[i];
                if (palette.name === paletteName) {
                    ej.datavisualization.Diagram.Util.removeItem(this.model.palettes, palette);
                    paletteHeader = document.getElementById(palette.name + "_header");
                    if (paletteHeader)
                        paletteHeader.parentNode.removeChild(paletteHeader);
                    paletteContent = document.getElementById(palette.name + "_content");
                    if (paletteContent)
                        paletteContent.parentNode.removeChild(paletteContent);
                }
            }
        },
        setWidth: function (value) {
            this.model.width = value;
            this._setWidth(value);
        },

        setHeight: function (value) {
            this.model.height = value;
            this._setHeight(value);
        },

        setPaletteItemWidth: function (value) {
            this.model.paletteItemWidth = value;
            this._redrawContent();
        },

        setPaletteItemHeight: function (value) {
            this.model.paletteItemHeight = value;
            this._redrawContent();
        },

        setHeaderHeight: function (value) {
            this.model.headerHeight = value;
            this._setHeaderHeight(value);
        },

        setCssClass: function (value) {
            this._setCssClass(value);
            this.model.cssClass = value;
        },

        showPaletteItemText: function (value) {
            this._showItemText(value);
            this.model.showPaletteItemText = value;
        },

        searchPalette: function (palette, key) {
            var paletteCollection = new ej.datavisualization.Diagram.Collection();
            var paletteItems = null;
            if (key != "") {
                palette = this._getSearchPaletteItems(key);
                paletteCollection.add(palette);
            }
            return paletteCollection;
        },
        //#endregion

        //#region Helper methods
        _getSearchPaletteItems: function (key) {
            var palette = new ej.datavisualization.Diagram.Palette();
            var palettes = this.model.palettes, i, j;
            for (i = 0; i < palettes.length; i++) {
                if ((((palettes[i].name).toLocaleLowerCase()).search(key.toLocaleLowerCase())) >= 0) {
                    for (j = 0; j < palettes[i].items.length; j++) {
                        this.element.find("#" + palettes[i].items[j].name + "_paletteItem")[0].style.display = "block";
                    }
                }
                else {
                    for (j = 0; j < palettes[i].items.length; j++) {
                        if ((((palettes[i].items[j].name).toLocaleLowerCase()).search(key.toLocaleLowerCase())) >= 0) {
                            this.element.find("#" + palettes[i].items[j].name + "_paletteItem")[0].style.display = "block";
                        }
                        else
                            this.element.find("#" + palettes[i].items[j].name + "_paletteItem")[0].style.display = "none";
                    }
                }
            }
            return palette;
        },

        _addExpandedClass: function (element, expanded) {
            if (expanded)
                $(element).addClass("expanded");
            else
                $(element).addClass("collapsed");
        },

        _collapse: function (palette) {
            if (!palette.expanded)
                $(document.getElementById(palette.name + "_header")).next(".e-scontent").slideToggle(10);

        },

        _transformItem: function (group, width, height, node, isDrag) {
            if (!isDrag) {
                var scale = this._getScaleFactor(width, height);
                var translate = this._getTranslateFactor(width, height);
                var transform = "";
                //translate
                transform += "translate(" + translate + "," + translate + ")";
                //scale
                transform += "scale(" + scale + "," + scale + ")";
                group.setAttribute("transform", transform);
            }
            if (node && ej.browserInfo().name === "msie") {
                if (node.type == "group" && node.shape.type === "html") {
                    var htmlDiv = document.getElementById(node.name + "_html");
                    htmlDiv.setAttribute("style", "zoom:" + scale + ";");
                }
            }
        },

        _getScaleFactor: function (width, height) {
            var fx = (30 * this.model.paletteItemWidth) / 100;
            var fy = (30 * this.model.paletteItemHeight) / 100;
            var sx = (this.model.paletteItemWidth - fx) / width;
            var sy = (this.model.paletteItemHeight - fy) / height;
            sx = sx > 1 ? 1 : sx;
            sy = sy > 1 ? 1 : sy;
            return Math.min(sx, sy);
        },

        _getTranslateFactor: function (width, height) {
            var x = (15 / 100) * this.model.paletteItemWidth;
            var y = (15 / 100) * this.model.paletteItemHeight;
            return Math.min(x, y);
        },

        _setWidth: function (val) {
            this.element.css("width", val);
        },

        _setHeight: function (val) {
            this.element.css("height", val);
        },

        _setHeaderHeight: function (val) {
            this.element.find(".e-header").css("height", val);
            this.element.find(".e-header-arrow").css("top", (val - 16) / 2);
        },

        _setCssClass: function (val) {
            this.element.removeClass(this.model.cssClass).addClass(val);
        },

        _showItemText: function (val) {
            if (val !== this.model.showPaletteItemText)
                if (val) {
                    this.element.find(".e-text-container").show();
                }
                else
                    this.element.find(".e-text-container").hide();
        },

        _redrawContent: function () {
            var contents = this.element.find(".e-scontent");
            for (var i = 0, len = contents.length; i < len; ++i) {
                var content = contents[i];
                $(content).empty();
                var palette = this.model.palettes[i];
                var paletteItems = palette.items;
                if (paletteItems && paletteItems.length > 0) {
                    for (var count = 0, l = paletteItems.length; count < l; count++) {
                        this._renderItem(paletteItems[count], content);
                    }
                }
            }
        },

        _getActivePalette: function (elementId) {
            var name = elementId.slice(0, elementId.lastIndexOf('_'));
            var palettes = this.model.palettes;
            for (var i = 0, len = palettes.length; i < len; i++) {
                var palette = palettes[i];
                if (palette.name === name && palette !== this.activePalette)
                    return palette;
            }
            return null;
        },

        _updateHeaderState: function (target) {
            this._clearHeaderSelection();
            this._updateExpandState(target);
            this._updateHeaderSelection(target);
        },

        _updateExpandState: function (target) {
            if (($(target).hasClass("expanded"))) {
                $(target).removeClass("expanded").addClass("collapsed");
                $(target).find(".e-header-arrow").removeClass("expanded").addClass("collapsed");
            }
            else {
                $(target).removeClass("collapsed").addClass("expanded");
                $(target).find(".e-header-arrow").removeClass("collapsed").addClass("expanded");
            }
        },

        _updateHeaderSelection: function (target) {
            if (!($(target).hasClass("selected"))) {
                $(target).addClass("selected");
                $(target).find(".e-header-arrow").addClass("selected");
            }
        },

        _clearHeaderSelection: function () {
            this.element.find(".e-header").removeClass("selected");
            this.element.find(".e-header-arrow").removeClass("selected");
        },

        _addItem: function (palette, item) {
            var content = document.getElementById(palette.name + "_content");
            this._renderItem(item, content);
        },

        _removeItem: function (palette, item) {
            var content = document.getElementById(palette.name + "_content");
            content.removeChild(document.getElementById(item.name + "_paletteItem"));
            if (item === this._selectedElement)
                this._selectedElement = null;
        },

        updateScrollerViewport: function () {
            var scroller = this.element.ejScroller("instance");
            scroller.model.touchScroll = false;
            scroller.model.width = this._setViewPortWidth();
            scroller.model.height = this._setViewPortHeight();
            this._refresh();
        },

        _refresh: function () {
            this.element.ejScroller("refresh");
        },

        //#endregion
    });
    //#endregion

})(jQuery, Syncfusion);;


(function ($, ej) {
    "use strict";
    //#region Extends
    ej.datavisualization.Diagram.extend = function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        __.prototype = b.prototype;
        d.prototype = new __();
    }
    //#endregion

    //#region Tool
    var ToolBase = (function () {
        function ToolBase(name, diagram) {
            this.name = name;
            this.diagram = diagram;
            this.helper = null;
            this.inAction = false;
            this.selectedObject = null;
            this.startPoint = ej.datavisualization.Diagram.Point(0, 0);
            this.currentPoint = ej.datavisualization.Diagram.Point(0, 0);
            this.previousPoint = ej.datavisualization.Diagram.Point(0, 0);
            this.cursor = "default";
            this._currentPossibleConnection = null;
            this._previousPossibleConnection = null;
            this._possibleConnectionPort = null;
            this.singleAction = false;
            this.svgHelper = null;
            this.single = null;
            this._centralPoint = ej.datavisualization.Diagram.Point(0, 0);
            this._enableAutoNode = null;
            this._prevTool = null;
        }
        ToolBase.prototype.abort = function (evt) {
            this._endAction();
            ej.datavisualization.Diagram.SvgContext.updateSelector(this.diagram.selectionList[0], this.diagram._svg, this.diagram._currZoom, this.diagram, this.diagram.model.selectedItems.constraints);
            this.diagram._removeTooltip();
        };
        ToolBase.prototype.keydown = function (evt) {
            var keycode = evt.keyCode ? evt.keyCode : evt.which;
            if (keycode === 27 && this.inAction) {
                this.abort();
            }
            else if (!this.inAction && keycode == 27) {
                this.diagram._clearSelection();
            }
        };

        ToolBase.prototype._containChil = function (node, list) {
            for (var i = 0; i < list.length; i++) {
                if (list[i] == node.name)
                    return true;
            }
        };

        ToolBase.prototype._containsSwimlane = function (list) {
            for (var i in list) {
                var child = this.diagram.nameTable[list[i]];
                if (child.isSwimlane || child.isLane)
                    return false;
            }
            return true;
        };

        ToolBase.prototype._decideSelectedItem = function (evt, node, skip) {
            var obj = null;
            if (node) {
                if (node.parent) {
                    if (this.diagram.selectionList && this.diagram.selectionList[0] && node.parent == this.diagram.selectionList[0].name && !skip)
                        obj = node;
                    else {
                        if (skip && this.diagram.selectionList[0] && this.diagram.selectionList[0].name == node.name) {
                            obj = node;
                        }
                        else {
                            var item = this.diagram.nameTable[node.parent];
                            obj = this._decideSelectedItem(evt, item, skip);
                            if (this.diagram.selectionList && this.diagram.selectionList[0]) {
                                if (obj && this.diagram.selectionList[0].name == obj.name && !skip)
                                    obj = node;
                            }
                        }
                    }
                } else {
                    obj = node;
                }
            }
            else {
                return null;
            }
            return obj;
        };


        ToolBase.prototype._removeHighLighter = function () {
            ej.datavisualization.Diagram.SvgContext._removeNodeHighlighter(this.diagram._svg, this.diagram._adornerLayer);
        };
        ToolBase.prototype._nodeHighLighter = function (overNode) {
            var source = null, childBounds = null, target = null;
            if (overNode && this.selectedObject.parent) //&& this.selectedObject.parent != overNode.name)
            {
                var parent = this.diagram.nameTable[this.selectedObject.parent];
                if (parent.container && parent.container.type == "stack" && this.selectedObject.name != overNode.name) {
                    ej.datavisualization.Diagram.SvgContext._drawNodeHighlighter(overNode, this.diagram._svg, this.diagram._adornerLayer, this.diagram._currZoom);
                }
                else if (parent.container && parent.container.type == "canvas" && this.selectedObject.parent != overNode.name) {
                    ej.datavisualization.Diagram.SvgContext._drawNodeHighlighter(overNode, this.diagram._svg, this.diagram._adornerLayer, this.diagram._currZoom);
                }
                else this._removeHighLighter();
            }
            else if (overNode && overNode.container && !overNode.isSwimlane) {
                ej.datavisualization.Diagram.SvgContext._drawNodeHighlighter(overNode, this.diagram._svg, this.diagram._adornerLayer, this.diagram._currZoom);
            }

            else
                this._removeHighLighter();
            if (this._nodeToHit && overNode && overNode.name != this._nodeToHit.name) {
                childBounds = ej.datavisualization.Diagram.Util.bounds(this._nodeToHit);
                target = this._getTargetNode(this._nodeToHit, childBounds);
                this._raiseEvent("mouseLeave", { element: this.selectedObject, source: this._nodeToHit, target: target });
            }
            if (overNode) {
                if (this._nodeToHit && this._nodeToHit.name !== overNode.name || !this._nodeToHit) {
                    this._nodeToHit = overNode;
                    if (this.selectedObject.parent)
                        source = this.diagram.nameTable[this.selectedObject.parent];
                    if (this.selectedObject.type == "pseudoGroup") {
                        var fChild = this.diagram.nameTable[this.diagram._getChild(this.selectedObject.children[0])];
                        if (fChild && fChild.parent)
                            source = this.diagram.nameTable[fChild.parent];
                    }
                    childBounds = ej.datavisualization.Diagram.Util.bounds(overNode);
                    target = this._getTargetNode(overNode, childBounds);
                    this._raiseEvent("mouseEnter", { element: this.selectedObject, source: source, target: target });
                }
            }
            else {
                this._nodeToHit = null;
            }
            if (overNode) {
                if (this.selectedObject.parent)
                    source = this.diagram.nameTable[this.selectedObject.parent];
                childBounds = ej.datavisualization.Diagram.Util.bounds(overNode);
                target = this._getTargetNode(overNode, childBounds);
                this._raiseEvent("mouseOver", { element: this.selectedObject, source: source, target: target });
            }
        };

        ToolBase.prototype._doubleClick = function (element) {
            if (element && element.parent) {
                var parent = this.diagram.nameTable[element.parent]
                if (parent && parent.container) {
                    var name = element.name;
                    this.diagram.updateSelectedObject(name);
                    this.diagram.addSelection(element);
                }
            }
        };

        ToolBase.prototype._itemClick = function (element, actualObject, selectedObject) {
            if (actualObject && actualObject.parent) {
                var parent = this.diagram.nameTable[actualObject.parent]
                if (parent && parent.container) {
                    if (actualObject && !this.diagram._selectedSymbol) {
                        var name = actualObject.name;
                        if (name.indexOf("_header_swimlane") != -1) {
                            if (element)
                                this.diagram.updateSelectedObject(element.parent);
                        }
                        else if (name.indexOf("_Headerr_") != -1)
                            this.diagram.updateSelectedObject(actualObject.parent);
                        else
                            this.diagram.updateSelectedObject(name);
                    }
                }
            }
            else if (actualObject) {
                this.diagram.updateSelectedObject(actualObject.name);
            }
            if (element && (element.type == "pseudoGroup" || element.name == "multipleSelection") && !this._containsChild(element, actualObject.name)) {
                this.diagram.updateSelectedObject(element.name)
            }
        };



        ToolBase.prototype._getTargetNode = function (node, childBounds) {
            var bounds = null, nodes = [];
            var quads = ej.datavisualization.Diagram.SpatialUtil.findQuads(this.diagram._spatialSearch, childBounds);
            for (var i = 0; i < quads.length; i++) {
                var quad = quads[i];
                if (quad.objects.length > 0) {
                    for (var j = 0; j < quad.objects.length; j++) {
                        var nd = quad.objects[j];
                        if (!nd.segments) {
                            bounds = ej.datavisualization.Diagram.Util.bounds(nd);
                            if (nodes.indexOf(nd) == -1 && ej.datavisualization.Diagram.Geometry.intersectsRect(childBounds, bounds))
                                nodes.push(nd);

                        }
                    }
                }
            }
            var collection = [];
            collection.push(node);
            for (i = 0; i < nodes.length; i++) {
                if (nodes[i].name != node.name)
                    collection.push(nodes[i]);
            }
            return collection;
        };
        ToolBase.prototype._updateMargin = function (node, group) {
            if (node.type == "pseudoGroup") {
                var child = null;
                var children = this.diagram._getChildren(node.children);
                for (var i = 0; i < children.length; i++) {
                    child = this.diagram.nameTable[children[i]];
                    this._updateMargin(child, group);
                }
            }
            else if (group && group.container && group.container.type == "canvas") {
                var groupBounds = ej.datavisualization.Diagram.Util.bounds(group); //ej.datavisualization.Diagram.SvgContext.getCanvasBoundingBox(group, this.diagram, node, true);
                var bounds1 = ej.datavisualization.Diagram.Util.bounds(node);
                var bounds = ej.datavisualization.Diagram.Geometry.rect([bounds1.topLeft, bounds1.topRight, bounds1.bottomRight, bounds1.bottomLeft]);
                node.marginLeft = bounds.x - (groupBounds.x + group.paddingLeft);
                node.marginRight = (groupBounds.x + group.width) - (bounds.x + bounds.width) - group.paddingRight;
                node.marginTop = bounds.y - (groupBounds.y + group.paddingTop);
                node.marginBottom = groupBounds.bottom - (bounds.y + bounds.height) - group.paddingBottom;
            }
        };
        ToolBase.prototype._getNodeUnderMouse = function (evt) {
            var type;
            var node = null;
            var obj = null;
            var parent = $(evt.target).parents(".ej-d-node,.ej-d-connector,.ej-d-group");
            if (parent) {
                type = parent.attr("class");
                if (type === "ej-d-node" || type === "ej-d-group") {
                    node = this.diagram._findNode(parent.attr("id"));
                } else if (type === "ej-d-connector") {
                    node = this.diagram._findConnector(parent.attr("id"));
                }
            }
            if (node) {
                if (node.type == "group") {
                    obj = node;
                }
                else {
                    if (node.parent) {
                        var parent1 = this.diagram.nameTable[node.parent];
                        if (parent1)
                            obj = parent1;
                    }
                }
            }
            return obj;
        };

        ToolBase.prototype._isChange = function (obj1, obj2) {
            var status = null;
            if (obj1.type == "group" || obj1.type == "pseudoGroup" || obj2.type == "group" || obj2.type == "pseudoGroup") {
                if ((obj1.type == "group" || obj1.type == "pseudoGroup") && !(obj2.type == "group" || obj2.type == "pseudoGroup")) {
                    status = !this._containsChild(obj1, obj2.name);
                }
                if (!(obj1.type == "group" || obj1.type == "pseudoGroup") && (obj2.type == "group" || obj2.type == "pseudoGroup")) {
                    status = !this._containsChild(obj2, obj1.name);
                }
                else if ((obj1.type == "group" || obj1.type == "pseudoGroup") && (obj2.type == "group" || obj2.type == "pseudoGroup")) {
                    if (obj1.name == obj2.name)
                        status = true;
                }
            }
            else {
                if (obj1.name == obj2.name)
                    status = true;
            }
            return status;
        };
        ToolBase.prototype._containsChild = function (node, childName) {
            var status = true;
            var child = null;
            if (node.children) {
                var children = this.diagram._getChildren(node.children);
                for (var i = 0; i < children.length; i++) {
                    child = this.diagram.nameTable[children[i]];
                    if (child.type == "group")
                        status = this._containsChild(child, childName);
                    else {
                        if (child.name == childName)
                            status = false;
                    }
                }
            }
            return status;
        };

        ToolBase.prototype._findNodeUnderMouse = function (evt, skip) {
            var obj = null;
            var node = null;
            var type;
            var parent = $(evt.target).parents(".ej-d-node,.ej-d-connector,.ej-d-group");
            if (parent) {
                type = parent.attr("class");
                if (type === "ej-d-node" || type === "ej-d-group") {
                    node = this.diagram._findNode(parent.attr("id"));
                } else if (type === "ej-d-connector") {
                    node = this.diagram._findConnector(parent.attr("id"));
                }
            }
            if (node && !node.parent)
                obj = node;
            else
                obj = this._decideSelectedItem(evt, node, skip);
            this.prevSelectObject = obj;

            if (skip && this.diagram.selectionList[0]) {
                if (obj && obj.type == "group" && !this._containsChild(obj, this.diagram.selectionList[0].name))
                    obj = obj;
                else if (obj && this.diagram.selectionList[0].name != obj.name && this._isChange(this.diagram.selectionList[0], obj))
                    obj = this.diagram.selectionList[0];
                else if (node && node.name == this.diagram.selectionList[0].name && !this._isChange(this.diagram.selectionList[0], obj)) {
                    obj = this.diagram.selectionList[0];

                }
            }
            this.actualObject = node;
            return obj;

        };

        ToolBase.prototype._findLabelUnderMouse = function (evt, skip) {
            var obj;
            var rect = $(evt.target);
            var rectid = rect.context.id.split('_');
            if (rectid[rectid.length - 1] == "lblbg") {
                var parent = $(evt.target).parents(".ej-d-node,.ej-d-connector,.ej-d-group");
                if (parent) {
                    var id = parent[0].getAttribute("id");
                    var type = parent[0].getAttribute("class");
                    if (type) {
                        if (type === "ej-d-node" || type === "ej-d-group") {
                            obj = this.diagram._findNode(id);
                            var curlabel = this.diagram._findLabelAtPoint(this.currentPoint, obj);
                            this.activeLabel = curlabel;
                        }
                        else if (type === "ej-d-connector") {
                            obj = this.diagram._findConnector(id);
                            var curlabel = this.diagram._findLabelAtPoint(this.currentPoint, obj);
                            this.activeLabel = curlabel;
                        }
                    }
                }
            }
            return obj;
        };
        ToolBase.prototype._selectionContainsChild = function (name) {
            if (this.diagram.selectionList[0].children) {
                var children = this.diagram._getChildren(this.diagram.selectionList[0].children);
                var child = null;
                for (var i = 0; i < children.length; i++) {
                    child = this.diagram.nameTable[children[i]];
                    if (child && child.name == name)
                        return true;
                }
            }
            else if (this.diagram.selectionList[0].type == "group" && this.diagram.selectionList[0].type != "pseudoGroup") {
                if (this.diagram.selectionList[0].name == name)
                    return true;
            }
            else if (this.diagram.nameTable[name] && this.diagram.nameTable[name].type == "group") {
                children = this.diagram._getChildren(this.diagram.nameTable[name].children);
                for (var j = 0; j < children.length; j++) {
                    child = this.diagram.nameTable[children[j]];
                    if (child)
                        var status = this._selectionContainsChild(child.name);
                    if (status)
                        return status;
                }
            }
            else if (this.diagram.selectionList[0].name == name)
                return true;

            return false;
        };

        ToolBase.prototype._isSelected = function (name) {
            var child = null;
            var node = this.diagram.nameTable[name];
            if (this._selectionContainsChild(node.name))
                return true;
            else if (node.type == "group") {
                var children = this.diagram._getChildren(node.children);
                for (var i = 0; i < children.length; i++) {
                    child = children[i];
                    if (this._selectionContainsChild(child))
                        return true;
                }
            }
            return false;
        };
        ToolBase.prototype._isColleagueSelected = function (name) {
            var node = this.diagram.nameTable[name];
            var child = null;
            if (node.parent) {
                var parent = this.diagram.nameTable[node.parent];
                if (parent) {
                    var children = this.diagram._getChildren(parent.children);
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        if (this._isSelected(child))
                            return true;
                    }
                }
            }
            return false;
        };
        ToolBase.prototype._isInSelection = function (name) {
            if (this.diagram.selectionList[0].type == "pseudoGroup" && this.diagram.selectionList[0].children) {
                var children = this.diagram._getChildren(this.diagram.selectionList[0].children);
                var child = null;
                for (var i = 0; i < children.length; i++) {
                    child = this.diagram.nameTable[children[i]];
                    if (child.name == name)
                        return true;
                }
            }
        };
        ToolBase.prototype._getCloneNode = function (node) {
            var obj = null;
            obj = jQuery.extend(true, {}, node);
            obj.children = [];
            obj.minHeight = 0;
            obj.minWidth = 0;
            obj.maxHeight = 0;
            obj.maxWidth = 0;
            return obj;
        };
        ToolBase.prototype._getProcessedObject = function (name, obj) {
            var node = this.diagram.nameTable[name];
            if (node) {
                if (this._isInSelection(name)) {
                    return null;
                }
                else if (this._selectionContainsChild(node.name))
                    return { add: node, remove: null };
                else {
                    if (node.parent) {
                        if (this._selectionContainsChild(node.parent)) {
                            if (this._isInSelection(node.parent))
                                return { add: node, remove: this.diagram.nameTable[node.parent] };
                            else {
                                var parent = this.diagram.nameTable[node.parent];
                                if (parent)
                                    return { add: parent, remove: this.diagram.nameTable[parent.parent] };
                            }
                        } else {
                            if (this._isColleagueSelected(node.parent) && !this._selectionContainsChild(node.parent)) {
                                if (this._isSelected(node.parent)) {
                                    return { add: node, remove: null };
                                }
                                else
                                    return { add: this.diagram.nameTable[node.parent], remove: null };
                            }
                            else if (this.diagram.selectionList[0] && this._isInSelection(node.parent)) {
                                return { add: this.diagram.nameTable[node.name], remove: this.diagram.nameTable[node.parent] };

                            }
                            else
                                return this._getProcessedObject(node.parent);
                        }
                    }
                    else {
                        return { add: node, remove: null };
                    }
                }
            }
        };

        ToolBase.prototype._measureStackBounds = function (group) {
            var child = null;
            var bounds;
            var rect = null;
            var children = this.diagram._getChildren(group.children);
            for (var i = 0; i < children.length; i++) {
                child = this.diagram.nameTable[children[i]];
                bounds = ej.datavisualization.Diagram.Util.bounds(child);

                if (bounds) {
                    if (!rect)
                        rect = bounds;
                    else
                        rect = this.diagram._union(bounds, rect);
                }
            }
            rect.width += group.paddingLeft + group.paddingRight;
            rect.height += group.paddingTop + group.paddingBottom;
            return rect;
        };
        ToolBase.prototype.hasSameParent = function () {
            if (this.selectedObject.type == "pseudoGroup") {
                var list = this.selectedObject;
                var child = null;
                if (this.diagram.nameTable[this.diagram._getChild(list.children[0])]) {
                    var parent = this.diagram.nameTable[this.diagram._getChild(list.children[0])].parent;
                    var lChildren = this.diagram._getChildren(list.children);
                    for (var i = 0; i < lChildren.length; i++) {
                        child = this.diagram.nameTable[lChildren[i]];
                        if (child.parent != parent || child.parent == "")
                            return false;
                    }
                }
                return true;
            }
            return false;
        },
            ToolBase.prototype._fromDiagram = function (list) {
                var state = true;
                var child = null;
                for (var i = 0; i < list.length; i++) {
                    child = this.diagram.nameTable[this.diagram._getChild(list[i])];
                    if (child && child.parent) {
                        state = false;
                        break;
                    }
                }
                return state;
            },
            ToolBase.prototype._fromContainer = function (list) {
                var child = null, parent = null;
                for (var i = 0; i < list.length; i++) {
                    child = this.diagram.nameTable[this.diagram._getChild(list[i])];
                    if (child.parent) {
                        parent = this.diagram.nameTable[child.parent];
                        if (parent) {
                            if (parent.container)
                                return true;
                        }
                    }
                }
            };

        ToolBase.prototype._fromSameContainer = function (list) {
            var child = null;
            var parent = null;
            for (var i = 0; i < list.length; i++) {
                child = this.diagram.nameTable[this.diagram._getChild(list[i])];
                if (!parent && child.parent)
                    parent = child.parent;
                if (child.parent) {
                    if (child.parent != parent)
                        return false;
                }
            }
            return true;
        },

        ToolBase.prototype._processCtrlKey = function (evt) {
            var obj;
            if (this.diagram.selectionList.length > 0) {
                var selectionList = this.diagram.selectionList;
                var isMultipleSelection;
                if (selectionList[0].type == "pseudoGroup") {
                    isMultipleSelection = true;
                    obj = this._findNodeUnderMouse(evt);
                }
                else {

                    obj = this._findNodeUnderMouse(evt);
                }
                var obj1 = this._findNodeUnderMouse(evt, true);
                var tempVal = this.selectedObject;
                var args = this._raiseEvent("itemClick", { element: this.selectedObject, actualObject: this.actualObject, selectedObject: obj1, cancel: false });
                this._itemClick(this.selectedObject, this.actualObject, obj1);
                if (args.cancel)
                    this.selectedObject = tempVal;
                if (this.actualObject) {
                    if (this.actualObject.parent) {
                        if (isMultipleSelection) {

                            var mulSelection = selectionList[0];
                            var temp = this._getProcessedObject(this.actualObject.name);
                            if (temp) {
                                if (this.selectedObject) {
                                    mulSelection.children = this.diagram._getChildren(mulSelection.children);
                                    ej.datavisualization.Diagram.Util.removeItem(mulSelection.children, this.selectedObject.name);
                                }
                                else if (temp.remove) {
                                    mulSelection.children = this.diagram._getChildren(mulSelection.children);
                                    ej.datavisualization.Diagram.Util.removeItem(mulSelection.children, temp.remove.name);
                                }


                                if (this.selectedObject) {
                                    if (!this._hasMultipleSelection(this.selectedObject)) {
                                        mulSelection.children.push(this.selectedObject.name);
                                    }
                                } else if (temp.add) {
                                    if (!this._hasMultipleSelection(temp.add)) {
                                        mulSelection.children.push(temp.add.name);
                                    }
                                }
                            } else {
                                nObj = this.actualObject;
                                if (this.selectedObject) {
                                    if (!this._hasMultipleSelection(this.selectedObject))
                                        mulSelection.children.push(this.selectedObject.name);
                                    else {
                                        mulSelection.children = this.diagram._getChildren(mulSelection.children);
                                        ej.datavisualization.Diagram.Util.removeItem(mulSelection.children, this.selectedObject.name);
                                    }
                                } else {
                                    if (!this._hasMultipleSelection(nObj))
                                        mulSelection.children.push(nObj.name);
                                    else {
                                        mulSelection.children = this.diagram._getChildren(mulSelection.children);
                                        ej.datavisualization.Diagram.Util.removeItem(mulSelection.children, nObj.name);
                                    }
                                }
                            }
                            ej.datavisualization.Diagram.Util._updateGroupBounds(mulSelection, this.diagram);
                            if (mulSelection.children.length <= 1) {
                                var child = this.diagram.nameTable[this.diagram._getChild(mulSelection.children[0])];
                                if (this.diagram._hasSelection()) {
                                    this.diagram._clearSelection();
                                }
                                this.selectedObject = child;
                                this.diagram._addSelection(this.selectedObject);
                            } else {
                                this.selectedObject = selectionList[0];
                                ej.datavisualization.Diagram.SvgContext.updateSelector(this.selectedObject, this.diagram._svg, this.diagram._currZoom, this.diagram, this.diagram.model.selectedItems.constraints);
                            }

                        } else {
                            if (this.diagram.selectionList[0].type == "group") {
                                selectionList = this.diagram.selectionList[0];
                                temp = this._getProcessedObject(this.actualObject.name);
                                nObj = temp.add;
                                if (temp) {
                                    if (this.diagram._hasSelection()) {
                                        this.diagram._clearSelection();
                                    }
                                }

                            } else {
                                temp = null;
                                if (obj.type == "group") {
                                    temp = this._getProcessedObject(this.actualObject.name);
                                }
                                if (temp)
                                    nObj = temp.add;
                                else
                                    nObj = obj;
                                selectionList = this.diagram.selectionList[0];
                                if (this.diagram._hasSelection()) {
                                    this.diagram._clearSelection();
                                }
                                pseudoGroup = ej.datavisualization.Diagram.Group({ type: "pseudoGroup", "name": "multipleSelection" });
                                if (selectionList.name != nObj.name)
                                    pseudoGroup.children.push(selectionList.name);
                                if (this.selectedObject)
                                    pseudoGroup.children.push(this.selectedObject.name);
                                else
                                    if (this._containsChild(pseudoGroup, nObj.name))
                                        pseudoGroup.children.push(nObj.name);

                                this._checkRepeatedChild(pseudoGroup.children);

                                this.diagram.nodes().push(pseudoGroup);
                                this.diagram.nameTable[pseudoGroup.name] = pseudoGroup;
                                ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, this.diagram);
                                this.selectedObject = pseudoGroup;
                                this.diagram._addSelection(this.selectedObject);
                            }
                        }
                    }
                    else {
                        if (isMultipleSelection) {
                            mulSelection = selectionList[0];
                            nObj = this.actualObject;
                            if (this.selectedObject) {
                                if (!this._hasMultipleSelection(this.selectedObject))
                                    mulSelection.children.push(this.selectedObject.name);
                                else {
                                    mulSelection.children = this.diagram._getChildren(mulSelection.children);
                                    ej.datavisualization.Diagram.Util.removeItem(mulSelection.children, this.selectedObject.name);
                                }
                            } else {
                                if (!this._hasMultipleSelection(nObj))
                                    mulSelection.children.push(nObj.name);
                                else {
                                    mulSelection.children = this.diagram._getChildren(mulSelection.children);
                                    ej.datavisualization.Diagram.Util.removeItem(mulSelection.children, nObj.name);
                                }
                            }
                            ej.datavisualization.Diagram.Util._updateGroupBounds(mulSelection, this.diagram);
                            this.selectedObject = selectionList[0];
                            ej.datavisualization.Diagram.SvgContext.updateSelector(this.selectedObject, this.diagram._svg, this.diagram._currZoom, this.diagram, this.diagram.model.selectedItems.constraints);
                        }
                        else {
                            var nObj = this.actualObject;
                            selectionList = this.diagram.selectionList[0];
                            if (this.diagram._hasSelection()) {
                                this.diagram._clearSelection();
                            }
                            var pseudoGroup = ej.datavisualization.Diagram.Group({ type: "pseudoGroup", "name": "multipleSelection" });
                            pseudoGroup.children.push(selectionList.name);
                            if (this.selectedObject)
                                pseudoGroup.children.push(this.selectedObject.name);
                            else
                                pseudoGroup.children.push(nObj.name);
                            this.diagram.nodes().push(pseudoGroup);
                            this.diagram.nameTable[pseudoGroup.name] = pseudoGroup;
                            ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, this.diagram);
                            this.selectedObject = pseudoGroup;
                            this.diagram._addSelection(this.selectedObject);
                        }
                    }
                }

                this.selectedObject = this.diagram.selectionList[0];
            }
            else {
                obj = this._findNodeUnderMouse(evt);
                this.selectedObject = obj;
            }
            return obj;
        };

        ToolBase.prototype._checkRepeatedChild = function (list) {
            var child = null;
            var cloneList = $.extend(true, {}, list);
            cloneList = this.diagram._getChildren(cloneList);
            for (var i = 0; i < cloneList.length; i++) {
                child = this.diagram.nameTable[cloneList.children[i]];
                if (child.type == "group") {
                    for (var j = 0; j < cloneList.children.length; j++) {
                        if (!this._containsChild(child, cloneList.children[j])) {
                            list.children = this.diagram._getChildren(list.children);
                            ej.datavisualization.Diagram.Util.removeItem(list.children, cloneList.children[j]);
                        }
                    }
                }
            }
        };
        ToolBase.prototype._hasMultipleSelection = function (node) {
            var children = this.diagram._getChildren(this.diagram.selectionList[0].children);
            for (var i = 0; i < children.length; i++) {
                if (node.name == children[i])
                    return true;
            }
            return false;
        };

        ToolBase.prototype._getNextParent = function (node) {
            if (node.parent) {
                var parent = this.diagram.nameTable[node.parent];
                if (this._hasMultipleSelection(parent))
                    return node;
                else
                    return this._getNextParent(parent);
            }
            else
                return node;
        };
        ToolBase.prototype._hasMultipleSelection = function (node) {
            var children = this.diagram._getChildren(this.diagram.selectionList[0].children);
            for (var i = 0; i < children.length; i++) {
                if (node.name == children[i])
                    return true;
            }
            return false;
        };

        ToolBase.prototype._getNextParent = function (node) {
            if (node.parent) {
                var parent = this.diagram.nameTable[node.parent];
                if (this._hasMultipleSelection(parent))
                    return node;
                else
                    return this._getNextParent(parent);
            }
            else
                return node;
        };
        ToolBase.prototype._findObj = function (element, group) {
            var obj;
            var id = element.getAttribute("id");
            if (group) {
                obj = this.diagram._findChildren(group, id);
            }
            else {
                var type = element.getAttribute("class");
                if (type) {
                    if (type === "ej-d-node" || type === "ej-d-group") {
                        obj = this.diagram._findNode(id);
                    }
                    else if (type === "ej-d-connector") {
                        obj = this.diagram._findConnector(id);
                    }
                }
            }
            return obj;
        };
        ToolBase.prototype.mousedown = function (evt) {
            this.startPoint = this.mousePosition(evt);
            this.currentPoint = this.mousePosition(evt);
            this.previousPoint = this.startPoint;
        };

        ToolBase.prototype.mousemove = function (evt) {
            this.currentPoint = this.mousePosition(evt);
        };
        ToolBase.prototype.mouseup = function (evt) {
            this._endAction();
            if (this.singleAction) {
                this.diagram.activateTool("select");
            }
        };
        ToolBase.prototype.mousePosition = function (evt) {
            return this.diagram._mousePosition(evt);
        };
        ToolBase.prototype.updateCursor = function (cursor) {
            this.diagram._currentCursor = cursor;
            this.diagram._updateCursor();
        };
        ToolBase.prototype.nearestGridPoint = function (point) {
            var snapPt = ej.datavisualization.Diagram.Point();
            if (this.diagram.model.snap & ej.datavisualization.Diagram.Snap.Grid) {
                var magnification = this.diagram.model.magnification / 100;
                var hSpacing = this.diagram.model.grid.horizontalSpacing * magnification;
                var vSpacing = this.diagram.model.grid.verticalSpacing * magnification;
                var width = point.x % hSpacing;
                var height = point.y % vSpacing;
                if (width >= (hSpacing / 2)) {
                    snapPt.x = point.x + hSpacing - width;
                }
                else {
                    snapPt.x = point.x - width;
                }
                if (height >= (vSpacing / 2)) {
                    snapPt.y = point.y + vSpacing - height;
                }
                else {
                    snapPt.y = point.y - height;
                }
            }
            return snapPt;
        };
        ToolBase.prototype.snap = function (point) {
            var snapSettings = this.diagram.model.snapSettings;

            var zoomFactor = this.diagram._currZoom;
            if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToVerticalLines)
                point.x = ej.datavisualization.Diagram.SnapUtil._round(point.x, snapSettings.verticalGridLines.snapInterval, zoomFactor);
            if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToHorizontalLines)
                point.y = ej.datavisualization.Diagram.SnapUtil._round(point.y, snapSettings.horizontalGridLines.snapInterval, zoomFactor);
            return point;

        };
        ToolBase.prototype._endAction = function () {
            this.inAction = false;

            if (this.svgHelper) {
                var helper = this.helper;
                var search = this.diagram._spatialSearch;
                if (helper.type != "group") {
                    ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(search, search.quadTable[helper.name], helper);
                }
                else {
                    var length = this.helper.children.length - 1;
                    for (var i = length; i >= 0; i--) {
                        ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(search, search.quadTable[helper.children[i].name], helper.children[i]);
                    }
                }
            }
            if (this.helper) {
                if (this.svgHelper)
                    this.diagram._svg.removeChild(this.svgHelper, this.diagram._diagramLayer);
                if (this.helper.gradient) {
                    var defs = this.diagram._svg.getElementsByTagName("defs")[0];
                    defs.removeChild(this.diagram._svg.getElementById(this.helper.name + "_gradient"));
                }
            }
            if (this._previousPossibleConnection) {
                this._previousPossibleConnection = null;
                ej.datavisualization.Diagram.SvgContext._removePortHighlighter(this.diagram._svg, this.diagram._adornerLayer);
            }
            this._currentPossibleConnection = null;
            this._possibleConnectionPort = null;
            this.helper = null;
            this.svgHelper = null;
            this.selectedObject = null;
            this.startPoint = ej.datavisualization.Diagram.Point(0, 0);
            this.currentPoint = ej.datavisualization.Diagram.Point(0, 0);
            this.previousPoint = ej.datavisualization.Diagram.Point(0, 0);
        };
        ToolBase.prototype._isResizeCorner = function (type) {
            var isResizeCorner = false;
            switch (type) {
                case "n-resize":
                case "e-resize":
                case "w-resize":
                case "s-resize":
                case "ne-resize":
                case "nw-resize":
                case "se-resize":
                case "sw-resize":
                case "targetEndPoint":
                case "sourceEndPoint":
                    isResizeCorner = true;
                    break;
            }
            return isResizeCorner;
        };
        ToolBase.prototype._initHelper = function () {
            if (this.selectedObject) {
                this.helper = $.extend(true, {}, this.selectedObject);
                this._updateHelperName(this.helper);
            }
        };
        ToolBase.prototype._updateHelperName = function (helper, child) {
            if (child) {
                helper.name += "helper";
            }
            else
                helper.name = "helper";
            helper.opacity = 0.5;
            var labels = helper.labels;
            for (var i = 0, len = labels.length; i < len; ++i) {
                labels[i].name += "helper";
            }
            if (helper.ports) {
                var ports = helper.ports;
                for (i = 0, len = ports.length; i < len; ++i) {
                    ports[i].name += "helper";
                }
            }
            if (helper.type == "group") {
                var children = this.diagram._getChildren(helper.children);
                for (i = 0, len = children.length; i < len; i++) {
                    this._updateHelperName(children[i], true);
                }
            }
        };
        ToolBase.prototype._raiseEvent = function (type, args) {
            args.elementType = this.diagram._getElementType(args.element);
            this.diagram._trigger(type, args);
            return args;
        };
        ToolBase.prototype._findPort = function (pt, node) {
            var port = this.diagram._findPortAtPoint(pt, node);
            if (!port && node.type == "group") {
                var childPort;
                var children = this.diagram._getChildren(node.children);
                for (var j = 0; j < children.length; j++) {
                    var child = this.diagram.nameTable[children[j]];
                    if (child && !child.segments) {
                        childPort = this._findPort(pt, child);
                        if (childPort && child.type != "group") {
                            this._currentPossibleConnection = child;
                            port = childPort;
                        }
                        else if (childPort) {
                            return childPort;
                        }
                    }
                }
            }
            return port;
        };
        ToolBase.prototype._checkConnectionPossible = function (evt) {
            var port = null;
            var pt = ej.datavisualization.Diagram.Point(this.currentPoint.x, this.currentPoint.y);
            var node = this.diagram._findNodeUnderMouse(evt);
            if (node && !(node.segments)) {
                if (!(node.type == "pseudoGroup") && !node.isLane && !node.isSwimlane) {
                    this._showPorts(node);
                    this._currentPossibleConnection = node;
                    if (this._previousPossibleConnection == null || this._previousPossibleConnection.name !== this._currentPossibleConnection.name) {
                        this._previousPossibleConnection = this._currentPossibleConnection;
                    }
                }
                else {
                    this._currentPossibleConnection = null;
                    this._possibleConnectionPort = null;
                }
            }
            else if (this.diagram.activeTool instanceof ej.datavisualization.Diagram.LineTool) {
                this._showPorts();
                this._currentPossibleConnection = null;
                this._possibleConnectionPort = null;
            }
            else {

                var epoint = ej.datavisualization.Diagram.Point(0, 0);
                if (this._endPoint == "targetEndPoint") {
                    epoint.x = this.selectedObject.targetPoint.x - 25;
                    epoint.y = this.selectedObject.targetPoint.y - 25;
                }
                else if (this._endPoint == "sourceEndPoint") {

                    epoint.x = this.selectedObject.sourcePoint.x - 25;
                    epoint.y = this.selectedObject.sourcePoint.y - 25;
                }
                var bounds = ej.datavisualization.Diagram.Rectangle(epoint.x, epoint.y, 50, 50);
                var quads = ej.datavisualization.Diagram.SpatialUtil.findQuads(this.diagram._spatialSearch, bounds);
                for (var i = 0; i < quads.length; i++) {
                    var quad = quads[i];
                    if (quad.objects.length > 0) {
                        for (var j = 0; j < quad.objects.length; j++) {
                            var nd = quad.objects[j];
                            var nodebounds = ej.datavisualization.Diagram.Util.bounds(nd);
                            if (ej.datavisualization.Diagram.Geometry.intersectsRect(bounds, nodebounds)) {
                                if (!nd.segments) {
                                    this._showPort(nd);
                                }
                            }
                            else {
                                if (!nd.segments) {
                                    this._showPort(nd, true);
                                }
                            }
                        }
                    }
                }

                this._currentPossibleConnection = null;
                this._possibleConnectionPort = null;
            }
            if (this._currentPossibleConnection) {
                port = this._findPort(pt, this._currentPossibleConnection);
                if ((port && ej.datavisualization.Diagram.Util.canConnect(port, true)) || ej.datavisualization.Diagram.Util.canConnect(this._currentPossibleConnection)) {
                    ej.datavisualization.Diagram.SvgContext._drawPortHighlighter(port, this._currentPossibleConnection, this.diagram._svg, this.diagram._adornerLayer,
                        this.diagram._currZoom);
                }
                else {
                    ej.datavisualization.Diagram.SvgContext._removePortHighlighter(this.diagram._svg, this.diagram._adornerLayer);
                }
                this._possibleConnectionPort = port;
                if (port && ej.datavisualization.Diagram.Util.canConnect(port, true)) {
                    var connectionNode = this._currentPossibleConnection;
                    var point = ej.datavisualization.Diagram.Util._getPortPosition(this._possibleConnectionPort, ej.datavisualization.Diagram.Util.bounds(connectionNode, true));
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, connectionNode.rotateAngle, connectionNode.offsetX, connectionNode.offsetY);
                    point = ej.Matrix.transform(matrix, point);
                    this.currentPoint = point;
                }
            }
            else {
                if (this._previousPossibleConnection) {
                    this._previousPossibleConnection = null;
                    ej.datavisualization.Diagram.SvgContext._removePortHighlighter(this.diagram._svg, this.diagram._adornerLayer);
                    this._possibleConnectionPort = null;
                }
            }

        };
        ToolBase.prototype._showPorts = function (node) {
            if (node) {
                if (this._currentPossibleConnection && this._currentPossibleConnection.name !== node.name) {
                    this._showPort(this._currentPossibleConnection, true);
                }
                this._showPort(node);
            }
            else {
                if (this._currentPossibleConnection != null) {
                    this._showPort(this._currentPossibleConnection, true);
                }
            }
        };
        ToolBase.prototype._showPort = function (node, hide) {
            var ports;
            var port;
            var portShape;
            var i;
            var len;
            if (hide) {
                ports = node.ports;
                for (i = 0, len = ports.length; i < len; ++i) {
                    port = ports[i];
                    if (port.visibility & ej.datavisualization.Diagram.PortVisibility.Hover ||
                        (port.visibility & ej.datavisualization.Diagram.PortVisibility.Connect &&
                        (this.name == "endPoint" || this instanceof ej.datavisualization.Diagram.LineTool))) {
                        portShape = this.diagram._svg.getElementById(node.name + "_" + port.name);
                        if (portShape)
                            portShape.setAttribute("visibility", "hidden");
                    }
                }
            }
            else {
                ports = node.ports;
                for (i = 0, len = ports.length; i < len; ++i) {
                    port = ports[i];
                    if (port.visibility & ej.datavisualization.Diagram.PortVisibility.Hover ||
                        (port.visibility & ej.datavisualization.Diagram.PortVisibility.Connect &&
                        (this.name == "endPoint" && this.inAction || this instanceof ej.datavisualization.Diagram.LineTool))) {
                        portShape = this.diagram._svg.getElementById(node.name + "_" + port.name);
                        if (portShape)
                            portShape.setAttribute("visibility", "visible");
                    }
                }
            }
        };
        ToolBase.prototype._showAllPorts = function (hide) {
            var i;
            var len;
            var nodes = this.diagram.nodes();
            if (hide) {
                for (i = 0, len = nodes.length; i < len; i++) {
                    this._showPort(nodes[i], hide);
                }
            }
            else {
                for (i = 0, len = nodes.length; i < len; ++i) {
                    this._showPort(nodes[i]);
                }
            }
        };
        ToolBase.prototype._disconnect = function (connector) {
            var args;
            var node = this.diagram.nameTable[connector.targetNode];
            var port = null;
            if (node) {
                port = ej.datavisualization.Diagram.Util.findPortByName(node, connector.targetPort);
                args = this._raiseEvent("connectionChange", { element: connector, connection: node, port: port, cancel: false });
                if (!args.cancel) {
                    ej.datavisualization.Diagram.Util.removeItem(node.inEdges, connector.name);
                    connector.targetNode = null;
                    connector.targetPort = null;
                }
            }
            node = this.diagram.nameTable[connector.sourceNode];
            if (node) {
                port = ej.datavisualization.Diagram.Util.findPortByName(node, connector.sourcePort);
                args = this._raiseEvent("connectionChange", { element: connector, connection: node, port: port, cancel: false });
                if (!args.cancel) {
                    ej.datavisualization.Diagram.Util.removeItem(node.outEdges, connector.name);
                    connector.sourceNode = null;
                    connector.sourcePort = null;
                }
            }
        };
        return ToolBase;
    })();

    ej.datavisualization.Diagram.ToolBase = ToolBase;
    //#endregion

    //#region SelectTool
    var SelectTool = (function (base) {
        ej.datavisualization.Diagram.extend(SelectTool, base);
        function SelectTool(diagram) {
            base.call(this, "select", diagram);
            this.cursor = "default";
            this._svgHelper = null;
        }
        SelectTool.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            var node = this._findNodeUnderMouse(evt);
            if (node) {
                this.selectedObject = node;
            }
        };
        SelectTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            if (!ej.datavisualization.Diagram.Geometry.isEmptyPoint(this.startPoint)) {
                if (ej.datavisualization.Diagram.Util.canDoMultipleSelection(this.diagram)) {
                    if (!this.inAction && (this.startPoint.x != this.currentPoint.x || this.startPoint.y != this.currentPoint.y)) {
                        this.inAction = true;
                        this._initHelper();
                    }
                    else
                        this._updateHelper();
                }
            }
        };
        SelectTool.prototype.mouseup = function (evt) {
            if (this.inAction) {
                this.currentPoint = this.mousePosition(evt);
                var rect = ej.datavisualization.Diagram.Geometry.rect([{ x: this.startPoint.x, y: this.startPoint.y }, { x: this.currentPoint.x, y: this.currentPoint.y }]);
                if (rect.width !== 0 || rect.height !== 0) {
                    var i;
                    var len;
                    var bounds;
                    var collection = [];
                    var nodes = this.diagram.nodes();
                    for (i = 0, len = nodes.length; i < len; i++) {
                        var node = this.diagram.nameTable[nodes[i].name];
                        if (node) {
                            bounds = ej.datavisualization.Diagram.Util.bounds(node);
                            bounds = ej.datavisualization.Diagram.Geometry.rect([bounds.topLeft, bounds.topRight, bounds.bottomRight, bounds.bottomLeft]);
                            if (ej.datavisualization.Diagram.Util.canSelect(node)) {
                                if (ej.datavisualization.Diagram.Geometry.containsRect(rect, bounds)) {
                                    if (node.parent === "")
                                        collection.push(node);
                                }
                                else if (node.type == "group") {
                                    this._checkGroupChildren(collection, node, rect);
                                }
                            }
                        }
                    }
                    var connectors = this.diagram.connectors();
                    for (i = 0, len = connectors.length; i < len; i++) {
                        var connector = this.diagram.nameTable[connectors[i].name];
                        if (connector) {
                            bounds = ej.datavisualization.Diagram.Util.bounds(connector);
                            bounds = ej.datavisualization.Diagram.Geometry.rect([bounds.topLeft, bounds.topRight, bounds.bottomRight, bounds.bottomLeft]);
                            if (ej.datavisualization.Diagram.Util.canSelect(connector) && ej.datavisualization.Diagram.Geometry.containsRect(rect, bounds)) {
                                if (connector.parent === "")
                                    collection.push(connector);
                            }
                        }
                    }
                    if (this.diagram._hasSelection()) {
                        collection = this.diagram._getChildren(collection);
                        ej.datavisualization.Diagram.Util.removeItem(collection, "multipleSelection");
                        this.diagram._clearSelection();
                    }
                    if (collection.length > 0) {
                        var children = collection;
                        var selection;
                        if (children.length > 1) {
                            var pseudoGroup = ej.datavisualization.Diagram.Group({ type: "pseudoGroup", "name": "multipleSelection" });
                            for (i = 0, len = children.length; i < len; i++) {
                                //children[i].parent = "multipleSelection";
                                pseudoGroup.children.push(this.diagram._getChild(children[i]));
                            }
                            this.diagram.nodes().push(pseudoGroup);
                            this.diagram.nameTable[pseudoGroup.name] = pseudoGroup;
                            selection = pseudoGroup;
                        }
                        else {
                            if (ej.datavisualization.Diagram.Util.canDoSingleSelection(this.diagram))
                                selection = collection[0];
                        }
                        if (selection) {
                            if (selection.type == "group" || selection.type == "pseudoGroup")
                                ej.datavisualization.Diagram.Util._updateGroupBounds(selection, this.diagram);
                            this.diagram._addSelection(selection);
                        }
                    }
                }
                else {
                    if (this.diagram._hasSelection() && !this.diagram._isDropped) {
                        this.diagram._clearSelection();
                    }
                }
            }
            else {
                if (evt.which != 3) {
                    if (this.selectedObject || this.diagram._hasSelection()) {
                        if (evt.ctrlKey || evt.shiftKey) {
                            if (!ej.datavisualization.Diagram.Util.canDoMultipleSelection(this.diagram)) {
                                this._processCtrlKey(evt);
                            }
                        }
                        else if (this.diagram._hasSelection())
                            this.diagram._clearSelection();
                        this.diagram._addSelection(this.selectedObject);
                    }
                    else if (this.diagram._hasSelection() && !this.diagram._isDropped) {
                        this.diagram._clearSelection();
                    }
                }
            }
            this.diagram._isDropped = false;
            if (this.selectedObject)
                this._raiseEvent("click", { element: this.selectedObject });
            base.prototype.mouseup.call(this, evt);

        };
        SelectTool.prototype._endAction = function () {
            if (this._svgHelper) {
                this.diagram._adornerLayer.removeChild(this._svgHelper);
                this.selectedObject = null;
                this._svgHelper = null;
            }
            base.prototype._endAction.apply(this);
        };
        SelectTool.prototype._initHelper = function () {
            if (!this._svgHelper) {
                var g = this.diagram._svg.g();
                this.diagram._adornerLayer.appendChild(g);

                var scale = this.diagram._currZoom;
                var selectionRect = this.diagram._svg.rect({
                    "id": "helper", "x": this.startPoint.x * scale, "y": this.startPoint.y * scale,
                    "fill": "transparent", "stroke": "gray", "stroke-dasharray": "2 2", "shape-rendering": "crispEdges"
                });
                g.appendChild(selectionRect);
                g.setAttribute("pointer-events", "none");
                this._svgHelper = g;
            }
        };
        SelectTool.prototype._updateHelper = function () {
            var helper = this.diagram._svg.getElementById("helper");
            var width = Math.abs(this.startPoint.x - this.currentPoint.x);
            var height = Math.abs(this.startPoint.y - this.currentPoint.y);
            var scale = this.diagram._currZoom;
            var x = ((this.startPoint.x > this.currentPoint.x) ? this.currentPoint.x : this.startPoint.x) * scale;
            var y = ((this.startPoint.y > this.currentPoint.y) ? this.currentPoint.y : this.startPoint.y) * scale;

            if (helper) {
                this.diagram._svg.rect({
                    "id": helper.id, "x": x,
                    "y": y, "width": width * scale, "height": height * scale
                });
            }
        };
        SelectTool.prototype._checkGroupChildren = function (collection, group, bounds) {
            var child, childBounds;
            var children = this.diagram._getChildren(group.children);
            for (var i = 0; i < children.length; i++) {
                child = this.diagram.nameTable[children[i]];
                if (child) {
                    childBounds = ej.datavisualization.Diagram.Util.bounds(child);
                    if (ej.datavisualization.Diagram.Geometry.containsRect(bounds, childBounds)) {
                        collection.push(child);
                    }
                    else if (child.type == "group") {
                        this._checkGroupChildren(collection, child, bounds);
                    }
                }
            }
        }
        return SelectTool;
    })(ToolBase);

    ej.datavisualization.Diagram.SelectTool = SelectTool;
    //#endregion

    //#region MoveTool
    var MoveTool = (function (base) {
        ej.datavisualization.Diagram.extend(MoveTool, base);
        function MoveTool(diagram) {
            base.call(this, "move", diagram);
            this.cursor = "move";
            this._isMouseDown = false;
            this.diffx = 0;
            this.diffy = 0;
            this.helper = null;
            this.hoverNode = null;
            this.stackOverNode = null;
            this.undoObject = [];
            this.activeLabel = null;
        }
        MoveTool.prototype.mousedown = function (evt) {
            ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
            this.diffx = 0;
            this.diffy = 0;
            this._allowPan(this.selectedObject, "mousedown", evt);
            base.prototype.mousedown.call(this, evt);
            this._isMouseDown = true;
            if (this.diagram._currentCursor != "pointer")
                this.updateCursor(this.cursor);
            this._findLabelUnderMouse(evt);
        };

        MoveTool.prototype._containsChild = function (node, childName) {
            var status = true;
            var child = null;
            var children = this.diagram._getChildren(node.children);
            for (var i = 0; i < children.length; i++) {
                child = this.diagram.nameTable[children[i]];
                if (child) {
                    if (child.type == "group")
                        status = this._containsChild(child, childName);
                    else {
                        if (child.name == childName)
                            status = false;
                    }
                }
            }
            return status;
        };
        MoveTool.prototype._nodeCanHighlight = function (hoverNode) {
            var status = false;
            if ((this.diagram._getChildren(hoverNode.children)).indexOf(this.selectedObject.name) == -1) {
                if (this.selectedObject.type != "group") {
                    status = true;
                }
                else {
                    if (hoverNode.type == "group") {
                        if (!this._containsChild(this.selectedObject, hoverNode.name))
                            status = true;
                    }
                }
            }
            return status;
        },

        MoveTool.prototype._containerMouseMove = function (evt) {
            //#region for Container
            if (this.selectedObject.parent && this.diagram.nameTable[this.selectedObject.parent] && this.diagram.nameTable[this.selectedObject.parent].container) {
                var container = this.diagram.nameTable[this.selectedObject.parent].container;
                //ej.datavisualization.Diagram.SvgContext._hideNode(this.selectedObject, this.diagram._svg);
                if (!this.helper) {
                    ej.datavisualization.Diagram.SvgContext._disableSelectedNode(this.selectedObject, this.diagram._svg, this.diagram);
                    this.helper = this._getCloneNode(this.selectedObject);
                    this.helper.name = "helper";
                    this.startPoint = this.currentPoint;
                    var bounds = ej.datavisualization.Diagram.Util.bounds(this.helper);
                    ej.datavisualization.Diagram.SvgContext._drawContainerHelper(this.diagram);
                } else {
                    this._updateHelperXY(this.helper, this.previousPoint, this.currentPoint);
                    ej.datavisualization.Diagram.SvgContext._updateContainerHelper(this.diagram);
                }
                if (container.type == "canvas") {
                    var overNode = this._getNodeUnderMouse(evt);
                    if (overNode && !overNode.segments && overNode.type == "group") {
                        if (overNode.container && overNode.container.type != "stack") {
                            this._nodeHighLighter(overNode);
                        }
                        this.hoverNode = overNode;
                    } else {
                        this._removeHighLighter();
                        this.hoverNode = null;
                    }
                } else if (container.type == "stack") {
                    var stackOverNode = this._findStackOverNode(this.helper, evt);
                    if (stackOverNode) {
                        this._nodeHighLighter(stackOverNode);
                        this.stackOverNode = stackOverNode;
                    } else {
                        this._removeHighLighter();
                        this.stackOverNode = null;
                    }
                }
            } else {
                if (!this.selectedObject.isSwimlane) {
                    if (this.selectedObject.type == "pseudoGroup" && this.hasSameParent()) {
                        if (!this.helper) {
                            this.helper = this._getCloneNode(this.selectedObject);
                            this.helper.name = "helper";
                            this.helper.children = [];
                            this.startPoint = this.currentPoint;
                            ej.datavisualization.Diagram.SvgContext._drawContainerHelper(this.diagram);
                        } else {
                            bounds = ej.datavisualization.Diagram.Util.bounds(this.helper);
                            this._updateHelperXY(this.helper, this.previousPoint, this.currentPoint);

                            ej.datavisualization.Diagram.SvgContext._updateContainerHelper(this.diagram);
                        }
                        ej.datavisualization.Diagram.SvgContext._disableSelectedNode(this.selectedObject, this.diagram._svg, this.diagram);
                        overNode = this._getNodeUnderMouse(evt);

                        var gHighLight = true;
                        if (overNode && !overNode.segments) {
                            if (overNode.container && overNode.container.type != "stack") {
                                this._nodeHighLighter(overNode);
                            }
                            this.hoverNode = overNode;
                        } else {
                            this._removeHighLighter();
                            this.hoverNode = null;
                        }
                        this._nodeHighLighter(overNode);
                    }
                    else if (!this.isDiagram(evt) && !this.selectedObject.segments) {
                        overNode = this._getNodeUnderMouse(evt);
                        ej.datavisualization.Diagram.SvgContext._disableSelectedNode(this.selectedObject, this.diagram._svg, this.diagram);
                        if (overNode && overNode.container && (this.selectedObject.isSwimlane || this.selectedObject.isLane)) {
                            if (this._getSwimLaneNode(overNode, this.selectedObject))
                                this._nodeHighLighter(overNode);
                        }
                        else if (overNode && overNode.container && overNode.container.type != "stack") {
                            if (this.selectedObject.name != overNode.name && this.selectedObject.type != "pseudoGroup")
                                this._nodeHighLighter(overNode);
                        }
                        this.hoverNode = overNode;
                        if (this.hoverNode && (this.selectedObject.type == "pseudoGroup" || this.selectedObject.name == "multipleSelection")) {
                            if (this._fromDiagram(this.selectedObject.children)) {
                                this._nodeHighLighter(this.hoverNode);
                            }
                        }

                    }
                    else
                        this._removeHighLighter();
                }
                if (!gHighLight) {
                    if (this.selectedObject.type == "pseudoGroup") {
                        if (this._fromDiagram(this.diagram._getChildren(this.selectedObject.children)))
                            this._updateXY(this.selectedObject, this.previousPoint, this.currentPoint);
                        else if (this._fromSameContainer(this.diagram._getChildren(this.selectedObject.children)) && this.hasSameParent()) {
                            this._updateXY(this.selectedObject, this.previousPoint, this.currentPoint);
                        }
                    }
                    else this._updateXY(this.selectedObject, this.previousPoint, this.currentPoint);
                }
            }
            //#endregion  
        },


        MoveTool.prototype.mousemove = function (evt) {
            this._allowPan(this.selectedObject, "mousemove", evt);
            base.prototype.mousemove.call(this, evt);
            ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
            if (this._isMouseDown && !this.inAction) {//&& (this.startPoint.x != this.currentPoint.x || this.startPoint.y != this.currentPoint.y)) {
                if (!this.selectedObject) {
                    var selectedObject;
                    selectedObject = this._findNodeUnderMouse(evt, true);

                    if (this.diagram._selectedSymbol) {
                        selectedObject = this.diagram.selectionList[0];
                    }

                    if (selectedObject) {
                        if (!ej.datavisualization.Diagram.Util.canMoveLabel(selectedObject))
                            this.activeLabel = null;
                        if (this.diagram.selectionList[0] && this.diagram.selectionList[0].type == "pseudoGroup") {
                            if (this.activeLabel) {
                                this.selectedObject = selectedObject;
                                this.diagram._clearSelection();
                            }
                            else
                                this.selectedObject = this.diagram.selectionList[0];
                            var tempVal = this.selectedObject;
                            var args = this._raiseEvent("itemClick", { actualObject: this.actualObject, selectedObject: this.selectedObject, model: this.diagram.model, cancel: false });
                            this._itemClick(this.selectedObject, this.actualObject, this.diagram.model);
                            if (args.cancel)
                                this.selectedObject = tempVal;
                            if (this.diagram.selectionList[0] != this.selectedObject)
                                this.diagram._clearSelection();

                        } else {
                            if (this.diagram.selectionList[0] != selectedObject) {
                                this.diagram._clearSelection();
                                this.selectedObject = this.diagram.nameTable[selectedObject.name];
                            } else {
                                this.selectedObject = this.diagram.nameTable[this.diagram.selectionList[0].name];
                            }
                            var tempVal = this.selectedObject;
                            var args = this._raiseEvent("itemClick", { actualObject: this.actualObject, selectedObject: this.selectedObject, model: this.diagram.model, cancel: false });
                            this._itemClick(this.selectedObject, this.actualObject, this.diagram.model);
                            if (args.cancel)
                                this.selectedObject = tempVal;
                            if (this.diagram.selectionList[0] != this.selectedObject)
                                this.diagram._clearSelection();
                        }
                        var data;
                        var childTable = {};
                        if (this.selectedObject.type == "group" || this.selectedObject.type == "pseudoGroup")
                            childTable = this.diagram._getChildTable(this.selectedObject, childTable);
                        var temp = { "childTable": childTable, "node": this.selectedObject };
                        data = $.extend(true, {}, temp);
                        this.undoObject = jQuery.extend(true, {}, data);
                    }
                }
            }

            if (this.selectedObject && ej.datavisualization.Diagram.Util.canSelect(this.selectedObject)) {
                if (!this.inAction) {
                    //ej.datavisualization.Diagram.SvgContext._removePivotPoint(this.selectedObject, this.diagram._svg, this.diagram.model.zoomFactor);
                    this.inAction = true;
                    if (!this.activeLabel)
                        this.updateCursor("move");
                    this._updateSelection();
                }
                if (this.activeLabel)
                    this._updateLabelXY(this.activeLabel, this.previousPoint, this.currentPoint);
                else {
                    if (this.diagram && !this.diagram._isEditing) {
                        this._containerMouseMove(evt);
                    }

                    if (this.selectedObject.segments) {
                        var connector = this.selectedObject;
                        if (ej.datavisualization.Diagram.Util.isTargetConnected(connector) || ej.datavisualization.Diagram.Util.isSourceConnected(connector)) {
                            this._disconnect(connector);
                        }
                    }
                    if (this.selectedObject.type == "pseudoGroup") {
                        var child;
                        var children = this.diagram._getChildren(this.selectedObject.children);
                        for (var i = 0, len = children.length; i < len; i++) {
                            child = this.diagram.nameTable[children[i]];
                            ej.datavisualization.Diagram.DiagramContext.update(child, this.diagram);
                        }
                    }
                    else {
                        if (this.selectedObject.parent) {
                            ej.datavisualization.Diagram.Util._updateGroupBounds(this.diagram.nameTable[this.selectedObject.parent], this.diagram);
                        }
                        ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                    }

                    this.diagram._renderTooltip(this.selectedObject);
                    this._updateSelection();
                    this.diagram._updateSelectionHandle(true);
                }
            }
            this.previousPoint = this.currentPoint;
        };
        MoveTool.prototype._findStackOverNode = function (node, evt) {
            var parent = this.diagram.nameTable[node.parent];
            var child = null, pos, childBounds;
            if (parent) {
                var children = this.diagram._getChildren(parent.children);
                var length = children.length;
                for (var i = 0; i < length; i++) {
                    child = this.diagram.nameTable[children[i]];
                    pos = this.mousePosition(evt);
                    childBounds = ej.datavisualization.Diagram.Util.bounds(child);
                    if (parent.container.orientation == "vertical") {
                        var lastChild = this.diagram.nameTable[children[length - 1]];
                        var firstChild = this.diagram.nameTable[children[0]];
                        if (pos.y >= childBounds.y && pos.y <= childBounds.bottom) {
                            return child;
                        }
                        else if (pos.y <= firstChild.offsetY - firstChild.height / 2) {
                            return firstChild;
                        }
                        else if (pos.y >= lastChild.offsetY + lastChild.height / 2) {
                            return lastChild;
                        }

                    } else {
                        lastChild = this.diagram.nameTable[children[length - 1]];
                        firstChild = this.diagram.nameTable[children[0]];
                        if (pos.x >= childBounds.x && pos.x <= childBounds.right) {
                            return child;
                        }
                        else if (pos.x <= firstChild.offsetX - firstChild.width / 2) {
                            return firstChild;
                        }
                        else if (pos.x >= lastChild.offsetX + lastChild.width / 2) {
                            return lastChild;
                        }
                    }
                }

            }
        };

        MoveTool.prototype._removeFromContainer = function (node) {

            if (node.type == "pseudoGroup") {
                var child = null;
                var children = this.diagram._getChildren(node.children);
                for (var i = 0; i < children.length; i++) {
                    child = this.diagram.nameTable[children[i]];
                    if (child) {
                        ej.datavisualization.Diagram.SvgContext._removeFromContainer(child, this.diagram._svg, this.diagram._adornerLayer);
                        //delete this.diagram.nameTable[child.name];
                    }
                }
            } else {
                //delete this.diagram.nameTable[node.name];
                ej.datavisualization.Diagram.SvgContext._removeFromContainer(node, this.diagram._svg, this.diagram._adornerLayer);
            }
        };

        MoveTool.prototype._updateContainerProperties = function (node) {
            if (node && node.type == "pseudoGroup") {
                var child = null;
                if (this.helper) {
                    var diffX = this.helper.offsetX - this.selectedObject.offsetX;
                    var diffY = this.helper.offsetY - this.selectedObject.offsetY;
                }
                else {
                    var diffX = 0;
                    var diffY = 0;
                }
                var children = this.diagram._getChildren(node.children);
                for (var i = 0; i < children.length; i++) {
                    child = this.diagram.nameTable[children[i]];
                    if (child && !child.isSwimlane) {
                        oldParent = this.diagram.nameTable[this.selectedObject.parent];
                        if (oldParent) {
                            oldParent.children = this.diagram._getChildren(oldParent.children);
                            if (oldParent && oldParent.children)
                                ej.datavisualization.Diagram.Util.removeItem(oldParent.children, this.selectedObject.name);
                        }

                        newObj = this.diagram.nameTable[child.name];
                        if (newObj) {
                            var oldPar = this.diagram.nameTable[newObj.parent];
                            if (oldPar) {
                                oldPar.children = this.diagram._getChildren(oldPar.children);
                                ej.datavisualization.Diagram.Util.removeItem(oldPar.children, newObj.name);
                            }
                            newObj.parent = this.hoverNode.name;
                            var newpar = this.diagram.nameTable[newObj.parent];
                            if (this._containsChild(newpar, newObj.name))
                                newpar.children.push(newObj.name);
                            this.diagram.updateNode(newObj.name, { offsetX: newObj.offsetX + diffX });
                            this.diagram.updateNode(newObj.name, { offsetY: newObj.offsetY + diffY });
                            this.diagram.nameTable[newObj.name] = newObj;
                        }
                    }
                }
                node.offsetX += diffX;
                node.offsetY += diffY;
                return node;
            }
            else {
                var oldParent = this.diagram.nameTable[this.selectedObject.parent];
                if (oldParent && oldParent.children) {
                    oldParent.children = this.diagram._getChildren(oldParent.children);
                    ej.datavisualization.Diagram.Util.removeItem(oldParent.children, this.selectedObject.name);
                }
                var newObj = this.selectedObject;//$.extend(true, {}, this.selectedObject);
                if (!this.hoverNode.isSwimlane)
                    newObj.parent = this.hoverNode.name;
                this.diagram.nameTable[newObj.name] = newObj;
                return newObj;
            }
        };

        MoveTool.prototype._updatePreviousContainer = function (node) {
            if (node.type == "group") {
                if (node.container.type == "canvas") {
                    var groupBounds = ej.datavisualization.Diagram.Util.bounds(node);
                    var newSize = this.diagram._getMinMaxSize(node, groupBounds.width, groupBounds.height);
                    node.width = newSize.width;
                    node.height = newSize.height;

                } else if (node.container.type == "stack") {

                }
            }
        };

        MoveTool.prototype._updateContainer = function (newObj, prevParent, isDrop) {
            var bounds, groupBounds, dx = 0, dy = 0, newSize;
            if (newObj) {
                var parObj = this.diagram.nameTable[newObj.parent];
                if (!parObj && newObj.type == "pseudoGroup") {
                    var fNode = this.diagram.nameTable[this.diagram._getChild(this.selectedObject.children[0])];
                    parObj = this.diagram.nameTable[fNode.parent];
                }
                if (parObj) {
                    if (parObj.container) {
                        if (parObj.container.type == "canvas") {
                            if (isDrop) {
                                var group = this.diagram.nameTable[newObj.parent];
                                if (!group && newObj.type == "pseudoGroup") {
                                    group = parObj;
                                }
                                var groupBounds123 = ej.datavisualization.Diagram.Util.bounds(group);

                                var grAngle = group.rotateAngle;
                                this.diagram._rotate(group, -group.rotateAngle, this.diagram.nameTable);
                                bounds = ej.datavisualization.Diagram.Util.bounds(newObj);
                                var bounds1 = ej.datavisualization.Diagram.Geometry.rect([bounds.topLeft, bounds.topRight, bounds.bottomRight, bounds.bottomLeft]);
                                groupBounds = ej.datavisualization.Diagram.Util.bounds(group);
                                var tightchildBounds = this.diagram._getTightChildrenBounds(group);
                                var right = true;
                                var bottom = true;
                                var bRight = bounds1.x + bounds1.width;
                                var bBottom = bounds1.y + bounds1.height;
                                if (bRight >= groupBounds.right) {
                                    ///if exeeds right 
                                    dx = bRight - groupBounds.right + group.paddingRight;
                                    newSize = this.diagram._getMinMaxSize(group, (group.width + dx), group.height, true);
                                    widDiff = newSize.width - group.width;
                                    group.width = newSize.width;
                                    group.offsetX += (widDiff / 2);
                                    if (bRight < groupBounds.right) {
                                        right = false;
                                    }
                                }
                                if (bBottom >= groupBounds.bottom) {
                                    ///if exeeds bottom 
                                    dy = bBottom - groupBounds.bottom + group.paddingBottom;
                                    newSize = this.diagram._getMinMaxSize(group, (group.width), (group.height + dy), true);
                                    heiDiff = newSize.height - group.height;
                                    group.height = newSize.height;
                                    group.offsetY += (heiDiff / 2);
                                    //group.offsetY += (dy / 2);
                                    //group.height += dy;
                                    bottom = true;
                                    if (bBottom < groupBounds.bottom) {
                                        bottom = false;
                                    }
                                }
                                if (bRight < groupBounds.right && right) { //if decreces from right
                                    dx = (tightchildBounds.x + tightchildBounds.width) + group.paddingRight - groupBounds.right;
                                    newSize = this.diagram._getMinMaxSize(group, (group.width + dx), group.height, true);
                                    var widDiff = newSize.width - group.width;
                                    group.width = newSize.width;
                                    group.offsetX += (widDiff / 2);
                                }
                                if (bBottom < groupBounds.bottom && bottom) { //if decreces from bottom
                                    dy = (tightchildBounds.y + tightchildBounds.height) + group.paddingBottom - groupBounds.bottom;
                                    newSize = this.diagram._getMinMaxSize(group, (group.width), (group.height + dy), true);
                                    var heiDiff = newSize.height - group.height;
                                    group.height = newSize.height;
                                    group.offsetY += (heiDiff / 2);
                                }

                                this._updateMargin(newObj, group);
                                ej.datavisualization.Diagram.SvgContext._alignOnCanvas1(group, this.diagram);
                                this.diagram._rotate(group, grAngle, this.diagram.nameTable);
                                var groupBounds1231 = ej.datavisualization.Diagram.Util.bounds(group);
                                this.diagram._translate(group, groupBounds123.topLeft.x - groupBounds1231.topLeft.x, groupBounds123.topLeft.y - groupBounds1231.topLeft.y, this.diagram.nameTable);
                                if (group.parent && group.container && group.container.type == "canvas")
                                    this._updateMargin(group, this.diagram.nameTable[group.parent]);

                                ej.datavisualization.Diagram.DiagramContext.update(group, this.diagram);

                            }
                            else {
                                var vertical = false;
                                var horizontal = false;
                                group = this.diagram.nameTable[newObj.parent];
                                groupBounds123 = ej.datavisualization.Diagram.Util.bounds(group);
                                grAngle = group.rotateAngle;
                                if (!((group.rotateAngle == 0) && (grAngle == 0)))
                                    this.diagram._rotate(group, -group.rotateAngle, this.diagram.nameTable);
                                if (group.container && group.container.type == "canvas") {
                                    this._updateMargin(newObj, group);
                                }
                                if (newObj.container.type == "stack") {
                                    if (newObj.container.orientation == "vertical")
                                        vertical = true;
                                    else
                                        horizontal = true;
                                }
                                bounds = this.diagram._getBoundsWithoutStretch(group, vertical, horizontal);// ej.datavisualization.Diagram.SvgContext._measureStackSize(group, this.diagram, true);
                                newSize = this.diagram._getMinMaxSize(group, (bounds.width), (bounds.height), true);
                                widDif = newSize.width - group.width;
                                heiDif = newSize.height - group.height;
                                group.offsetX += (widDif / 2);
                                group.width = newSize.width;
                                group.offsetY += (heiDif / 2);
                                group.height = newSize.height;
                                ej.datavisualization.Diagram.SvgContext._alignOnCanvas1(group, this.diagram);
                                if (!((group.rotateAngle == 0) && (grAngle == 0)))
                                    this.diagram._rotate(group, grAngle, this.diagram.nameTable);
                                groupBounds1231 = ej.datavisualization.Diagram.Util.bounds(group);
                                this.diagram._translate(group, groupBounds123.topLeft.x - groupBounds1231.topLeft.x, groupBounds123.topLeft.y - groupBounds1231.topLeft.y, this.diagram.nameTable);
                            }
                            if (newObj.parent) {
                                this._updateContainer(this.diagram.nameTable[newObj.parent]);
                                if (!this.diagram.nameTable[newObj.parent].parent)
                                    ej.datavisualization.Diagram.DiagramContext.update(this.diagram.nameTable[newObj.parent], this.diagram);
                            } else if (newObj.type == "pseudoGroup") {
                                fNode = this.diagram.nameTable[this.diagram._getChild(newObj.children[0])];
                                var parObj2 = this.diagram.nameTable[fNode.parent];
                                if (parObj2.parent) {
                                    this._updateContainer(this.diagram.nameTable[parObj2.name]);
                                    if (!this.diagram.nameTable[parObj2.name])
                                        ej.datavisualization.Diagram.DiagramContext.update(this.diagram.nameTable[parObj2.name], this.diagram);
                                }
                            }

                        }//end canvas

                        else if (parObj.container.type == "stack") {
                            group = this.diagram.nameTable[newObj.parent];
                            bounds = ej.datavisualization.Diagram.SvgContext._measureStackSize(group, this.diagram, true);
                            groupBounds123 = ej.datavisualization.Diagram.Util.bounds(group);
                            grAngle = group.rotateAngle;
                            if (!((group.rotateAngle == 0) && (grAngle == 0)))
                                this.diagram._rotate(group, -group.rotateAngle, this.diagram.nameTable);
                            newSize = this.diagram._getMinMaxSize(group, (bounds.width), (bounds.height), true);
                            var widDif = newSize.width - group.width;
                            var heiDif = newSize.height - group.height;

                            group.offsetX += (widDif / 2);
                            group.width = newSize.width;
                            group.offsetY += (heiDif / 2);
                            group.height = newSize.height;


                            ej.datavisualization.Diagram.SvgContext._alignOnStack(group, this.diagram);
                            if (!((group.rotateAngle == 0) && (grAngle == 0)))
                                this.diagram._rotate(group, grAngle, this.diagram.nameTable);
                            groupBounds1231 = ej.datavisualization.Diagram.Util.bounds(group);
                            this.diagram._translate(group, groupBounds123.topLeft.x - groupBounds1231.topLeft.x, groupBounds123.topLeft.y - groupBounds1231.topLeft.y, this.diagram.nameTable);
                            if (group.parent)
                                this._updateContainer(group);
                            ej.datavisualization.Diagram.DiagramContext.update(group, this.diagram);
                        }
                    }
                }
            }
        };

        MoveTool.prototype._addToContainer = function (node) {
            if (node.type == "pseudoGroup") {
                var child = null;
                var children = this.diagram._getChildren(node.children);
                for (var i = 0; i < children.length; i++) {
                    child = this.diagram.nameTable[children[i]];
                    if (child) {
                        parent = this.diagram._svg.getElementById(child.parent);
                        if (!parent)
                            parent = this.diagram._diagramLayer;
                        if (child.type == "group") {
                            ej.datavisualization.Diagram.SvgContext.renderGroup(child, this.diagram._svg, parent, this.diagram.nameTable, this.diagram);
                        } else if (child.segments) {
                            ej.datavisualization.Diagram.SvgContext.renderConnector(child, this.diagram._svg, parent);
                        } else {
                            ej.datavisualization.Diagram.SvgContext.renderNode(child, this.diagram._svg, parent);
                        }
                    }
                }
            } else {
                this.diagram._clearSelection();
                var parent;
                if (this.hoverNode && this.hoverNode.children && (!this.hoverNode.isSwimlane)) {
                    this.hoverNode.children.push(node.name);
                    //this.diagram.nameTable[node.name] = node;
                }
                if (node) {
                    parent = this.diagram._svg.getElementById(node.parent);
                    if (!parent)
                        parent = this.diagram._diagramLayer;
                    if (node.type == "group") {
                        ej.datavisualization.Diagram.SvgContext.renderGroup(node, this.diagram._svg, parent, this.diagram.nameTable, this.diagram);
                    } else if (node.segments) {
                        ej.datavisualization.Diagram.SvgContext.renderConnector(node, this.diagram._svg, parent);
                    } else {
                        ej.datavisualization.Diagram.SvgContext.renderNode(node, this.diagram._svg, parent);
                    }
                }
            }
            this.selectedObject = node;
        };
        MoveTool.prototype._addToDiagram = function () {
            this.seletedObject = this.diagram.nameTable[this.selectedObject.name];
            this._removeFromContainer(this.selectedObject);
            var oldParent = this.diagram.nameTable[this.selectedObject.parent];
            if (oldParent) {
                oldParent.children = this.diagram._getChildren(oldParent.children);
                ej.datavisualization.Diagram.Util.removeItem(oldParent.children, this.selectedObject.name);
            }
            this.selectedObject.parent = "";
            this.diagram.nameTable[this.selectedObject.name] = this.selectedObject;
            this._updateXY(this.diagram.nameTable[this.selectedObject.name], this.startPoint, this.currentPoint);
            this._addToContainer(this.selectedObject);
        };
        MoveTool.prototype.isDiagram = function (evt) {
            if (evt.target.id == this.diagram._id + "_canvas_svg")
                return true;
            else
                return false;
        };
        MoveTool.prototype._allowPan = function (node, moveType, evt) {
            if (moveType === "mousedown")
                this.diagram.tools["panTool"].mousedown(evt);
            if (node && (node.type == "group" || node.shape) && (node.constraints & ej.datavisualization.Diagram.NodeConstraints.AllowPan)) {
                if (moveType === "mousemove")
                    this.diagram.tools["panTool"].mousemove(evt);
                else if (moveType === "mouseup")
                    this.diagram.tools["panTool"].mouseup(evt);
            }
        };
        MoveTool.prototype._checkForDropEvent = function (hoverNode) {
            var source = null, target = null, childBounds = null;
            if (this.selectedObject && this.selectedObject.parent)
                source = this.diagram.nameTable[this.selectedObject.parent];
            if (hoverNode) {
                childBounds = ej.datavisualization.Diagram.Util.bounds(hoverNode);
                target = this._getTargetNode(hoverNode, childBounds);
            }
            var args = this._raiseEvent("drop", { cancel: false, source: source, target: target });
            return args.cancel;
        };

        MoveTool.prototype._getSwimLaneNode = function (node, selNode) {
            if (node.isSwimlane) {
                if (this.diagram.nameTable[this.diagram._getChild(node.children[1])].container.orientation != selNode.orientation)
                    return node;
            }
            if (node.parent) {
                var parent = this.diagram.nameTable[node.parent];
                if (parent) {
                    return this._getSwimLaneNode(parent, selNode);
                }
            }
            return null;
        };
        MoveTool.prototype._cloneGroupNode = function (node, id) {
            var child = null, child1, clnObj, node1;
            node1 = $.extend(true, {}, node);
            node1.name += id;
            if (node.type == "group") {
                node1.children = [];
                var children = this.diagram._getChildren(node.children);
                for (var i = 0; i < children.length; i++) {
                    child = this.diagram.nameTable[children[i]];
                    child1 = $.extend(true, {}, child);
                    child1.name += id;
                    if (child1.parent)
                        child1.parent += id;
                    if (child1.type == "group")
                        this._cloneGroupNode(child1, id);
                    this.diagram.nameTable[child1.name] = child1;
                    this.diagram.nodes().push(child1);
                    node1.children.push(child1.name);
                }
            }
            return node1;
        };
        MoveTool.prototype._getSwimLaneStackIndex = function (node) {
            if (node.container.type == "canvas") {
                if (node.parent)
                    var parent = this.diagram.nameTable[node.parent];
                if (parent) {
                    return parent.children.indexOf(node.name);
                }
            } else {
                return null;
            }
        };
        MoveTool.prototype._changeNodeState = function (evt, doc) {
            var newObj, pNode, mergNode = null;
            //#region drop fropm palette
            if (this.diagram._selectedSymbol && this.diagram._selectedSymbol.isLane && !doc) {
                ej.datavisualization.Diagram.SvgContext._enableSelectedNode(this.selectedObject, this.diagram._svg, this.diagram);
                var btmNode = this._findNodeUnderMouse(evt);
                if (btmNode)
                    mergNode = this._getSwimLaneNode(btmNode, this.selectedObject);
                if (btmNode && mergNode) {
                    ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._svg, this.diagram._adornerLayer);
                    this._removeHighLighter();
                    var stack = this.diagram.nameTable[this.diagram._getChild(mergNode.children[1])];
                    if (stack) {
                        var id = ej.datavisualization.Diagram.Util.randomId();
                        var selctObject = this._cloneGroupNode(this.selectedObject, id);
                        this.diagram.remove(this.selectedObject);
                        if (this.hoverNode)
                            var index = this._getSwimLaneStackIndex(this.hoverNode);
                        if (index || index == 0) {
                            stack.children.splice(index, 0, selctObject.name);
                        }
                        else
                            stack.children.push(selctObject.name);
                        selctObject.parent = stack.name;
                        this.diagram.add(selctObject);
                        var stackParent = this.diagram.nameTable[stack.parent];
                        if (stackParent) {
                            this._updateContainer(selctObject);
                        }
                        ej.datavisualization.Diagram.DiagramContext.update(stackParent, this.diagram);
                        this.selectedObject = stackParent;
                    }
                }
                else {
                    //add new stack
                    var swimlane = ej.datavisualization.Diagram.SwimLaneHelper._createSwimlane(this.selectedObject, this.diagram);
                    if (swimlane) {
                        this.diagram.remove(this.selectedObject);
                        this.diagram.add(swimlane);
                        this.selectedObject = swimlane;
                    }
                }

            }//#endregion
                //#region for Container 
            else if (this.selectedObject && this.selectedObject.parent && this.diagram.nameTable[this.selectedObject.parent].container) {
                ej.datavisualization.Diagram.SvgContext._enableSelectedNode(this.selectedObject, this.diagram._svg, this.diagram);
                var container = this.diagram.nameTable[this.selectedObject.parent].container;
                if (container.type == "canvas") {
                    ej.datavisualization.Diagram.SvgContext._showNode(this.selectedObject, this.diagram._svg);
                    ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._svg, this.diagram._adornerLayer);
                    this._removeHighLighter(); //ej.datavisualization.Diagram.SvgContext._removeNodeHighlighter(this.diagram._svg, this.diagram._adornerLayer);
                    var checkDrop = !this._checkForDropEvent(this.hoverNode);
                    if (checkDrop) {
                        if (this.hoverNode && this.hoverNode.allowDrop || (this.hoverNode && this.hoverNode.name == this.selectedObject.parent)) {
                            if (this.hoverNode.container && this.hoverNode.container.type == "canvas") {
                                //var event = this._checkForDropEvent(evt);
                                //if (!event) {
                                this.seletedObject = this.diagram.nameTable[this.selectedObject.name];
                                pNode = this.selectedObject.parent;
                                this._removeFromContainer(this.selectedObject);
                                newObj = this._updateContainerProperties(this.diagram.nameTable[this.selectedObject.name]);
                                this._updateXY(this.diagram.nameTable[this.selectedObject.name], this.startPoint, this.currentPoint);
                                this._addToContainer(newObj);
                                //}
                            }
                        } else { //add to diagram
                            if (this.isDiagram(evt)) {
                                this._addToDiagram();
                            }
                            this.diffx = 0;
                            this.diffy = 0;
                        }
                    }
                } else if (container.type == "stack") {
                    ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._svg, this.diagram._adornerLayer);
                    this._removeHighLighter();
                }
            }
            else {///added from diagram to container
                ej.datavisualization.Diagram.SvgContext._enableSelectedNode(this.selectedObject, this.diagram._svg, this.diagram);
                if (this.selectedObject && !this.selectedObject.isSwimlane) {
                    if (this.selectedObject.type == "pseudoGroup" && this.hasSameParent()) {
                        this.currentPoint = this.previousPoint;
                        this.diffx = 0;
                        this.diffy = 0;
                        this._removeHighLighter();
                        ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._svg, this.diagram._adornerLayer);
                        if (this.hoverNode && this.hoverNode.allowDrop && !this._checkForDropEvent(this.hoverNode) || (this.hoverNode && this.hoverNode.name == this.selectedObject.parent)) {
                            this.seletedObject = this.diagram.nameTable[this.selectedObject.name];
                            pNode = this.selectedObject.parent;
                            newObj = this._updateContainerProperties(this.diagram.nameTable[this.selectedObject.name]);
                            this._removeFromContainer(this.selectedObject);
                            this._addToContainer(newObj);
                        } else {
                            this.diffx = 0;
                            this.diffy = 0;
                            if (!this.hoverNode && this.selectedObject.type == "pseudoGroup" && this.hasSameParent()) {

                                ej.datavisualization.Diagram.SvgContext._enableSelectedNode(this.selectedObject, this.diagram._svg, this.diagram);
                                ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._svg, this.diagram._adornerLayer);
                                this._removeHighLighter();
                                this.seletedObject = this.diagram.nameTable[this.selectedObject.name];
                                var checkDrop = !this._checkForDropEvent(this.hoverNode);
                                if (checkDrop) {
                                    if (this.isDiagram(evt)) {
                                        this._removeChildParent(this.selectedObject)
                                        this._addToDiagram();
                                    }
                                }
                            }
                        }
                    } else if (!this.isDiagram(evt) && this.selectedObject.type != "pseudoGroup") {
                        var overNode = this.hoverNode;
                        if (overNode && overNode.container && this.hoverNode.allowDrop && !this._checkForDropEvent(this.hoverNode) || (this.hoverNode && this.hoverNode.container && this.hoverNode.name == this.selectedObject.parent)) {
                            if (!this.selectedObject.segments) {
                                ej.datavisualization.Diagram.SvgContext._enableSelectedNode(this.selectedObject, this.diagram._svg, this.diagram);
                                ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._svg, this.diagram._adornerLayer);
                                this._removeHighLighter();
                                this.seletedObject = this.diagram.nameTable[this.selectedObject.name];
                                this._removeFromContainer(this.selectedObject);
                                newObj = this._updateContainerProperties(this.diagram.nameTable[this.selectedObject.name]);
                                //this._updateXY(this.diagram.nameTable[this.selectedObject.name], this.startPoint, this.currentPoint);
                                var parent = this.diagram.nameTable[newObj.parent];
                                if (parent)
                                    this._updateMargin(newObj, parent);
                                this._addToContainer(newObj);
                                if (parent)
                                    ej.datavisualization.Diagram.SvgContext._alignOnCanvas1(parent, this.diagram);
                            }
                        }
                    }
                    else {
                        if (this.hoverNode && (this.selectedObject.type == "pseudoGroup" || this.selectedObject.name == "multipleSelection")) {
                            if (this._fromDiagram(this.selectedObject.children)) {
                                if (this.hoverNode.allowDrop) {
                                    ej.datavisualization.Diagram.SvgContext._enableSelectedNode(this.selectedObject, this.diagram._svg, this.diagram);
                                    ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._svg, this.diagram._adornerLayer);
                                    ej.datavisualization.Diagram.SvgContext._removeNodeHighlighter(this.diagram._svg, this.diagram._adornerLayer);
                                    if (this._containsSwimlane(this.selectedObject.children)) {
                                        this._removeFromContainer(this.selectedObject);
                                        newObj = this._updateContainerProperties(this.diagram.nameTable[this.selectedObject.name]);
                                        parent = this.diagram.nameTable[newObj.parent];
                                        if (parent)
                                            this._updateMargin(this.selectedObject, parent);
                                        this._addToContainer(this.selectedObject);
                                    }
                                }
                            }
                        }
                        //    overNode = this.hoverNode;
                        //    if (overNode && overNode.container && this.hoverNode.allowDrop || (this.hoverNode && this.hoverNode.name == this.selectedObject.parent)) {
                        //        ej.datavisualization.Diagram.SvgContext._enableSelectedNode(this.selectedObject, this.diagram._svg, this.diagram.nameTable);
                        //        ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._svg, this.diagram._adornerLayer);
                        //        ej.datavisualization.Diagram.SvgContext._removeNodeHighlighter(this.diagram._svg, this.diagram._adornerLayer);
                        //        this.seletedObject = this.diagram.nameTable[this.selectedObject.name];
                        //        this._removeFromContainer(this.selectedObject);
                        //        newObj = this._updateContainerProperties(this.diagram.nameTable[this.selectedObject.name]);
                        //        //this._updateXY(this.diagram.nameTable[this.selectedObject.name], this.startPoint, this.currentPoint);
                        //        parent = this.diagram.nameTable[newObj.parent];
                        //        if (parent)
                        //            this._updateMargin(newObj, parent);
                        //        this._addToContainer(newObj);
                        //        ej.datavisualization.Diagram.SvgContext._alignOnCanvas1(parent, this.diagram);
                        //    }
                    }
                }
            }
            return newObj;
            //#endregion   
        };
        MoveTool.prototype._removeChildParent = function (node) {
            if (node.type == "pseudoGroup") {
                var child = null, parent;
                var children = this.diagram._getChildren(node.children);
                for (var i = 0; i < children.length; i++) {
                    child = this.diagram.nameTable[children[i]];
                    if (child) {
                        if (child.parent != "") {
                            parent = this.diagram.nameTable[child.parent];
                            if (parent && parent.children) {
                                ej.datavisualization.Diagram.Util.removeItem(parent.children, child.name);
                            }
                        }
                        child.parent = "";
                    }
                }
            } else {
                ej.datavisualization.Diagram.SvgContext._removeFromContainer(node, this.diagram._svg, this.diagram._adornerLayer);
            }
        };
        MoveTool.prototype._updateNodeState = function (evt, newObj) {
            if (this.diagram.nameTable[this.selectedObject.parent])
                var container = this.diagram.nameTable[this.selectedObject.parent].container;
            if (this.selectedObject.parent && this.diagram.nameTable[this.selectedObject.parent].container) {
                container = this.diagram.nameTable[this.selectedObject.parent].container;
                if (container.type == "canvas") {
                    if (this.hoverNode && newObj) {
                        var pNode = this.selectedObject.parent;
                        this._updateContainer(newObj, pNode, true);
                        ej.datavisualization.Diagram.DiagramContext.update(newObj, this.diagram);
                    }
                }
                else if (container.type == "stack") {

                    var evtArgs = this._checkForDropEvent(this.stackOverNode);
                    if (!evtArgs) {
                        var stackOverNode = this.stackOverNode;
                        if (stackOverNode) {
                            var parent = this.diagram.nameTable[stackOverNode.parent];

                            var groupBounds123 = ej.datavisualization.Diagram.Util.bounds(parent);
                            var grAngle = parent.rotateAngle;
                            if (!(parent.rotateAngle == 0) && (grAngle == 0))
                                this.diagram._rotate(parent, -parent.rotateAngle, this.diagram.nameTable);
                            parent.children = this.diagram._getChildren(parent.children);
                            this._swapChildren(parent.children, this.selectedObject.name, stackOverNode.name);
                            this._updateContainer(this.selectedObject);

                            if (!(parent.rotateAngle == 0) && (grAngle == 0))
                                this.diagram._rotate(parent, grAngle, this.diagram.nameTable);
                            var groupBounds1231 = ej.datavisualization.Diagram.Util.bounds(parent);
                            this.diagram._translate(parent, groupBounds123.topLeft.x - groupBounds1231.topLeft.x, groupBounds123.topLeft.y - groupBounds1231.topLeft.y, this.diagram.nameTable);
                            ej.datavisualization.Diagram.DiagramContext.update(parent, this.diagram);

                        } else {
                            this.diffx = 0;
                            this.diffy = 0;
                        }
                    }
                }
            }
            else if (this.selectedObject.type == "pseudoGroup") {
                var fNode = this.diagram.nameTable[this.diagram._getChild(this.selectedObject.children[0])];
                if (fNode && fNode.parent)
                    container = this.diagram.nameTable[fNode.parent].container;
                if (container && container.type == "canvas") {
                    if (this.hoverNode && newObj) {
                        pNode = this.selectedObject.parent;
                        this._updateContainer(newObj, pNode, true);
                        ej.datavisualization.Diagram.DiagramContext.update(newObj, this.diagram);
                    }
                }

            }
        },

       MoveTool.prototype.mouseup = function (evt, doc) {
           var skip = this.inAction;
           this.diffx = 0;
           this.diffy = 0;
           this._isMouseDown = false;
           ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
           var clickedObject;
           if (this.inAction) {
               var newObj = this._changeNodeState(evt, doc);
               this.inAction = false;
               if (this.activeLabel)
                   this._updateLabelXY(this.activeLabel, this.previousPoint, this.currentPoint);
               else
                   this._updateXY(this.selectedObject, this.previousPoint, this.currentPoint);
               //#region for Container

               this._updateNodeState(evt, newObj);
               //#endregion 
               this._updateObject();

               var data;
               var childTable = {};
               if (this.selectedObject.type == "group" || this.selectedObject.type == "pseudoGroup")
                   childTable = this.diagram._getChildTable(this.selectedObject, childTable);
               var temp = { "childTable": childTable, "node": this.selectedObject };
               data = $.extend(true, {}, temp);

               if (!this.diagram._selectedSymbol) {
                   var entry = { type: "positionchanged", undoObject: this.undoObject, redoObject: jQuery.extend(true, {}, data), isMultipleNode: this.selectedObject.type == "group" ? true : false };
                   this.diagram.addHistoryEntry(entry);
               }
               //var entry = new ej.datavisualization.Diagram.HistoryEntry(new ej.datavisualization.Diagram.MoveHandleCmd(this.undoObject, ej.datavisualization.Diagram.Util.clone(this.selectedObject), this.selectedObject.type == "pseudoGroup" ? true : false));
               //this.diagram.historyManager.addHistoryEntry(entry);
               this.diagram._updateSelectionHandle();
               clickedObject = this.selectedObject;
           }
           else {
               if (!this.selectedObject) {
                   if (evt.which == 3) {
                       if (this.diagram.selectionList && this.diagram.selectionList[0] && !(this.diagram.selectionList[0].type == "pseudoGroup")) {
                           if (this.diagram.selectionList.length > 0) {
                               this.selectedObject = this._findNodeUnderMouse(evt, true);
                               clickedObject = this.selectedObject;
                           } else {
                               this.selectedObject = this._findNodeUnderMouse(evt);
                               clickedObject = this.selectedObject;
                           }
                           if (this.selectedObject && !this.diagram._selectionContains(this.selectedObject))
                               this.diagram._clearSelection();
                       }
                   }
                   else {
                       if (evt.ctrlKey || evt.shiftKey) {
                           clickedObject = this._processCtrlKey(evt);
                       }
                       else {
                           if (ej.datavisualization.Diagram.Util.canDoSingleSelection(this.diagram))
                               this.selectedObject = this._findNodeUnderMouse(evt);
                           clickedObject = this.selectedObject;
                       }
                       if (this.selectedObject && !this.diagram._selectionContains(this.selectedObject))
                           this.diagram._clearSelection();
                   }
               }
               else {
                   clickedObject = this._findNodeUnderMouse(evt);
               }
           }

           if (this.selectedObject && this.selectedObject.type != "pseudoGroup") {
               var obj1 = this._findNodeUnderMouse(evt, true);
               if (!skip) {
                   var tempVal = this.selectedObject;
                   var args = this._raiseEvent("itemClick", { element: this.selectedObject, actualObject: this.actualObject, selectedObject: obj1, model: this.diagram.model, cancel: false });
                   this._itemClick(this.selectedObject, this.actualObject, obj1);
                   if (args.cancel)
                       this.selectedObject = tempVal;
               }
           }
           this._allowPan(this.selectedObject, "mouseup", evt);
           this._updateSelection();
           this.activeLabel = null;
           this.diagram._removeTooltip();
           if (!this.diagram._isEditing)
               this.diagram._endEdit();
           this.hoverNode = null;
           //raise click event
           if (clickedObject) {
               this._raiseEvent("click", { element: clickedObject, actualObject: this.actualObject });
           }
           base.prototype.mouseup.call(this, evt);
       };

        MoveTool.prototype._swapChildren = function (list, name1, name2) {
            var moveIndex = list.indexOf(name2);
            list.splice(list.indexOf(name1), 1);
            list.splice(moveIndex, 0, name1);
        };
        MoveTool.prototype._updateObject = function () {
            if (this.selectedObject.type == "pseudoGroup") {
                var child;
                var children = this.diagram._getChildren(this.selectedObject.children);
                for (var i = 0, len = children.length; i < len; i++) {
                    child = this.diagram.nameTable[children[i]];
                    ej.datavisualization.Diagram.DiagramContext.update(child, this.diagram);
                }
            }
            else
                ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
        };
        MoveTool.prototype._endAction = function () {
            base.prototype._endAction.apply(this);
            this._isMouseDown = false;
            this._mouseOffset = ej.datavisualization.Diagram.Size(0, 0);
        };

        MoveTool.prototype._renderHelper = function () {
            if (!this.svgHelper) {
                if (this.helper.segments)
                    ej.datavisualization.Diagram.SvgContext.renderConnector(this.helper, this.diagram._svg, this.diagram._diagramLayer);
                else if (this.helper.type == "group")
                    ej.datavisualization.Diagram.SvgContext.renderGroup(this.helper, this.diagram._svg, this.diagram._diagramLayer);
                else
                    ej.datavisualization.Diagram.SvgContext.renderNode(this.helper, this.diagram._svg, this.diagram._diagramLayer);
                this.svgHelper = document.getElementById(this.helper.name);
                this.svgHelper.setAttribute("pointer-events", "none");
            }
        };
        MoveTool.prototype._updateHelper = function () {
            this._updateXY(this.helper, this.previousPoint, this.currentPoint);
            ej.datavisualization.Diagram.SvgContext.update(this.helper, this.diagram);
        };
        MoveTool.prototype._updateHelperXY = function (shape, startPoint, endPoint) {
            var towardsLeft = endPoint.x < startPoint.x;
            var towardsTop = endPoint.y < startPoint.y;
            var difx = this.diffx + (endPoint.x - startPoint.x);
            var dify = this.diffy + (endPoint.y - startPoint.y);
            var offset;
            if (((this.diagram.model.snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToHorizontalLines) ||
                (this.diagram.model.snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToVerticalLines)) && this.diagram._enableSnapToObject())
                offset = ej.datavisualization.Diagram.SnapUtil._snapPoint(this.diagram, this.helper, towardsLeft, towardsTop, ej.datavisualization.Diagram.Point(difx, dify),
                    endPoint, startPoint);

            if (!offset)
                offset = ej.datavisualization.Diagram.Point(difx, dify);

            this.diffx = difx - offset.x;
            this.diffy = dify - offset.y;
            if (!ej.datavisualization.Diagram.Geometry.isEmptyPoint(offset)) {
                var args = this._raiseEvent("drag", { element: this.helper, offset: offset, cancel: false });
                if (!args.cancel) {
                    this.diagram._translate(shape, offset.x, offset.y, this.diagram.nameTable);
                    this._updateParent(shape);
                    if (shape.type == "group") {
                        ej.datavisualization.Diagram.Util._updateGroupBounds(shape, this.diagram);
                    }
                }
            }
        };

        MoveTool.prototype._updateXY = function (shape, startPoint, endPoint) {
            var towardsLeft = endPoint.x < startPoint.x;
            var towardsTop = endPoint.y < startPoint.y;
            var difx = this.diffx + (endPoint.x - startPoint.x);
            var dify = this.diffy + (endPoint.y - startPoint.y);
            var offset;
            if (((this.diagram.model.snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToHorizontalLines) ||
                (this.diagram.model.snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToVerticalLines)) || this.diagram._enableSnapToObject())
                offset = ej.datavisualization.Diagram.SnapUtil._snapPoint(this.diagram, this.selectedObject, towardsLeft, towardsTop, ej.datavisualization.Diagram.Point(difx, dify),
                    endPoint, startPoint);

            if (!offset)
                offset = ej.datavisualization.Diagram.Point(difx, dify);

            this.diffx = difx - offset.x;
            this.diffy = dify - offset.y;
            if (!ej.datavisualization.Diagram.Geometry.isEmptyPoint(offset)) {
                var args;
                if (!this.diagram._selectedSymbol)
                    args = this._raiseEvent("drag", { element: this.selectedObject, offset: offset, cancel: false });
                if ((args && !args.cancel) || this.diagram._selectedSymbol) {
                    var canPan = false;
                    if (shape.shape) {
                        if (ej.datavisualization.Diagram.Util.canAllowPan(shape)) {
                            if (this.diagram._hScrollOffset === 0) {
                                offset.x = 0;
                            }
                            if (this.diagram._vScrollOffset === 0) {
                                offset.y = 0;
                            }
                        }
                    }
                    this.diagram._translate(shape, offset.x, offset.y, this.diagram.nameTable);
                    this._updateParent(shape);
                    if (shape.type == "group") {
                        ej.datavisualization.Diagram.Util._updateGroupBounds(shape, this.diagram);
                    }
                }
            }
        };
        MoveTool.prototype._updateLabelXY = function (label, startPoint, endPoint) {
            var bounds = ej.datavisualization.Diagram.Util.bounds(this.selectedObject);
            var difx = endPoint.x - startPoint.x;
            var dify = endPoint.y - startPoint.y;
            if (!this.selectedObject.segments) {
                var matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, -this.selectedObject.rotateAngle);
                var diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify)); difx = diff.x; dify = diff.y;
            }
            var args = this._raiseEvent("drag", { element: label, offset: label.offset, cancel: false });
            if (!args.cancel) {
                this.diagram._translateLabel(this.selectedObject, label, difx, dify);
            }
        };
        MoveTool.prototype._updateParent = function (shape) {
            var child;
            if (shape.type == "pseudoGroup") {
                var children = this.diagram._getChildren(shape.children);
                for (var i = 0; i < children.length; i++) {
                    child = this.diagram.nameTable[children[i]];
                    if (child && child.parent) {
                        ej.datavisualization.Diagram.Util._updateGroupBounds(this.diagram.nameTable[child.parent], this.diagram);
                        ej.datavisualization.Diagram.DiagramContext.update(this.diagram.nameTable[child.parent], this.diagram);
                        this.diagram._updateAssociatedConnectorEnds(this.diagram.nameTable[child.parent], this.diagram.nameTable);
                    }
                }
            } else {
                if (shape && shape.parent) {
                    ej.datavisualization.Diagram.Util._updateGroupBounds(this.diagram.nameTable[shape.parent], this.diagram);
                    ej.datavisualization.Diagram.DiagramContext.update(this.diagram.nameTable[shape.parent], this.diagram);
                    this.diagram._updateAssociatedConnectorEnds(this.diagram.nameTable[shape.parent], this.diagram.nameTable);
                }
            }
            if (shape.parent) {
                var sParent = this.diagram.nameTable[shape.parent];
                if (sParent) {
                    this._updateParent(sParent);
                }
            }
        };
        MoveTool.prototype._updateSelection = function () {
            if (!this.diagram._selectionContains(this.selectedObject)) {
                this.diagram._addSelection(this.selectedObject);
            }
        };
        return MoveTool;
    })(ToolBase);

    ej.datavisualization.Diagram.MoveTool = MoveTool;
    //#endregion

    //#region ResizeTool
    var ResizeTool = (function (base) {
        ej.datavisualization.Diagram.extend(ResizeTool, base);
        function ResizeTool(diagram) {
            base.call(this, "resize", diagram);
            this.cursor = "default";//update resize cursor during action i.e in action
            this._resizeDirection = null;
            this._mouseOffset = ej.datavisualization.Diagram.Size(0, 0);
            this.diffx = 0;
            this.diffy = 0;
            this._startPoint = ej.datavisualization.Diagram.Size(0, 0);
            this.undoObject = null;
        }

        ResizeTool.prototype.mousedown = function (evt) {
            ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
            base.prototype.mousedown.call(this, evt);
            this.selectedObject = this.diagram.nameTable[this.diagram.selectionList[0].name];
            var data;
            var childTable = {};
            if (this.selectedObject.type == "group" || this.selectedObject.type == "pseudoGroup")
                childTable = this.diagram._getChildTable(this.selectedObject, childTable);
            var temp = { "childTable": childTable, "node": this.selectedObject };
            data = $.extend(true, {}, temp);
            this.undoObject = jQuery.extend(true, {}, data);
            //this.undoObject = ej.datavisualization.Diagram.Util.clone(this.selectedObject);
            this._resizeDirection = evt.target.getAttribute("class");
            this.initialBounds = { width: this.selectedObject.width, height: this.selectedObject.height, y: this.selectedObject.offsetY, x: this.selectedObject.offsetX };
        };
        ResizeTool.prototype._createUpdateHelper = function () {
            if (!this.helper) {
                this.helper = this._getCloneNode(this.selectedObject);
                this.helper.type = null;
                this.helper.name = "helper";
                ej.datavisualization.Diagram.SvgContext._drawContainerHelper(this.diagram);
                this._startPoint = this.currentPoint;
                this._updateSize(this.helper, this.previousPoint, this.currentPoint, null, null, null, true);
            } else {
                var groupBounds123 = ej.datavisualization.Diagram.Util.bounds(this.helper);
                this._updateSize(this.helper, this.previousPoint, this.currentPoint, null, null, null, true);
                var groupBounds1231 = ej.datavisualization.Diagram.Util.bounds(this.helper);
                if (this.selectedObject.container)
                    this.diagram._translate(this.helper, groupBounds123.topLeft.x - groupBounds1231.topLeft.x, groupBounds123.topLeft.y - groupBounds1231.topLeft.y, this.diagram.nameTable);
                ej.datavisualization.Diagram.SvgContext._updateContainerHelper(this.diagram);
            }
        };
        ResizeTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
            if (this.selectedObject) {
                if (!this.inAction) {
                    ej.datavisualization.Diagram.SvgContext._removePivotPoint(this.selectedObject, this.diagram._svg, this.diagram._currZoom);
                    this.inAction = true;
                }
                var canvasChild = false;
                if (this.selectedObject && this.selectedObject.parent) {
                    var parNode = this.diagram.nameTable[this.selectedObject.parent];
                    if (parNode.container && parNode.container.type == "canvas")
                        canvasChild = true;
                }
                else if (this.selectedObject.type == "pseudoGroup" && this.hasSameParent() && this._fromContainer(this.diagram._getChildren(this.selectedObject.children))) {
                    canvasChild = true;
                }
                if (this.selectedObject && canvasChild) {
                    this._createUpdateHelper();
                }
                else if (this.selectedObject && this.diagram.nameTable[this.selectedObject.name].container) {
                    this._createUpdateHelper();
                }
                else if (this.selectedObject.parent && this.diagram.nameTable[this.selectedObject.parent] &&
                    this.diagram.nameTable[this.selectedObject.parent].container && this.diagram.nameTable[this.selectedObject.parent].container.type == "stack") {
                    if (!this.helper) {
                        this.helper = this._getCloneNode();
                    }
                    ej.datavisualization.Diagram.SvgContext._drawContainerHelper(this.diagram);
                    this._startPoint = this.currentPoint;
                    this._updateSize(this.helper, this.previousPoint, this.currentPoint);
                    ej.datavisualization.Diagram.DiagramContext.update(this.helper, this.diagram);
                }
                else {
                    if (this.selectedObject.type != "pseudoGroup")
                        this._updateSize(this.selectedObject, this.previousPoint, this.currentPoint);
                    else if (this.selectedObject.type == "pseudoGroup" && !this._fromContainer(this.diagram._getChildren(this.selectedObject.children)) && this._fromSameContainer(this.diagram._getChildren(this.selectedObject.children)))
                        this._updateSize(this.selectedObject, this.previousPoint, this.currentPoint);
                }
                ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                this.diagram._renderTooltip(this.selectedObject);
                this.diagram._updateSelectionHandle(true);
            }

            this.previousPoint = this.currentPoint;
        };
        ResizeTool.prototype._updateResizeObject = function () {
            var object = this.diagram.nameTable[this.selectedObject.name];
            var groupBounds123 = ej.datavisualization.Diagram.Util.bounds(object);
            var grAngle = object.rotateAngle;
            this.diagram._rotate(object, -object.rotateAngle, this.diagram.nameTable);
            var dX = object.width - this.helper.width;
            var dY = object.height - this.helper.height;
            if ((!object.container && object.rotateAngle == 0)) {
                this._updateSize(object, this.startPoint, this.currentPoint);
            }
            else {
                this.diagram.updateNode(object.name, { width: this.helper.width });
                this.diagram.updateNode(object.name, { height: this.helper.height });
            }

            object.minWidth = object.width;
            object.minHeight = object.height;
            this.diagram._rotate(object, grAngle, this.diagram.nameTable);
            var groupBounds1231 = ej.datavisualization.Diagram.Util.bounds(object);
            if (!object.container && object.rotateAngle == 0) { //this.diagram._translate(object, dX / 2, dY / 2, this.diagram.nameTable);
            }
            else
                this.diagram._translate(object, groupBounds123.topLeft.x - groupBounds1231.topLeft.x, groupBounds123.topLeft.y - groupBounds1231.topLeft.y, this.diagram.nameTable);
            return object;
        };
        ResizeTool.prototype.mouseup = function (evt) {
            if (this.inAction) {
                ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
                this.inAction = false;
                var canvasChild = false;
                if (this.selectedObject && this.selectedObject.parent) {
                    var parNode = this.diagram.nameTable[this.selectedObject.parent];
                    if (parNode.container && parNode.container.type == "canvas")
                        canvasChild = true;
                }
                else if (this.selectedObject.type == "pseudoGroup" && this.hasSameParent() && this._fromContainer(this.diagram._getChildren(this.selectedObject.children))) {
                    canvasChild = true;
                }
                if (this.selectedObject && canvasChild) {
                    ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._svg, this.diagram._adornerLayer);
                    var object = this._updateResizeObject();
                    this._updateContainer(object, null, true);
                }
                else if (this.selectedObject && this.diagram.nameTable[this.selectedObject.name].container) {
                    ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._svg, this.diagram._adornerLayer);
                    object = this.diagram.nameTable[this.selectedObject.name];
                    if (this.selectedObject.container) {
                        object.minWidth = this.helper.width.width;
                        object.minHeight = this.helper.width.height;
                    }
                    this._updateSize(this.selectedObject, this._startPoint, this.currentPoint, null, null, true);
                    if (this.selectedObject.parent) {//canvas panel
                        var parent = this.diagram.nameTable[this.selectedObject.parent];
                        if (parent.type == "group" && parent.container && parent.container.type == "stack") {
                            ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._svg, this.diagram._adornerLayer);
                            object = this.diagram.nameTable[this.selectedObject.name];
                            var newsize = this.diagram._getMinMaxSize(this.selectedObject, this.helper.width, this.helper.height);
                            object.height = newsize.height;
                            object.width = newsize.width;
                            if (this.selectedObject.container) {
                                object.minWidth = object.width;
                                object.minHeight = object.height;
                            }
                            this._updateContainer(this.diagram.nameTable[this.selectedObject.name]);
                        }
                    }
                    else if (this.selectedObject) {//stack panel
                        this.selectedObject.minWidth = this.selectedObject.width;
                        this.selectedObject.minHeight = this.selectedObject.height;
                    }
                }
                else if (this.selectedObject.parent && this.diagram.nameTable[this.selectedObject.parent] &&
                this.diagram.nameTable[this.selectedObject.parent].container && this.diagram.nameTable[this.selectedObject.parent].container.type == "stack") {
                    ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._svg, this.diagram._adornerLayer);
                    this.selectedObject.height = this.helper.height;
                    this.selectedObject.width = this.helper.width;
                    this._updateContainer(this.selectedObject);
                }
                else {
                    this._updateSize(this.selectedObject, this.previousPoint, this.currentPoint);
                }
                if (this.selectedObject.parent) {
                    ej.datavisualization.Diagram.Util._updateGroupBounds(this.diagram.nameTable[this.selectedObject.parent], this.diagram);
                }
                ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                this.diagram._updateSelectionHandle();

                var data;
                var childTable = {};
                if (this.selectedObject.type == "group" || this.selectedObject.type == "pseudoGroup")
                    childTable = this.diagram._getChildTable(this.selectedObject, childTable);
                var temp = { "childTable": childTable, "node": this.selectedObject };
                data = $.extend(true, {}, temp);

                var entry = { type: "sizechanged", undoObject: this.undoObject, redoObject: jQuery.extend(true, {}, data), isMultipleNode: this.selectedObject.type == "group" ? true : false };
                this.diagram.addHistoryEntry(entry);

                //var entry = new ej.datavisualization.Diagram.HistoryEntry(new ej.datavisualization.Diagram.ResizeHandleCmd(this.undoObject, ej.datavisualization.Diagram.Util.clone(this.selectedObject), this.selectedObject.type == "pseudoGroup" ? true: false));
                //this.diagram.historyManager.addHistoryEntry(entry);
                this.diagram._removeTooltip();
            }
            base.prototype.mouseup.call(this, evt);
        };

        ResizeTool.prototype._updateContainer = function (newObj, prevParent, isDrop) {
            var bounds, groupBounds, dx = 0, dy = 0, newSize;
            if (newObj) {

                var parObj = this.diagram.nameTable[newObj.parent];
                if (!parObj && newObj.type == "pseudoGroup") {
                    var fNode = this.diagram.nameTable[this.diagram._getChild(this.selectedObject.children[0])];
                    parObj = this.diagram.nameTable[fNode.parent];
                }
                if (parObj) {
                    if (parObj.container.type == "canvas") {
                        if (isDrop) {
                            isDrop = false;
                            var group = this.diagram.nameTable[newObj.parent];

                            if (!group && newObj.type == "pseudoGroup") {
                                group = parObj;
                            }
                            var groupBounds123 = ej.datavisualization.Diagram.Util.bounds(group);
                            var grAngle = group.rotateAngle;
                            this.diagram._rotate(group, -group.rotateAngle, this.diagram.nameTable);
                            bounds = ej.datavisualization.Diagram.Util.bounds(newObj);
                            var bounds1 = ej.datavisualization.Diagram.Geometry.rect([bounds.topLeft, bounds.topRight, bounds.bottomRight, bounds.bottomLeft]);
                            groupBounds = ej.datavisualization.Diagram.Util.bounds(group);
                            var tightchildBounds = this.diagram._getTightChildrenBounds(group);
                            var right = true;
                            var bottom = true;
                            var bRight = bounds1.x + bounds1.width;
                            var bBottom = bounds1.y + bounds1.height;

                            if (bRight >= groupBounds.right) {
                                ///if exeeds right 
                                dx = bRight - groupBounds.right + group.paddingRight;
                                newSize = this.diagram._getMinMaxSize(group, (group.width + dx), group.height, true);
                                widDiff = newSize.width - group.width;
                                group.width = newSize.width;
                                group.offsetX += (widDiff / 2);
                                if (bRight < groupBounds.right) {
                                    right = false;
                                }
                            }
                            if (bBottom >= groupBounds.bottom) {
                                ///if exeeds bottom 
                                dy = bBottom - groupBounds.bottom + group.paddingBottom;
                                newSize = this.diagram._getMinMaxSize(group, (group.width), (group.height + dy), true);
                                heiDiff = newSize.height - group.height;
                                group.height = newSize.height;
                                group.offsetY += (heiDiff / 2);
                                bottom = true;
                                if (bBottom < groupBounds.bottom) {
                                    bottom = false;
                                }
                            }
                            if (bRight < groupBounds.right && right) { //if decreces from right
                                dx = (tightchildBounds.x + tightchildBounds.width) + group.paddingRight - groupBounds.right;
                                newSize = this.diagram._getMinMaxSize(group, (group.width + dx), group.height, true);
                                var widDiff = newSize.width - group.width;
                                group.width = newSize.width;
                                group.offsetX += (widDiff / 2);
                            }
                            if (bBottom < groupBounds.bottom && bottom) { //if decreces from bottom
                                dy = (tightchildBounds.y + tightchildBounds.height) + group.paddingBottom - groupBounds.bottom;
                                newSize = this.diagram._getMinMaxSize(group, (group.width), (group.height + dy), true);
                                var heiDiff = newSize.height - group.height;
                                group.height = newSize.height;
                                group.offsetY += (heiDiff / 2);
                            }
                            this._updateMargin(newObj, group);
                            ej.datavisualization.Diagram.SvgContext._alignOnCanvas1(group, this.diagram);
                            this.diagram._rotate(group, grAngle, this.diagram.nameTable);
                            var groupBounds1231 = ej.datavisualization.Diagram.Util.bounds(group);
                            this.diagram._translate(group, groupBounds123.topLeft.x - groupBounds1231.topLeft.x, groupBounds123.topLeft.y - groupBounds1231.topLeft.y, this.diagram.nameTable);
                            if (group.parent && group.container && group.container.type == "canvas")
                                this._updateMargin(group, this.diagram.nameTable[group.parent]);
                            ej.datavisualization.Diagram.DiagramContext.update(group, this.diagram);
                        } else {
                            var vertical = false;
                            var horizontal = false;
                            group = this.diagram.nameTable[newObj.parent];
                            if (newObj.container && newObj.container.type == "stack") {
                                if (newObj.container.orientation == "vertical")
                                    vertical = true;
                                else
                                    horizontal = true;
                            }
                            bounds = this.diagram._getBoundsWithoutStretch(group, vertical, horizontal);
                            bounds.width += group.paddingLeft + group.paddingRight;
                            bounds.height += group.paddingTop + group.paddingBottom;
                            newSize = this.diagram._getMinMaxSize(group, (bounds.width), (bounds.height), true);
                            widDif = newSize.width - group.width;
                            heiDif = newSize.height - group.height;
                            group.offsetX += (widDif / 2);
                            group.width = newSize.width;
                            group.offsetY += (heiDif / 2);
                            group.height = newSize.height;
                            ej.datavisualization.Diagram.SvgContext._alignOnCanvas1(group, this.diagram);
                            ej.datavisualization.Diagram.DiagramContext.update(group, this.diagram);
                        }
                        if (group.parent) {
                            if (this.diagram.nameTable[group.parent])
                                isDrop = true;
                            this._updateContainer(group, null, isDrop);
                        }
                    }//end canvas

                    else if (parObj.container.type == "stack") {
                        group = this.diagram.nameTable[newObj.parent];
                        bounds = ej.datavisualization.Diagram.SvgContext._measureStackSize(group, this.diagram, true);
                        newSize = this.diagram._getMinMaxSize(group, (bounds.width), (bounds.height), true);
                        var widDif = newSize.width - group.width;
                        var heiDif = newSize.height - group.height;
                        group.offsetX += (widDif / 2);
                        group.width = newSize.width;
                        group.offsetY += (heiDif / 2);
                        group.height = newSize.height;
                        ej.datavisualization.Diagram.SvgContext._alignOnStack(group, this.diagram);
                        ej.datavisualization.Diagram.DiagramContext.update(group, this.diagram);
                        if (group.parent)
                            this._updateContainer(group);

                    }
                }
            }
        };
        ResizeTool.prototype._updateSize = function (shape, startPoint, endPoint, x1, y1, updateMinMax, isHelper) {
            var deltaWidth, deltaHeight, diff;
            var matrix = ej.Matrix.identity();
            ej.Matrix.rotate(matrix, -shape.rotateAngle);
            var horizontalsnap = { snapped: false, offset: 0, left: false, right: false };
            var verticalsnap = { snapped: false, offset: 0, top: false, bottom: false };
            var difx = x1 ? x1 : (this.currentPoint.x - this.startPoint.x);
            var dify = y1 ? y1 : (this.currentPoint.y - this.startPoint.y);
            var pivot = ej.datavisualization.Diagram.Point(0, 0);
            var trans = ej.Matrix.identity();
            var x = shape.offsetX;
            var y = shape.offsetY;
            ej.Matrix.rotate(trans, shape.rotateAngle, x, y);
            var w = shape.width;
            var h = shape.height;
            x = x - w * shape.pivot.x;
            y = y - h * shape.pivot.y;
            switch (this._resizeDirection) {
                case "n-resize":
                    pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(x + w / 2, y + h));
                    var deltaWidth = 1;
                    diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify));
                    difx = diff.x; dify = diff.y;
                    dify = this._snapTop(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    deltaHeight = (this.initialBounds.height - dify) / shape.height;
                    break;
                case "e-resize":
                    pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(x, y + h / 2));
                    diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify)); difx = diff.x; dify = diff.y;
                    difx = this._snapRight(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    dify = 0;
                    deltaWidth = (this.initialBounds.width + difx) / shape.width;
                    deltaHeight = 1;
                    break;
                case "w-resize":
                    pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(x + w, y + h / 2));
                    diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify)); difx = diff.x; dify = diff.y;
                    difx = this._snapLeft(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    dify = 0;
                    deltaWidth = (this.initialBounds.width - difx) / shape.width;
                    deltaHeight = 1;
                    break;
                case "s-resize":
                    pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(x + w / 2, y));
                    deltaWidth = 1;
                    diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify));
                    difx = diff.x; dify = diff.y;
                    dify = this._snapBottom(horizontalsnap, verticalsnap, diff.x, diff.y, shape, endPoint == startPoint);
                    deltaHeight = (this.initialBounds.height + dify) / shape.height;
                    break;
                case "ne-resize":
                    pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(x, y + h));
                    diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify)); difx = diff.x; dify = diff.y;
                    difx = this._snapRight(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    dify = this._snapTop(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    deltaWidth = (this.initialBounds.width + difx) / shape.width;
                    deltaHeight = (this.initialBounds.height - dify) / shape.height;
                    break;
                case "nw-resize":
                    pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(x + w, y + h));
                    diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify)); difx = diff.x; dify = diff.y;
                    dify = this._snapTop(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    difx = this._snapLeft(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    deltaWidth = (this.initialBounds.width - difx) / shape.width;
                    deltaHeight = (this.initialBounds.height - dify) / shape.height;
                    break;
                case "se-resize":
                    pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(x, y));
                    diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify)); difx = diff.x; dify = diff.y;
                    dify = this._snapBottom(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    difx = this._snapRight(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    deltaWidth = (this.initialBounds.width + difx) / shape.width;
                    deltaHeight = (this.initialBounds.height + dify) / shape.height;
                    break;
                case "sw-resize":
                    pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(x + w, y));
                    diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify)); difx = diff.x; dify = diff.y;
                    dify = this._snapBottom(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    difx = this._snapLeft(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    deltaWidth = (this.initialBounds.width - difx) / shape.width;
                    deltaHeight = (this.initialBounds.height + dify) / shape.height;
                    break;
            }
            var propResize;
            if (shape)
                if (shape.type == "pseudoGroup" || shape.type == "group") {
                    var list = this.diagram._getChildren(this.diagram.nameTable[this.diagram.selectionList[0].name].children);
                    for (var i = 0; i < list.length; i++) {
                        var element = this.diagram.nameTable[list[i]];
                        if (element && !(element.segments) && (element.constraints & ej.datavisualization.Diagram.NodeConstraints.AspectRatio)) {
                            propResize = true;
                        }
                    }
                }
            if (propResize || (shape.constraints & ej.datavisualization.Diagram.NodeConstraints.AspectRatio)) {
                if (this._resizeDirection == "n-resize" || this._resizeDirection == "s-resize" || this._resizeDirection == "w-resize" || this._resizeDirection == "e-resize") {
                    var rotatedDif = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(this.previousPoint.x - this.currentPoint.x, this.previousPoint.y - this.currentPoint.y));
                    if (Math.abs(rotatedDif.x) > Math.abs(rotatedDif.y))
                        deltaHeight = deltaWidth;
                    else
                        deltaWidth = deltaHeight;
                }
                else if (this.previousPoint != this.currentPoint)
                    deltaHeight = deltaWidth = Math.max(deltaHeight, deltaWidth);
                else
                    deltaHeight = deltaWidth = 0;
            }
            var size = ej.datavisualization.Diagram.Size();
            size.width = deltaWidth;
            size.height = deltaHeight;
            if (!ej.datavisualization.Diagram.Geometry.isEmptySize(size)) {
                this.diagram.scale(shape, deltaWidth, deltaHeight, pivot, this.diagram.nameTable, null, updateMinMax, isHelper);
                var args = this._raiseEvent("sizeChange", { element: this.selectedObject, offset: size, cancel: false });
                if (args.cancel && !isHelper) {
                    this.diagram.scale(shape, 1 / deltaWidth, 1 / deltaHeight, pivot, this.diagram.nameTable);
                }
                if (shape.type == "group") {
                    ej.datavisualization.Diagram.Util._updateGroupBounds(shape, this.diagram);
                }
            }
        };

        ResizeTool.prototype._snapTop = function (horizontalsnap, verticalsnap, delx, dely, shape, ended) {
            var dify = dely;
            verticalsnap.top = true;
            var snapSettings = this.diagram.model.snapSettings;
            var zoomFactor = this.diagram._currZoom;
            if (this.diagram._enableSnapToObject() && !shape.rotateAngle) {
                var y = this.initialBounds.y - this.initialBounds.height / 2 + dely - (shape.offsetY - shape.height / 2);
                ej.datavisualization.Diagram.SnapUtil._snapSize(this.diagram, horizontalsnap, verticalsnap, delx, y, this.selectedObject, ended);
            }
            if (!verticalsnap.snapped) {
                if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToHorizontalLines) {
                    var top = this.initialBounds.y - this.initialBounds.height / 2;
                    var actualTop = top + dely;
                    var roundedTop = ej.datavisualization.Diagram.SnapUtil._round(actualTop, snapSettings.horizontalGridLines.snapInterval, zoomFactor);
                    dify = roundedTop - top;
                }
            }
            else {
                dify = (dely - y) + verticalsnap.offset;
            }
            return dify;
        };
        ResizeTool.prototype._snapBottom = function (horizontalsnap, verticalsnap, delx, dely, shape, ended, matrix) {
            var dify = dely;
            verticalsnap.bottom = true;
            var snapSettings = this.diagram.model.snapSettings;
            var zoomFactor = this.diagram._currZoom;
            if (this.diagram._enableSnapToObject() && !shape.rotateAngle) {
                var y = this.initialBounds.y + this.initialBounds.height / 2 + dely - (shape.offsetY + shape.height / 2);
                ej.datavisualization.Diagram.SnapUtil._snapSize(this.diagram, horizontalsnap, verticalsnap, delx, y, this.selectedObject, ended);;
            }
            var bounds = ej.datavisualization.Diagram.Util.bounds(shape);
            if (!verticalsnap.snapped) {
                if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToHorizontalLines) {
                    var bottom = this.initialBounds.y + this.initialBounds.height / 2;
                    var actualBottom = bottom + dely;
                    var roundedBottom = ej.datavisualization.Diagram.SnapUtil._round(actualBottom, snapSettings.horizontalGridLines.snapInterval, zoomFactor);
                    dify = roundedBottom - bottom;
                }
            }
            else {
                dify = (dely - y) + verticalsnap.offset;
            }
            return dify;
        };
        ResizeTool.prototype._snapLeft = function (horizontalsnap, verticalsnap, delx, dely, shape, ended) {
            var difx = delx;
            horizontalsnap.left = true;
            var snapSettings = this.diagram.model.snapSettings;
            var zoomFactor = this.diagram._currZoom;
            if (this.diagram._enableSnapToObject() && !shape.rotateAngle) {
                var x = this.initialBounds.x - this.initialBounds.width / 2 + delx - (shape.offsetX - shape.width / 2);
                ej.datavisualization.Diagram.SnapUtil._snapSize(this.diagram, horizontalsnap, verticalsnap, x, dely, this.selectedObject, ended);;
            }
            var bounds = ej.datavisualization.Diagram.Util.bounds(shape);
            if (!horizontalsnap.snapped) {
                if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToVerticalLines) {
                    var left = this.initialBounds.x - this.initialBounds.width / 2;
                    var actualLeft = left + delx;
                    var roundedLeft = ej.datavisualization.Diagram.SnapUtil._round(actualLeft, snapSettings.horizontalGridLines.snapInterval, zoomFactor);
                    difx = roundedLeft - left;
                }
            }
            else {
                difx = (delx - x) + horizontalsnap.offset;
            }
            return difx;
        };
        ResizeTool.prototype._snapRight = function (horizontalsnap, verticalsnap, delx, dely, shape, ended) {
            var difx = delx;
            horizontalsnap.right = true;
            var snapSettings = this.diagram.model.snapSettings;
            var zoomFactor = this.diagram._currZoom;
            if (this.diagram._enableSnapToObject() && !shape.rotateAngle) {
                var x = this.initialBounds.x + this.initialBounds.width / 2 + delx - (shape.offsetX + shape.width / 2);
                ej.datavisualization.Diagram.SnapUtil._snapSize(this.diagram, horizontalsnap, verticalsnap, x, dely, this.selectedObject, ended);
            }
            if (!horizontalsnap.snapped) {
                if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToVerticalLines) {
                    var right = this.initialBounds.x + this.initialBounds.width / 2;
                    var actualRight = right + delx;
                    var roundedRight = ej.datavisualization.Diagram.SnapUtil._round(actualRight, snapSettings.verticalGridLines.snapInterval, zoomFactor);
                    difx = roundedRight - right;
                }
            }
            else {
                difx = (delx - x) + horizontalsnap.offset;
            }
            return difx;
        };
        return ResizeTool;
    })(ToolBase);

    ej.datavisualization.Diagram.ResizeTool = ResizeTool;
    //#endregion

    //#region EndPointTool
    var ConnectionEditTool = (function (base) {
        ej.datavisualization.Diagram.extend(ConnectionEditTool, base);
        function ConnectionEditTool(diagram) {
            base.call(this, "endPoint", diagram);
            this.cursor = "move";
            this._endPoint = null;
            this._undoObject = null;
        }
        ConnectionEditTool.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            if (evt.ctrlKey && evt.shiftKey) {
                var parent = $(evt.target).parents(".ej-d-connector");
                if (parent.length > 0) {
                    this.selectedObject = this.diagram.nameTable[parent[0].id];
                    if (this.diagram._hasSelection())
                        this.diagram._clearSelection();
                    this.diagram._addSelection(this.selectedObject);
                }
            }
            if (this.diagram.selectionList[0] && !this.selectedObject) this.selectedObject = this.diagram.nameTable[this.diagram.selectionList[0].name];
            this.undoObject = this._getClonedObject(this.selectedObject);
            this._endPoint = evt.target.getAttribute("class");
            this.targetid = evt.target.id;
            this._selectedSegment = "";
        };
        ConnectionEditTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            if (this.selectedObject && !(evt.ctrlKey && evt.shiftKey)) {
                var isTwo = false;
                if (this.selectedObject.segments.length == 2) isTwo = true;
                var difx = this.currentPoint.x - this.previousPoint.x;
                var dify = this.currentPoint.y - this.previousPoint.y;
                if (!this.inAction && (this.startPoint.x != this.currentPoint.x || this.startPoint.y != this.currentPoint.y)) {
                    this.inAction = true;
                    if (this.selectedObject.segments.length > 0) {
                        for (var m = 0; m < this.selectedObject.segments.length; m++) {
                            this.selectedObject.segments[m]._bridges = [];
                        }
                    }
                    (this.diagram._svg.getElementById(this.selectedObject.name + "_hitTest")).style["pointer-events"] = "none";
                    (this.diagram._svg.getElementById(this.selectedObject.name)).style["pointer-events"] = "none";
                    (this.diagram._svg.getElementById(this.diagram._svg.document.id + "handle_g")).style["pointer-events"] = "none";
                    var coll = this.targetid.split("_");
                    coll.reverse();
                    var index = Number(coll[0]);
                    this.selectedSegment = this.selectedObject.segments[index];
                    var segment = this.selectedSegment;
                    if (this.selectedSegment && this.selectedSegment.type == "orthogonal") {
                        var refresh = false;
                        if (index === 0) {
                            var editfirstsegment = true;
                        }
                        if (!this.selectedSegment.length) {
                            this._addTerminalSegment(difx, dify, coll);
                            refresh = true;
                        }
                        else if (index == 0) {
                            this.insertFirstSegment(difx, dify, coll);
                            refresh = true;
                        }
                        else {
                            this.nextSegment = this.selectedObject.segments[index + 1];
                        }
                    }
                    else
                        this.nextSegment = this.selectedObject.segments[index + 1];
                    if (refresh) {
                        ej.datavisualization.Diagram.Util._updateConnectorSegments(this.selectedObject, !(isTwo || editfirstsegment || !this.selectedObject.sourcePort), !(isTwo || !(segment.length || segment.length === 0) || !this.selectedObject.targetPort), this.diagram);
                        ej.datavisualization.Diagram.DiagramContext._refreshSegments(this.selectedObject, this.diagram);
                        ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.diagram.selectionList[0], this.diagram._svg, this.diagram._currZoom);
                    }
                    if (!this.selectedSegment && this._endPoint == "targetEndPoint") this.selectedSegment = this.selectedObject.segments[this.selectedObject.segments.length - 1];
                    if (!this.selectedSegment && this._endPoint == "sourceEndPoint") {
                        this.selectedSegment = this.selectedObject.segments[0];
                        this.nextSegment = this.selectedObject.segments[1];
                    }
                    this.undoObject = this._getClonedObject(this.selectedObject);
                }
                else if (this.inAction) {
                    if (this.selectedSegment && this._endPoint == "segmentEnd") {
                        this._updateAdjacentSegments(difx, dify);
                    }
                    else if (this._endPoint != "segmentEnd") {
                        if (this._endPoint == "targetEndPoint" || this._endPoint == "sourceEndPoint")
                            this._checkConnectionPossible(evt);
                        var updateSelection = this._updatePoints(this.selectedObject);
                        this._disconnect(this.selectedObject);
                        this._updateConnection(this.selectedObject, updateSelection);

                    }
                    ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                    this.diagram._updateSelectionHandle(true);
                }
            }
            this.previousPoint = this.currentPoint;
        };
        ConnectionEditTool.prototype._updateAdjacentSegments = function (difx, dify) {
            var current = this.selectedSegment;
            var pt = { x: difx + current._endPoint.x, y: dify + current._endPoint.y };
            if (current.type == "orthogonal") {
                if (current._direction == "left" || current._direction == "right") {
                    current._startPoint.y += dify;
                    current._endPoint.y = current._startPoint.y;
                }
                else {
                    current._startPoint.x += difx;
                    current._endPoint.x = current._startPoint.x;
                }
                current.points[0] = current._startPoint;
                current.points[current.points.length - 1] = current._endPoint;
                var index = this.selectedObject.segments.indexOf(this.selectedSegment);
                var prev = this.selectedObject.segments[index - 1];
                if (prev) this.updatePreviousSegment(current, prev, difx, dify);
            }
            else if (current.type == "straight") {
                current.points[current.points.length - 1] = current._endPoint = pt;
                current._point = current.point = pt;
            }
            else {
                current.points[current.points.length - 1] = current._endPoint = pt;
                current._point = current.point = pt;
                ej.datavisualization.Diagram.Util._updateBezierPoints(current);
            }
            if (this.nextSegment)
                this.updateNextSegment(current, this.nextSegment, difx, dify);
        }
        ConnectionEditTool.prototype._addTerminalSegment = function (difx, dify, coll) {
            var segment = this.selectedSegment;
            this.selectedObject.segments.pop();
            var first = this.selectedObject.segments[this.selectedObject.segments.length - 1] && this.selectedObject.segments[this.selectedObject.segments.length - 1].type == "orthogonal" ? this.selectedObject.segments[this.selectedObject.segments.length - 1] : null;
            for (var i = 0; i < segment.points.length - 2; i++) {
                var seg = ej.datavisualization.Diagram.Segment({
                    type: "orthogonal",
                    length: ej.datavisualization.Diagram.Geometry.distance(segment.points[i], segment.points[i + 1]),
                    direction: ej.datavisualization.Diagram.Util._getBezierDirection(segment.points[i], segment.points[i + 1])
                });
                if (seg.length == 0) {
                    if (first.direction == "top" || first.direction == "bottom") {
                        seg._direction = seg.direction = difx > 0 ? "right" : "left";
                    }
                    else {
                        seg._direction = seg.direction = dify > 0 ? "bottom" : "top";
                    }
                }
                first = seg;
                this.selectedObject.segments.push(seg);
            }
            var sec = Number(coll[1]);
            if (segment.points.length == 2 || sec == segment.points.length - 2) {
                if (first) {
                    first.length += 5;
                    first._length = first.length;
                }
                if (sec != 0) {
                    var length = ej.datavisualization.Diagram.Geometry.distance(segment.points[segment.points.length - 2], segment._endPoint);
                    var direction = ej.datavisualization.Diagram.Util._getBezierDirection(segment.points[segment.points.length - 2], segment._endPoint);
                    var newsegment = ej.datavisualization.Diagram.Segment({ type: "orthogonal", length: 2 * length / 3, direction: direction });
                    this.selectedObject.segments.push(newsegment);

                }
            }
            var lastseg = ej.datavisualization.Diagram.Segment({ type: "orthogonal" });
            this.selectedObject.segments.push(lastseg);
            var index = Number(coll[0]) + (Number(coll[1]) || 0);
            this.selectedSegment = this.selectedObject.segments[index];
            this.nextSegment = this.selectedObject.segments[index + 1];
            if (index == this.selectedObject.segments.length - 2) {
                if (Number(coll[0]) == 0) {
                    this.nextSegment._direction = ej.datavisualization.Diagram.Util._getBezierDirection(segment.points[segment.points.length - 2], segment._endPoint);;
                }
                else
                    this.nextSegment._direction = segment._direction;
            }
            else {
                lastseg._direction = ej.datavisualization.Diagram.Util._getBezierDirection(segment.points[segment.points.length - 2], segment._endPoint);;
            }
            if (index == 0) this.insertFirstSegment(difx, dify, coll);

        },
        ConnectionEditTool.prototype.insertFirstSegment = function (difx, dify, coll) {
            var segment = this.selectedSegment;
            if (this.selectedObject.sourcePort && segment.length && this.selectedObject.segments[0].points.length > 2) {
                this.selectedObject.segments.splice(0, 1);
                var segments = [];
                var prev;
                for (var i = 0; i < segment.points.length - 1; i++) {
                    var first = ej.datavisualization.Diagram.Segment({
                        type: "orthogonal",
                        length: ej.datavisualization.Diagram.Geometry.distance(segment.points[i], segment.points[i + 1]),
                        direction: ej.datavisualization.Diagram.Util._getBezierDirection(segment.points[i], segment.points[i + 1])
                    });
                    if (first.length == 0) {
                        if (prev.direction == "top" || prev.direction == "bottom") {
                            first._direction = first.direction = difx > 0 ? "right" : "left";
                        }
                        else {
                            first._direction = first.direction = dify > 0 ? "bottom" : "top";
                        }
                    }
                    prev = first;
                    segments.push(first);
                }
                this.selectedObject.segments = segments.concat(this.selectedObject.segments);
                this.selectedSegment = this.selectedObject.segments[Number(coll[1])];
                this.nextSegment = this.selectedObject.segments[Number(coll[1]) + 1];
            }
            else {
                var segment = this.selectedObject.segments[0];
                var segments = [];
                segments.push(ej.datavisualization.Diagram.Segment({ type: "orthogonal", "direction": segment.direction, length: segment.length / 3 }));
                if (segment.direction == "bottom" || segment.direction == "top") {
                    var length = Math.max(5, Math.abs(difx));
                    var direction = difx > 0 ? "right" : "left";
                }
                else {
                    var length = Math.max(5, Math.abs(dify));
                    var direction = dify > 0 ? "bottom" : "top";
                }
                segments.push(ej.datavisualization.Diagram.Segment({ type: "orthogonal", "direction": direction, length: length }));
                var nextseg = this.selectedObject.segments[1];
                if (nextseg && nextseg.length) {
                    if (direction != nextseg.direction) {
                        length *= -1;
                    }
                    nextseg.length -= length;
                    nextseg._length = nextseg.length;
                }
                segment.length = segment._length = 2 * segment._length / 3;
                this.selectedObject.segments = segments.concat(this.selectedObject.segments);
                var index = Number(coll[0]) + Number(coll[1]);
                this.selectedSegment = this.selectedObject.segments[2];
                this.nextSegment = this.selectedObject.segments[3];
            }
        },
        ConnectionEditTool.prototype.updatePreviousSegment = function (current, prev, difx, dify) {
            prev._endPoint = prev.points[prev.points.length - 1] = current._startPoint;
            var direction = current.type == "orthogonal" && !current.direction ? ej.datavisualization.Diagram.Util._getBezierDirection(current._startPoint, current._endPoint) : current.direction;
            if (prev.type == "orthogonal") {
                if (direction == "left" || direction == "right") {
                    if (prev.direction == "bottom") {
                        prev.length += dify;
                        if (prev.length < 0) {
                            prev._direction = prev.direction = "top";
                            prev.length *= -1;
                        }
                    }
                    else {
                        prev.length -= dify;
                        if (prev.length < 0) {
                            prev._direction = prev.direction = "bottom";
                            prev.length *= -1;
                        }
                    }
                    prev._length = prev.length;
                }
                else {
                    if (prev) {
                        if (prev.direction == "right") {
                            prev.length += difx
                            if (prev.length < 0) {
                                prev._direction = prev.direction = "left";
                                prev.length *= -1;
                            }
                        }
                        else {
                            prev.length -= difx;
                            if (prev.length < 0) {
                                prev._direction = prev.direction = "right";
                                prev.length *= -1;
                            }
                        }
                        prev._length = prev.length;
                    }
                }
            }
            else {
                if (prev.type == "bezier") {
                    ej.datavisualization.Diagram.Util._updateBezierPoints(prev);
                }
            }

        };
        ConnectionEditTool.prototype.updateNextSegment = function (current, next, difx, dify) {
            var pt = current._endPoint;
            next._startPoint = next.points[0] = this.selectedSegment._endPoint;
            if (next) {
                if (next.type == "orthogonal") {
                    if (next.length || next.length === 0) {
                        if (next._direction == "left" || next._direction == "right") {
                            if (difx != 0) {
                                if (next._direction == "right") {
                                    next._length -= difx;
                                }
                                else {
                                    next._length += difx;
                                }

                                if (next.length || next.length === 0) {
                                    next.length = next._length;
                                    if (next.length < 0) {
                                        if (next.direction == "left") next.direction = "right";
                                        else if (next.direction == "right") next.direction = "left";
                                        next.length *= -1;
                                        next._direction = next.direction;
                                        next._length = next.length;
                                    }
                                }

                            }
                            if (dify != 0) {
                                if (current.type != "orthogonal") {
                                    next._startPoint.y = next.points[0].y = next._endPoint.y = next.points[next.points.length - 1].y = pt.y;
                                    var index = this.selectedObject.segments.indexOf(next);
                                    var segment = this.selectedObject.segments[index + 1];
                                    segment._startPoint.y = segment.points[0].y = next._endPoint.y;
                                    if (segment.length) {
                                        if (segment.direction == "bottom") {
                                            segment.length -= dify;
                                            if (segment.length < 0) {
                                                segment.direction = "top";
                                                segment.length *= -1;
                                            }
                                        }
                                        else {
                                            segment.length += dify;
                                            if (segment.length < 0) {
                                                segment.direction = "bottom";
                                                segment.length *= -1;
                                            }
                                        }
                                    }
                                }
                            }

                        }
                        else {
                            if (dify != 0) {
                                if (next._direction == "bottom") {
                                    next._length -= dify;
                                }
                                else {
                                    next._length += dify;
                                }

                                if (next.length || next.length === 0) {
                                    next.length = next._length;
                                    if (next.length < 0) {
                                        if (next.direction == "top") next.direction = "bottom";
                                        else if (next.direction == "bottom") next.direction = "top";
                                        next.length *= -1;
                                        next._length = next.length;
                                        next._direction = next.direction;
                                    }
                                }

                            }
                            if (difx != 0) {
                                if (current.type != "orthogonal") {
                                    next._startPoint.x = next.points[0].x = next._endPoint.x = next.points[next.points.length - 1].x = pt.x;
                                    var index = this.selectedObject.segments.indexOf(next);
                                    var segment = this.selectedObject.segments[index + 1];
                                    if (segment.length) {
                                        if (segment.direction == "right") {
                                            segment.length += difx;
                                            if (segment.length < 0) {
                                                segment.direction = "left";
                                                segment.length *= -1;
                                            }
                                        }
                                        else {
                                            segment.length -= difx;
                                            if (segment.length < 0) {
                                                segment.direction = "right";
                                                segment.length *= -1;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    }
                }
                else {

                    if (next.type == "bezier")
                        ej.datavisualization.Diagram.Util._updateBezierPoints(next);
                }
            }
        };
        ConnectionEditTool.prototype.mouseup = function (evt) {
            if (evt.shiftKey && evt.ctrlKey) {
                this._addOrRemoveStraightSegments(evt);
            }
            else
                if (this.inAction) {
                    this.inAction = false;
                    if (this._endPoint == "segmentEnd" && this.selectedSegment.type == "orthogonal") {
                        var index = this.selectedObject.segments.indexOf(this.selectedSegment);
                        var prev = this.selectedObject.segments[index - 1];
                        var next = this.selectedObject.segments[index + 1];
                        var refresh = false;
                        if (prev && prev.type == "orthogonal" && Math.abs(prev.length) < 5) {
                            if (index != 1) {
                                refresh = this._removePrevSegment(index);
                            }
                        }
                        else if (next && next.type == "orthogonal") {
                            var length = (next.length || next.length === 0) ? next.length : ej.datavisualization.Diagram.Geometry.distance(next.points[0], next.points[1]);
                            if (Math.abs(length <= 5)) {
                                refresh = this._removeNextSegment(index);
                            }
                        }
                        if (refresh) {
                            ej.datavisualization.Diagram.Util._updateConnectorSegments(this.selectedObject, this.selectedObject.sourcePort, this.selectedObject.targetPort, this.diagram);
                            ej.datavisualization.Diagram.DiagramContext._refreshSegments(this.selectedObject, this.diagram);
                            ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.diagram.selectionList[0], this.diagram._svg, this.diagram._currZoom);
                        }
                    }
                    else if (this._endPoint != "segmentEnd") {
                        this._updatePoints(this.selectedObject);
                        this._disconnect(this.selectedObject);
                        var args;
                        if (this._currentPossibleConnection && !this.inAction) {
                            this._updateConnection(this.selectedObject);
                        }
                        else {
                            if (this.selectedObject.sourceNode || this.selectedObject.targetNode) {
                                this._updateConnection(this.selectedObject);
                            }
                        }
                        ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                        if (this.selectedObject.parent)
                            ej.datavisualization.Diagram.Util._updateGroupBounds(this.diagram.nameTable[this.selectedObject.parent], this.diagram);
                    }

                    ej.datavisualization.Diagram.Util.updateBridging(this.selectedObject, this.diagram);
                    ej.datavisualization.Diagram.SvgContext.update(this.selectedObject, this.diagram);
                    this.diagram._updateConnectorBridging(this.selectedObject);
                    this.diagram._updateSelectionHandle();

                    if (this.selectedObject) {
                        (this.diagram._svg.getElementById(this.selectedObject.name + "_hitTest")).style["pointer-events"] = "";
                        (this.diagram._svg.getElementById(this.selectedObject.name)).style["pointer-events"] = "";
                    }
                    (this.diagram._svg.getElementById(this.diagram._svg.document.id + "handle_g")).style["pointer-events"] = "";
                }
            if (this.selectedObject) {
                var entry = { type: "endpointchanged", undoObject: this.undoObject, redoObject: this._getClonedObject(this.selectedObject), isMultipleNode: this.selectedObject.type = "group" ? true : false };
                this.diagram.addHistoryEntry(entry);
            }
            base.prototype.mouseup.call(this, evt);
        };
        ConnectionEditTool.prototype._addOrRemoveStraightSegments = function (evt) {
            if (this._endPoint == "segmentEnd") {
                var targetid = evt.target.id;
                var coll = targetid.split("_");
                coll.reverse();
                var index = Number(coll[0]);
                var segment = this.selectedObject.segments[index];
                if (segment && segment.type == "straight") {
                    var prevseg = this.selectedObject.segments[index + 1];
                    if (prevseg) {
                        this.selectedObject.segments.splice(index, 1);
                        prevseg._startPoint = prevseg.points[0] = segment._startPoint;
                        update = true;
                    }
                }
            }
            else {
                var className = evt.target.getAttribute("class");
                var targetid = evt.target.id;
                var update = false;
                var index = this._findIndex();
                if (this.selectedObject.segments && this.selectedObject.segments[index] && this.selectedObject.segments[index].type == "straight") {
                    var segment = this.selectedObject.segments[index];
                    var newseg = ej.datavisualization.Diagram.Segment({ type: "straight", point: segment._endPoint });
                    this.selectedObject.segments.splice(index + 1, 0, newseg);
                    segment._point = segment.point = segment.points[1] = segment._endPoint = this.currentPoint;
                    newseg.points[0] = newseg._startPoint = this.currentPoint;
                    newseg.points[1] = newseg._endPoint = newseg.point;
                    update = true;
                }
            }
            if (update) {
                ej.datavisualization.Diagram.Util._updateConnectorSegments(this.selectedObject, this.selectedObject.sourcePort, this.selectedObject.targetPort, this.diagram);
                ej.datavisualization.Diagram.Util.updateBridging(this.selectedObject, this.diagram);
                ej.datavisualization.Diagram.DiagramContext._refreshSegments(this.selectedObject, this.diagram);
                //ej.datavisualization.Diagram.SvgContext.clearSelector(this.diagram._svg, this.diagram._adornerLayer);
                ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.diagram.selectionList[0], this.diagram._svg, this.diagram._currZoom);
            }
        };
        ConnectionEditTool.prototype._findIndex = function () {
            var intersectingSegs = [];
            for (var i = 0; i < this.selectedObject.segments.length; i++) {
                var segment = this.selectedObject.segments[i];
                var rect;
                rect = {
                    x: Math.min(segment._startPoint.x, segment._endPoint.x), y: Math.min(segment._startPoint.y, segment._endPoint.y),
                    width: Math.abs(segment._startPoint.x - segment._endPoint.x), height: Math.abs(segment._startPoint.y - segment._endPoint.y)
                };
                ej.datavisualization.Diagram.Geometry.inflate(rect, this.selectedObject.lineHitPadding / 2, this.selectedObject.lineHitPadding / 2);
                if (ej.datavisualization.Diagram.Geometry.containsPoint(rect, this.currentPoint)) {
                    intersectingSegs.push(segment);
                }
            }
            if (intersectingSegs.length == 1) {
                return this.selectedObject.segments.indexOf(intersectingSegs[0]);
            }
            else {
                var ratio, min, index, seg, v, h;
                for (var i = 0; i < intersectingSegs.length; i++) {
                    seg = intersectingSegs[i];
                    var point = this.currentPoint;
                    v = (point.y - seg._startPoint.y) / (seg._endPoint.y - point.y);
                    h = (point.x - seg._startPoint.x) / (seg._endPoint.x - point.x);
                    ratio = Math.abs(v - h);
                    if (i == 0) { min = ratio; index = 0; }
                    if (ratio < min) { min = ratio; index = i; }
                }
                return this.selectedObject.segments.indexOf(intersectingSegs[index]);
            }
        }
        ConnectionEditTool.prototype._removeNextSegment = function (index) {
            var first = this.selectedObject.segments[index - 1];
            var last = this.selectedObject.segments[index + 2];
            var next = this.selectedObject.segments[index + 1];
            if (next.length || next.length === 0) {
                this.selectedObject.segments.splice(index, 2);
                if (this.selectedSegment.direction == "top" || this.selectedSegment.direction == "bottom") {
                    last._startPoint.y = this.selectedSegment._startPoint.y;
                    first._endPoint.x = last._startPoint.x;
                }
                else {
                    last._startPoint.x = this.selectedSegment._startPoint.x;
                    first._endPoint.y = last._startPoint.y;
                }
            }
            else {
                this.selectedObject.segments.splice(index + 1, 1);
                if (this.selectedSegment.direction == "top" || this.selectedSegment.direction == "bottom") {
                    first._endPoint.x = next._endPoint.x;
                }
                else {
                    first._endPoint.y = next._endPoint.y;
                }
                first._length = first.length = ej.datavisualization.Diagram.Geometry.distance(first._startPoint, first._endPoint);
                if (first.length)
                    first._direction = first.direction = ej.datavisualization.Diagram.Util._getBezierDirection(first._startPoint, first._endPoint);
                this.selectedSegment.length = this.selectedSegment._length = this.selectedSegment.direction = null;
            }

            if (first && last) {
                first._length = first.length = ej.datavisualization.Diagram.Geometry.distance(first._startPoint, last._startPoint);
                if (first.length)
                    first._direction = first.direction = ej.datavisualization.Diagram.Util._getBezierDirection(first._startPoint, last._startPoint);
                if (last.length || last.length === 0) {
                    last._length = last.length = ej.datavisualization.Diagram.Geometry.distance(first._endPoint, last._endPoint);
                    if (last.length)
                        last._direction = last.direction = ej.datavisualization.Diagram.Util._getBezierDirection(first._endPoint, last._endPoint);
                }
            }
            return true;
        },
        ConnectionEditTool.prototype._removePrevSegment = function (index) {
            var first = this.selectedObject.segments[index - 2];
            var next = this.selectedObject.segments[index + 1];
            var length = (next.length || next.length === 0) ? next.length : ej.datavisualization.Diagram.Geometry.distance(next.points[0], next.points[1]);
            if (length <= 5) {
                var end = this.selectedObject.segments[index + 2];
                if (next.length === length)
                    this.selectedObject.segments.splice(index - 1, 4);
                else
                    this.selectedObject.segments.splice(index - 1, 3);
                if (end) {
                    if (first.direction == "top" || first.direction == "bottom") {
                        first._endPoint.y = end._endPoint.y;
                        end._startPoint.x = first._endPoint.x;
                    }
                    else {
                        first._endPoint.x = end._endPoint.x;
                        end._startPoint.y = first._endPoint.y;
                    }
                    if (first.length || first.length === 0) {
                        first._length = first.length = ej.datavisualization.Diagram.Geometry.distance(first._startPoint, first._endPoint);
                        if (first.length)
                            first._direction = first.direction = ej.datavisualization.Diagram.Util._getBezierDirection(first._startPoint, first._endPoint);
                    }
                    if (end.length || end.length === 0) {
                        end._length = end.length = ej.datavisualization.Diagram.Geometry.distance(end._startPoint, end._endPoint);
                        if (end._length)
                            end._direction = end.direction = ej.datavisualization.Diagram.Util._getBezierDirection(end._startPoint, end._endPoint);
                    }
                }
                else {
                    first._endPoint = this.selectedObject.endPoint;
                    first.direction = first.length = first._length = null;
                    first._direction = next._direction;
                }
            }
            else {

                var last = this.selectedObject.segments[index + 1];
                this.selectedObject.segments.splice(index - 1, 2);
                var segment = this.selectedSegment;
                if (segment.direction == "left" || segment.direction == "right") {
                    first._endPoint.x = last._startPoint.x;
                    last._startPoint.y = first._endPoint.y;
                }
                else {
                    first._endPoint.y = last._startPoint.y;
                    last._startPoint.x = first._endPoint.x;
                }
                if (this.selectedSegment.length || this.selectedSegment.length === 0) {
                    first._length = first.length = ej.datavisualization.Diagram.Geometry.distance(first._startPoint, first._endPoint);
                    if (first._length)
                        first._direction = first.direction = ej.datavisualization.Diagram.Util._getBezierDirection(first._startPoint, first._endPoint);
                }
                if (last.length || last.length === 0) {
                    last._length = last.length = ej.datavisualization.Diagram.Geometry.distance(last._startPoint, last._endPoint);
                    if (last.length)
                        last._direction = last.direction = ej.datavisualization.Diagram.Util._getBezierDirection(last._startPoint, last._endPoint);
                }
            }

            return true;
        },
        ConnectionEditTool.prototype._getClonedObject = function (connector) {
            if (connector) {
                var clonedObject = $.extend(true, {}, connector);
                clonedObject.targetNode = connector.targetNode;
                clonedObject.sourceNode = connector.sourceNode;
                clonedObject.targetPort = connector.targetPort;
                clonedObject.sourcePort = connector.sourcePort;
                return clonedObject;
            }
        };
        ConnectionEditTool.prototype._updateConnection = function (connector, updateSelection) {
            var connectionChange;
            if (this._endPoint == "targetEndPoint") {
                if (this._currentPossibleConnection) {
                    if (this._possibleConnectionPort && ej.datavisualization.Diagram.Util.canConnect(this._possibleConnectionPort, true)) {
                        if (connector.targetNode != this._currentPossibleConnection.name || connector.targetPort != this._possibleConnectionPort.name) {
                            connectionChange = this._raiseConnectionChangeEvent(connector, true);
                        }
                    }
                    else if (ej.datavisualization.Diagram.Util.canConnect(this._currentPossibleConnection)) {
                        if (connector.targetNode != this._currentPossibleConnection.name || connector.targetPort) {
                            connectionChange = this._raiseConnectionChangeEvent(connector, true);
                        }
                    }
                }
                else {
                    if (this.selectedObject.targetNode) {
                        connectionChange = this._raiseConnectionChangeEvent(connector, true);
                    }
                }
                if (connectionChange) {
                    ej.datavisualization.Diagram.Util._updateConnectorSegments(this.selectedObject, this.selectedObject.sourcePort, this.selectedObject.targetPort, this.diagram);
                    ej.datavisualization.Diagram.DiagramContext._refreshSegments(this.selectedObject, this.diagram);
                    if (connector.segments.length > 2 || connector.segments[0].points.length == 2)
                        ej.datavisualization.Diagram.Util._updatePreviousSegment(connector);
                    ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.diagram.selectionList[0], this.diagram._svg, this.diagram.model.zoomFactor);
                }
            }
            else if (this._endPoint == "sourceEndPoint") {
                if (this._currentPossibleConnection) {
                    if (this._possibleConnectionPort && ej.datavisualization.Diagram.Util.canConnect(this._possibleConnectionPort, true)) {
                        if (connector.sourceNode != this._currentPossibleConnection.name || connector.sourcePort != this._possibleConnectionPort.name) {
                            connectionChange = this._raiseConnectionChangeEvent(connector);
                        }
                    }
                    else if (ej.datavisualization.Diagram.Util.canConnect(this._currentPossibleConnection)) {
                        if (connector.sourceNode != this._currentPossibleConnection.name || connector.sourcePort) {
                            connectionChange = this._raiseConnectionChangeEvent(connector);
                        }
                    }

                }
                else {
                    if (this.selectedObject.sourceNode) {
                        connectionChange = this._raiseConnectionChangeEvent(connector);
                        //if (connectionChange)
                        {
                            ej.datavisualization.Diagram.Util._updateConnectorSegments(this.selectedObject, this.selectedObject.sourcePort, this.selectedObject.targetPort, this.diagram);
                            ej.datavisualization.Diagram.DiagramContext._refreshSegments(this.selectedObject, this.diagram);

                        }
                    }
                    if (connectionChange) {
                        ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.diagram.selectionList[0], this.diagram._svg, this.diagram.model.zoomFactor);
                    }
                }

            }

            var endPoint = this.selectedSegment._endPoint;
            this.diagram._dock(connector, this.diagram.nameTable, updateSelection);
            if (connectionChange && this._endPoint == "sourceEndPoint" && this.selectedObject.segments.length > 1) {
                if (this.selectedSegment.points.length == 2 && !this.selectedObject.sourcePort && this.selectedSegment.length) {
                    if (this.selectedSegment.direction == "right" || this.selectedSegment.direction == "left") {
                        if (this.selectedSegment._startPoint.x < endPoint.x) {
                            this.selectedSegment.direction = this.selectedSegment._direction = "right";
                        }
                        else this.selectedSegment.direction = this.selectedSegment._direction = "left";
                        this.selectedSegment.length = this.selectedSegment._length = Math.abs(this.selectedSegment._startPoint.x - endPoint.x);
                    }
                    else {
                        if (this.selectedSegment._startPoint.y < endPoint.y) {
                            this.selectedSegment.direction = this.selectedSegment._direction = "bottom";
                        }
                        else this.selectedSegment.direction = this.selectedSegment._direction = "top";
                        this.selectedSegment.length = this.selectedSegment._length = Math.abs(this.selectedSegment._startPoint.y - endPoint.y);

                    }
                    ej.datavisualization.Diagram.Util._updateConnectorSegments(this.selectedObject, this.selectedObject.sourcePort, this.selectedObject.targetPort, this.diagram);
                    ej.datavisualization.Diagram.DiagramContext._refreshSegments(this.selectedObject, this.diagram);
                    ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.diagram.selectionList[0], this.diagram._svg, this.diagram.model.zoomFactor);
                }
                else {
                    if (connectionChange) {
                        ej.datavisualization.Diagram.Util._updateConnectorSegments(this.selectedObject, this.selectedObject.sourcePort, this.selectedObject.targetPort, this.diagram);
                        ej.datavisualization.Diagram.DiagramContext._refreshSegments(this.selectedObject, this.diagram);
                        ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.diagram.selectionList[0], this.diagram._svg, this.diagram.model.zoomFactor);
                    }
                }
            }
        };
        ConnectionEditTool.prototype._raiseConnectionChangeEvent = function (connector, isTarget) {
            var args = this._raiseEvent("connectionChange", { element: this.selectedObject, endPoint: this._endPoint, connection: this._currentPossibleConnection, port: this._possibleConnectionPort, cancel: false });
            if (!args.cancel) {
                if (isTarget) {
                    if (!this._currentPossibleConnection || connector.targetNode != this._currentPossibleConnection.name) {
                        if (this._currentPossibleConnection)
                            this._currentPossibleConnection.inEdges.push(connector.name);
                        if (connector.targetNode) {
                            var node = this.diagram.nameTable[this.selectedObject.targetNode];
                            ej.datavisualization.Diagram.Util.removeItem(node.inEdges, connector.name);
                        }
                    }
                    connector.targetNode = this._currentPossibleConnection ? this._currentPossibleConnection.name : null;
                    connector.targetPort = this._possibleConnectionPort ? this._possibleConnectionPort.name : null;
                }
                else {
                    if (!this._currentPossibleConnection || connector.sourceNode != this._currentPossibleConnection.name) {
                        if (this._currentPossibleConnection)
                            this._currentPossibleConnection.outEdges.push(connector.name);
                        if (connector.sourceNode) {
                            var node = this.diagram.nameTable[this.selectedObject.sourceNode];
                            ej.datavisualization.Diagram.Util.removeItem(node.outEdges, connector.name);
                        }
                    }
                    connector.sourceNode = this._currentPossibleConnection ? this._currentPossibleConnection.name : null;
                    connector.sourcePort = this._possibleConnectionPort ? this._possibleConnectionPort.name : null;
                }

                return true;
            }
        }
        ConnectionEditTool.prototype._disconnect = function (connector) {
            var args;
            //var node = this.diagram.nameTable[connector.targetNode];
            var port = null;
            //if (this._endPoint == "targetEndPoint" && node) {
            //    port = ej.datavisualization.Diagram.Util.findPortByName(node, connector.targetPort);
            //    args = this._raiseEvent("connectionChange", { element: connector, endPoint: this._endPoint, connection: node, port: port, cancel: false });
            //    if (!args.cancel) {
            //        ej.datavisualization.Diagram.Util.removeItem(node.inEdges, connector.name);
            //        connector.targetNode = null;
            //        connector.targetPort = null;
            //    }

            //}
            //var node = this.diagram.nameTable[connector.sourceNode];
            //if ((this._endPoint == "sourceEndPoint") && node) {
            //    port = ej.datavisualization.Diagram.Util.findPortByName(node, connector.sourcePort);
            //    args = this._raiseEvent("connectionChange", { element: connector, endPoint: this._endPoint, connection: node, port: port, cancel: false });
            //    if (!args.cancel) {
            //        ej.datavisualization.Diagram.Util.removeItem(node.outEdges, connector.name);
            //        connector.sourceNode = null;
            //        connector.sourcePort = null;
            //    }
            //}
        };
        ConnectionEditTool.prototype._endAction = function () {
            this._showPorts();
            var possibleConnection;
            if (this._currentPossibleConnection && !this._possibleConnectionPort) {
                possibleConnection = this._currentPossibleConnection;
            }
            base.prototype._endAction.apply(this);
            if (this._endPoint) {
                this._endPoint = null;
                if (possibleConnection) {
                    this.diagram._checkToolToActivate(possibleConnection, this.currentPoint);
                    this.diagram._updateCursor();
                }
            }
        };
        ConnectionEditTool.prototype._updatePoints = function (connector) {
            if (this._endPoint != "segmentEnd") {
                var isTarget = (this._endPoint == "targetEndPoint") ? true : false;
                var isSource = (this._endPoint == "sourceEndPoint") ? true : false;

                var endPoint;
                if (this._endPoint) {
                    var end = this._endPoint.match("bezierpoint1") ? "bezierpoint1" : this._endPoint.match("bezierpoint2") ? "bezierpoint2" : this._endPoint;;

                    switch (end) {
                        case "targetEndPoint":
                            endPoint = this.selectedSegment._endPoint;
                            break;
                        case "sourceEndPoint":
                            endPoint = this.selectedSegment._startPoint;
                            break;
                        case "bezierpoint1":
                            endPoint = this.selectedSegment._point1;
                            break;
                        case "bezierpoint2":
                            endPoint = this.selectedSegment._point2;
                            break;
                    }

                    var ptCur = this.currentPoint;
                    if (this._possibleConnectionPort == null) {
                        ptCur = this.snap(ptCur);
                    }
                    var offset = ej.datavisualization.Diagram.Point(endPoint.x - ptCur.x, endPoint.y - ptCur.y);
                    if (!ej.datavisualization.Diagram.Geometry.isEmptyPoint(offset)) {
                        var cancel = false;
                        var args;
                        var type = null;
                        if (!this.inAction) {
                            if (isTarget) {
                                type = "target";
                            }
                            else if (isSource) {
                                type = "source";
                            }
                            args = this._raiseEvent("drag", { end: type, element: this.selectedObject, cancel: false });
                            cancel = args.cancel;
                        }
                        if (!cancel) {
                            if (isTarget || isSource) {
                                var connected = this._currentPossibleConnection ? ej.datavisualization.Diagram.Util.canConnect(this._currentPossibleConnection, false) : false;
                                if (this.selectedObject.segments.length > 1) {
                                    if (!isTarget && !connected && this.selectedSegment.type == "orthogonal" && (this.selectedSegment.length || this.selectedSegment.length === 0)) {
                                        this.selectedObject.sourcePoint = ptCur;
                                        var difx = ptCur.x - this.selectedSegment._startPoint.x;
                                        var dify = ptCur.y - this.selectedSegment._startPoint.y;
                                        if (this.selectedSegment.direction == "left" || this.selectedSegment.direction == "right") {
                                            this.selectedSegment._endPoint.y = this.selectedSegment.points[this.selectedSegment.points.length - 1].y = ptCur.y;
                                        }
                                        else {
                                            this.selectedSegment._endPoint.x = this.selectedSegment.points[this.selectedSegment.points.length - 1].x = ptCur.x;
                                        }
                                        this.selectedSegment._startPoint = this.selectedSegment.points[0] = ptCur;
                                        this.selectedSegment._length = this.selectedSegment.length = ej.datavisualization.Diagram.Geometry.distance(ptCur, this.selectedSegment._endPoint);
                                        if (this.selectedSegment._length)
                                            this.selectedSegment._direction = this.selectedSegment.direction = ej.datavisualization.Diagram.Util._getBezierDirection(ptCur, this.selectedSegment._endPoint);

                                        this.updateNextSegment(this.selectedObject.segments[0], this.selectedObject.segments[1], difx,
                                            dify);
                                        var next = this.selectedObject.segments[1];
                                        var updated = false;
                                        if (next && (next.length)) {
                                            next.length = next._length = ej.datavisualization.Diagram.Geometry.distance(this.selectedSegment._endPoint, next._endPoint);
                                            if (next.length)
                                                next.direction = next._direction = ej.datavisualization.Diagram.Util._getBezierDirection(this.selectedSegment._endPoint, next._endPoint);
                                        }
                                        if (this.selectedSegment.length == 0 || next.length === 0) {
                                            if (next.length == 0 && this.selectedObject.segments.length > 2) {
                                                this.selectedObject.segments.splice(0, 2);
                                            }
                                            else if (this.selectedObject.segments.length > 1) {
                                                this.selectedObject.segments.splice(0, 1);
                                            }
                                            this.selectedSegment = this.selectedObject.segments[0];
                                            this.selectedSegment._startPoint = this.selectedSegment.points[0] = ptCur;
                                            if (this.selectedSegment._direction == "left" || this.selectedSegment._direction == "right") {
                                                this.selectedSegment._endPoint.y = this.selectedSegment.points[this.selectedSegment.points.length - 1].y = ptCur.y;
                                            }
                                            else {
                                                this.selectedSegment._endPoint.x = this.selectedSegment.points[this.selectedSegment.points.length - 1].x = ptCur.x;
                                            }

                                            var next = this.selectedObject.segments[1];
                                            if (this.selectedObject.segments.length > 1) {
                                                this.selectedSegment._length = this.selectedSegment.length = ej.datavisualization.Diagram.Geometry.distance(ptCur, next._startPoint);
                                                ej.datavisualization.Diagram.Util._addOrthogonalPoints(this.selectedSegment, null, connector.segments[1], connector.sourcePoint, connector.targetPoint);
                                                ej.datavisualization.Diagram.Util._addOrthogonalPoints(connector.segments[1], connector.segments[0], connector.segments[2], connector.sourcePoint, connector.targetPoint);
                                                next._startPoint = next.points[0] = connector.segments[0]._endPoint;
                                            }
                                            else ej.datavisualization.Diagram.Util._addOrthogonalPoints(this.selectedSegment, null, connector.segments[1], connector.sourcePoint, connector.targetPoint);

                                            updated = true;
                                        }
                                        else ej.datavisualization.Diagram.Util._addOrthogonalPoints(this.selectedSegment, null, connector.segments[1], connector.sourcePoint, connector.targetPoint);
                                        if (next && (next.length)) {
                                            next.length = next._length = ej.datavisualization.Diagram.Geometry.distance(this.selectedSegment._endPoint, next._endPoint);
                                            if (next.length)
                                                next.direction = next._direction = ej.datavisualization.Diagram.Util._getBezierDirection(this.selectedSegment._endPoint, next._endPoint);
                                        }
                                    }
                                    else if (isTarget && !connected && this.selectedSegment.type == "orthogonal" && this.selectedSegment.points.length == 2) {
                                        var difx = ptCur.x - this.selectedSegment._endPoint.x;
                                        var dify = ptCur.y - this.selectedSegment._endPoint.y;

                                        if (this.selectedSegment._direction == "left" || this.selectedSegment._direction == "right") {
                                            this.selectedSegment._startPoint.y = (this.selectedSegment.points[0].y += dify);
                                            this.selectedSegment._endPoint.y = this.selectedSegment.points[1].y = this.selectedSegment._startPoint.y;
                                        }
                                        else {
                                            this.selectedSegment._startPoint.x = (this.selectedSegment.points[0].x += difx);
                                            this.selectedSegment._endPoint.x = this.selectedSegment.points[1].x = this.selectedSegment._startPoint.x;
                                        }
                                        var index = this.selectedObject.segments.length - 1;
                                        if (this.selectedObject.segments[index - 1])
                                            this.updatePreviousSegment(this.selectedObject.segments[index], this.selectedObject.segments[index - 1], difx,
                                                dify);
                                    }
                                }
                                if ((isSource || isTarget) && !connected) {
                                    var srclength = this.selectedSegment.points.length;
                                    this.diagram._setEndPoint(connector, ej.datavisualization.Diagram.Point(ptCur.x, ptCur.y), isTarget);
                                    if (srclength != this.selectedSegment.points.length || updated) {
                                        return true;
                                    }
                                }
                            }
                            else
                                ej.datavisualization.Diagram.Util._setBezierPoint(this.selectedSegment, ej.datavisualization.Diagram.Point(ptCur.x, ptCur.y), end);
                        }
                    }
                }
            }
        };
        return ConnectionEditTool;
    })(ToolBase);

    ej.datavisualization.Diagram.ConnectionEditTool = ConnectionEditTool;
    //#endregion

    //#region LineTool
    var LineTool = (function (base) {
        ej.datavisualization.Diagram.extend(LineTool, base);
        function LineTool(name, diagram) {
            base.call(this, name, diagram);
            this.cursor = "crosshair";
            this._isMouseDown = false;
            this._targetPossibleConnection = null;
            this._sourcePossibleConnection = null;
            this._targetPort = null;
            this._sourcePort = null;
        }
        LineTool.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            this._isMouseDown = true;
            if (this.diagram._hasSelection()) {
                this.diagram._clearSelection();
            }
            if (this._currentPossibleConnection) {
                this._sourcePossibleConnection = this._currentPossibleConnection;
                this._sourcePort = this._possibleConnectionPort;
            }
        };
        LineTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            this._checkConnectionPossible(evt);
            if (this._isMouseDown) {
                if (!this.inAction) {
                    this.inAction = true;
                    this._initHelper();
                    this._renderHelper();
                }
                else {
                    this._targetPossibleConnection = this._currentPossibleConnection;
                    this._targetPort = this._possibleConnectionPort;
                    this._updateHelper();
                }
            }
            this.previousPoint = this.currentPoint;
        };
        LineTool.prototype.mouseup = function (evt) {
            this._isMouseDown = false;
            if (this.inAction) {
                this.inAction = false;
                var ptStart = this._getStartPoint();
                var ptEnd = this._getCurrentPoint();
                var distance = ej.datavisualization.Diagram.Geometry.distance(ptStart, ptEnd);
                if (distance > 0) {
                    var connector = this.createConnector(ptStart, ptEnd);
                    connector.name = "connector" + ej.datavisualization.Diagram.Util.randomId();
                    var args;
                    if (this._sourcePossibleConnection) {
                        if (this._sourcePort && ej.datavisualization.Diagram.Util.canConnect(this._sourcePort, true)) {
                            args = this._raiseEvent("connectionChange", { element: connector, connection: this._sourcePossibleConnection, port: this._sourcePort, cancel: false });
                            if (!args.cancel) {
                                connector.sourceNode = this._sourcePossibleConnection.name;
                                connector.sourcePort = this._sourcePort.name;
                                ej.datavisualization.Diagram.Util.removeItem(this._sourcePossibleConnection.outEdges, this.helper.name);
                            }
                        }
                        else if (ej.datavisualization.Diagram.Util.canConnect(this._sourcePossibleConnection)) {
                            args = this._raiseEvent("connectionChange", { element: connector, connection: this._sourcePossibleConnection, port: this._sourcePort, cancel: false });
                            if (!args.cancel) {
                                connector.sourceNode = this._sourcePossibleConnection.name;
                                ej.datavisualization.Diagram.Util.removeItem(this._sourcePossibleConnection.outEdges, this.helper.name);
                            }
                        }
                    }
                    if (this._targetPossibleConnection) {
                        if (this._targetPort && ej.datavisualization.Diagram.Util.canConnect(this._targetPort, true)) {
                            args = this._raiseEvent("connectionChange", { element: connector, connection: this._targetPossibleConnection, port: this._targetPort, cancel: false });
                            if (!args.cancel) {
                                connector.targetNode = this._targetPossibleConnection.name;
                                connector.targetPort = this._targetPort.name;
                                ej.datavisualization.Diagram.Util.removeItem(this._targetPossibleConnection.inEdges, this.helper.name);
                            }
                        }
                        else if (ej.datavisualization.Diagram.Util.canConnect(this._targetPossibleConnection)) {
                            args = this._raiseEvent("connectionChange", { element: connector, connection: this._targetPossibleConnection, port: this._targetPort, cancel: false });
                            if (!args.cancel) {
                                connector.targetNode = this._targetPossibleConnection.name;
                                ej.datavisualization.Diagram.Util.removeItem(this._targetPossibleConnection.inEdges, this.helper.name);
                            }
                        }

                    }
                    this.diagram.add(connector);
                    ej.datavisualization.Diagram.Util.updateBridging(connector, this.diagram);
                    ej.datavisualization.Diagram.SvgContext.update(connector, this.diagram);
                    this.diagram._updateConnectorBridging(connector);
                }
            }
            if (this.singleAction)
                this.diagram.deactivateTool();
            if (this._prevTool)
                this._prevTool.inAction = false;
            this._showPorts();
            base.prototype.mouseup.call(this, evt);
        };

        LineTool.prototype._getStartPoint = function () {
            var ptStart;
            if (this._sourcePossibleConnection && this._sourcePort) {
                ptStart = ej.datavisualization.Diagram.Util._getPortPosition(this._sourcePort, ej.datavisualization.Diagram.Util.bounds(this._sourcePossibleConnection));
            }
            else {
                ptStart = this.snap(this.startPoint);
            }
            return ptStart;
        };
        LineTool.prototype._getCurrentPoint = function () {
            var ptCur;
            if (this._targetPossibleConnection && this._targetPort) {
                ptCur = ej.datavisualization.Diagram.Util._getPortPosition(this._targetPort, ej.datavisualization.Diagram.Util.bounds(this._targetPossibleConnection));
            }
            else {
                ptCur = this.snap(this.currentPoint);
            }
            return ptCur;
        };
        LineTool.prototype._initHelper = function () {
            this.helper = this.createConnector(ej.datavisualization.Diagram.Point(0, 0), ej.datavisualization.Diagram.Point(0, 0));
            this.diagram._setZorder(this.helper);
            this.helper.name = "helper";
        };
        LineTool.prototype.createConnector = function (startPoint, endPoint) {
            return null;
        };
        LineTool.prototype._renderHelper = function () {
            if (!this.svgHelper) {
                this.svgHelper = ej.datavisualization.Diagram.SvgContext.renderConnector(this.helper, this.diagram._svg, this.diagram._diagramLayer);
                this.svgHelper = document.getElementById(this.helper.name);
                this.svgHelper.setAttribute("pointer-events", "none");
                $(this.diagram._svg.getElementById(this.svgHelper.id)).attr("pointer-events", "none");
                $(this.diagram._svg.getElementById(this.svgHelper.id + "_hitTest")).attr("pointer-events", "none");
            }
        };
        LineTool.prototype._updateHelper = function () {
            var points = [];
            var ptStart = this._getStartPoint();
            var ptEnd = this._getCurrentPoint();
            points.push(ptStart);
            points.push(ptEnd);
            this.diagram._setEndPoint(this.helper, ptStart, false);
            this.diagram._setEndPoint(this.helper, ptEnd, true);
            this._disconnect(this.helper);
            if (this._sourcePossibleConnection) {
                if (this._sourcePort && ej.datavisualization.Diagram.Util.canConnect(this._sourcePort, true)) {
                    this.helper.sourceNode = this._sourcePossibleConnection.name;
                    this.helper.sourcePort = this._sourcePort.name;
                    this._sourcePossibleConnection.outEdges.push(this.helper.name);
                }
                else if (ej.datavisualization.Diagram.Util.canConnect(this._sourcePossibleConnection)) {
                    this.helper.sourceNode = this._sourcePossibleConnection.name;
                    this._sourcePossibleConnection.outEdges.push(this.helper.name);
                }
            }
            if (this._targetPossibleConnection) {
                if (this._targetPort && ej.datavisualization.Diagram.Util.canConnect(this._targetPort, true)) {
                    this.helper.targetNode = this._targetPossibleConnection.name;
                    this.helper.targetPort = this._targetPort.name;
                    this._targetPossibleConnection.inEdges.push(this.helper.name);
                }
                else if (ej.datavisualization.Diagram.Util.canConnect(this._targetPossibleConnection)) {
                    this.helper.targetNode = this._targetPossibleConnection.name;
                    this._targetPossibleConnection.inEdges.push(this.helper.name);
                }
            }
            this.diagram._dock(this.helper, this.diagram.nameTable);

            ej.datavisualization.Diagram.SvgContext.update(this.helper, this.diagram);
        };
        LineTool.prototype._endAction = function () {
            base.prototype._endAction.apply(this);
            this._targetPossibleConnection = null;
            this._sourcePossibleConnection = null;
            this._targetPort = null;
            this._sourcePort = null;
            this._isMouseDown = false;
        };
        LineTool.prototype._showPorts = function (node) {
        };
        LineTool.prototype._showAllPorts = function (hide) {
            base.prototype._showAllPorts.call(this, hide);
        };
        return LineTool;
    })(ToolBase);

    ej.datavisualization.Diagram.LineTool = LineTool;
    //#endregion

    //#region StraightLineTool
    var StraightLineTool = (function (base) {
        ej.datavisualization.Diagram.extend(StraightLineTool, base);
        function StraightLineTool(diagram) {
            base.call(this, "straightLine", diagram);
        }
        StraightLineTool.prototype.createConnector = function (startPoint, endPoint) {
            var connector = this.diagram._getNewConnector({ "segments": [{ "type": "straight" }], "sourcePoint": startPoint, "targetPoint": endPoint });
            return connector;
        };
        return StraightLineTool;
    })(LineTool);

    ej.datavisualization.Diagram.StraightLineTool = StraightLineTool;
    //#endregion

    //#region OrthogonalLineTool
    var OrthogonalLineTool = (function (base) {
        ej.datavisualization.Diagram.extend(OrthogonalLineTool, base);
        function OrthogonalLineTool(diagram) {
            base.call(this, "orthogonalLine", diagram);
        }
        OrthogonalLineTool.prototype.createConnector = function (startPoint, endPoint) {
            var connector = this.diagram._getNewConnector({ "segments": [{ "type": "orthogonal" }], "sourcePoint": startPoint, "targetPoint": endPoint });
            return connector;
        };
        return OrthogonalLineTool;
    })(LineTool);

    ej.datavisualization.Diagram.OrthogonalLineTool = OrthogonalLineTool;
    //#endregion

    //#region RotateTool
    var RotateTool = (function (base) {
        ej.datavisualization.Diagram.extend(RotateTool, base);
        function RotateTool(diagram) {
            base.call(this, "rotatetool", diagram);
            this._mouseOffset = ej.datavisualization.Diagram.Size(0, 0);
            this.undoObject = null;
        }
        RotateTool.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            this.selectedObject = this.diagram.selectionList[0];
            //this.undoObject = ej.datavisualization.Diagram.Util.clone(this.selectedObject);

            var data;
            var childTable = {};
            if (this.selectedObject.type == "group" || this.selectedObject.type == "pseudoGroup")
                childTable = this.diagram._getChildTable(this.selectedObject, childTable);
            var temp = { "childTable": childTable, "node": this.selectedObject };
            data = $.extend(true, {}, temp);
            this.undoObject = jQuery.extend(true, {}, data);

            var scale = this.diagram._currZoom;
            //ej.datavisualization.Diagram.SvgContext.renderPivotPoint(this.selectedObject, this.diagram._currZoom, this.diagram._svg);

        };
        RotateTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);

            if (this.selectedObject) {
                if (!this.inAction) {
                    if (this.selectedObject.type == "group" || this.selectedObject.type == "pseudoGroup") {
                        var children = this.diagram._getChildren(this.selectedObject.children);
                        for (var i = 0; i < children.length; i++) {
                            var child = this.diagram.nameTable[children[i]];
                            if (!ej.datavisualization.Diagram.Util.canResize(child)) return;
                        }
                    }
                    this.inAction = true;
                }
                else {
                    var isContainer = false;
                    if (this.selectedObject.parent) {
                        var parent = this.diagram.nameTable[this.selectedObject.parent];
                        if (parent.container) {
                            isContainer = true;
                        }
                    }
                    else if (this.selectedObject.type == "pseudoGroup" && this.hasSameParent() && this._fromContainer(this.diagram._getChildren(this.selectedObject.children))) {
                        isContainer = true;
                    }
                    if (isContainer) {
                        if (!this.helper) {
                            this.helper = this._getCloneNode(this.selectedObject);
                            this.helper.name = "helper";
                        }
                        this._rotate(this.helper);
                        ej.datavisualization.Diagram.SvgContext._drawContainerHelper(this.diagram);
                    }

                    else {
                        if (this.selectedObject.type == "pseudoGroup" && this._fromContainer(this.diagram._getChildren(this.selectedObject.children))) {// && this._fromContainer(this.selectedObject.children) && this.hasSameParent()) {
                            if (this._fromContainer(this.diagram._getChildren(this.selectedObject.children)) && this.hasSameParent()) {
                                this._rotate(this.selectedObject);
                                if (this.selectedObject.parent) {
                                    ej.datavisualization.Diagram.Util._updateGroupBounds(this.diagram.nameTable[this.selectedObject.parent], this.diagram);
                                }
                                ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                                this.diagram._updateSelectionHandle(true);
                                this.diagram._renderTooltip(this.selectedObject);
                            }
                        }
                        else {
                            this._rotate(this.selectedObject);
                            if (this.selectedObject.parent) {
                                ej.datavisualization.Diagram.Util._updateGroupBounds(this.diagram.nameTable[this.selectedObject.parent], this.diagram);
                            }
                            ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                            this.diagram._updateSelectionHandle(true);
                            this.diagram._renderTooltip(this.selectedObject);
                        }
                    }
                }
            }
            this.previousPoint = this.currentPoint;
        };
        RotateTool.prototype._rotate = function (node) {
            var cancel = false;
            var args;
            if (!this.inAction) {
                args = this._raiseEvent("rotationChange", { element: node, cancel: false });
                cancel = args.cancel;
            }
            if (!cancel) {
                var pt = ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY);
                var crntpoint = this.currentPoint;
                var angle = ej.datavisualization.Diagram.Geometry.findAngle(ej.datavisualization.Diagram.Point(pt.x, pt.y), crntpoint) + 90;
                angle = ej.datavisualization.Diagram.SnapUtil._snapAngle(this.diagram, angle);
                this.diagram._rotate(node, angle - node.rotateAngle, this.diagram.nameTable);
            }
        };

        RotateTool.prototype._updateRotateObject = function () {
            var object = this.diagram.nameTable[this.selectedObject.name];
            ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
            if (this.helper) {
                var difAngle = this.helper.rotateAngle - this.diagram.nameTable[this.selectedObject.name].rotateAngle;
                //object.rotateAngle += difAngle;
                this.diagram._rotate(this.selectedObject, difAngle, this.diagram.nameTable);
                ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
            }
            return object;
        };
        //RotateTool.prototype._updateMargin = function (node, group) {
        //    if (node.type == "pseudoGroup") {
        //        var child = null;
        //        for (var i = 0; i < node.children.length; i++) {
        //            child = this.diagram.nameTable[node.children[i]];
        //            this._updateMargin(child, group);
        //        }
        //    }
        //    else if (group && group.container && group.container.type == "canvas") {
        //        var groupBounds = ej.datavisualization.Diagram.Util.bounds(group); //ej.datavisualization.Diagram.SvgContext.getCanvasBoundingBox(group, this.diagram, node, true);
        //        var bounds1 = ej.datavisualization.Diagram.Util.bounds(node);
        //        var bounds = ej.datavisualization.Diagram.Geometry.rect([bounds1.topLeft, bounds1.topRight, bounds1.bottomRight, bounds1.bottomLeft]);
        //        node.marginLeft = bounds.x - (groupBounds.x + group.paddingLeft);
        //        node.marginRight = (groupBounds.x + group.width) - (bounds.x + bounds.width) - group.paddingRight;
        //        node.marginTop = bounds.y - (groupBounds.y + group.paddingTop);
        //        node.marginBottom = groupBounds.bottom - (bounds.y + bounds.height) - group.paddingBottom;
        //    }
        //};
        RotateTool.prototype._updateContainer = function (newObj, prevParent, isDrop) {
            var bounds, groupBounds, dx = 0, dy = 0, newSize;
            if (newObj) {
                var parObj = this.diagram.nameTable[newObj.parent];
                if (!parObj && newObj.type == "pseudoGroup") {
                    var fNode = this.diagram.nameTable[this.diagram._getChild(this.selectedObject.children[0])];
                    parObj = this.diagram.nameTable[fNode.parent];
                }
                if (parObj) {
                    if (parObj.container.type == "canvas") {
                        if (isDrop) {
                            isDrop = false;
                            var group = this.diagram.nameTable[newObj.parent];
                            if (!group && newObj.type == "pseudoGroup") {
                                group = parObj;
                            }
                            var groupBounds123 = ej.datavisualization.Diagram.Util.bounds(group);
                            var grAngle = group.rotateAngle;
                            this.diagram._rotate(group, -group.rotateAngle, this.diagram.nameTable);
                            ej.datavisualization.Diagram.DiagramContext.update(group, this.diagram);
                            bounds = ej.datavisualization.Diagram.Util.bounds(newObj);
                            var bounds1 = ej.datavisualization.Diagram.Geometry.rect([bounds.topLeft, bounds.topRight, bounds.bottomRight, bounds.bottomLeft]);
                            groupBounds = ej.datavisualization.Diagram.Util.bounds(group);
                            var tightchildBounds = this.diagram._getTightChildrenBounds(group);
                            var right = true;
                            var bottom = true;
                            var bRight = bounds1.x + bounds1.width;
                            var bBottom = bounds1.y + bounds1.height;
                            if (bRight >= groupBounds.right) {
                                ///if exeeds right 
                                dx = bRight - groupBounds.right + group.paddingRight;
                                newSize = this.diagram._getMinMaxSize(group, (group.width + dx), group.height, true);
                                widDiff = newSize.width - group.width;
                                group.width = newSize.width;
                                group.offsetX += (widDiff / 2);
                                if (bRight < groupBounds.right) {
                                    right = false;
                                }
                            }
                            if (bBottom >= groupBounds.bottom) {
                                ///if exeeds bottom 
                                dy = bBottom - groupBounds.bottom + group.paddingBottom;
                                newSize = this.diagram._getMinMaxSize(group, (group.width), (group.height + dy), true);
                                heiDiff = newSize.height - group.height;
                                group.height = newSize.height;
                                group.offsetY += (heiDiff / 2);
                                bottom = true;
                                if (bBottom < groupBounds.bottom) {
                                    bottom = false;
                                }
                            }
                            if (bRight < groupBounds.right && right) { //if decreces from right
                                dx = (tightchildBounds.x + tightchildBounds.width) + group.paddingRight - groupBounds.right;
                                newSize = this.diagram._getMinMaxSize(group, (group.width + dx), group.height, true);
                                var widDiff = newSize.width - group.width;
                                group.width = newSize.width;
                                group.offsetX += (widDiff / 2);
                            }
                            if (bBottom < groupBounds.bottom && bottom) { //if decreces from bottom
                                dy = (tightchildBounds.y + tightchildBounds.height) + group.paddingBottom - groupBounds.bottom;
                                newSize = this.diagram._getMinMaxSize(group, (group.width), (group.height + dy), true);
                                var heiDiff = newSize.height - group.height;
                                group.height = newSize.height;
                                group.offsetY += (heiDiff / 2);
                            }
                            ej.datavisualization.Diagram.DiagramContext.update(group, this.diagram);
                            this._updateMargin(newObj, group);
                            ej.datavisualization.Diagram.SvgContext._alignOnCanvas1(group, this.diagram);
                            this.diagram._rotate(group, grAngle, this.diagram.nameTable);
                            var groupBounds1231 = ej.datavisualization.Diagram.Util.bounds(group);
                            this.diagram._translate(group, groupBounds123.topLeft.x - groupBounds1231.topLeft.x, groupBounds123.topLeft.y - groupBounds1231.topLeft.y, this.diagram.nameTable);
                            if (group.parent && group.container && group.container.type == "canvas")
                                this._updateMargin(group, this.diagram.nameTable[group.parent]);
                            ej.datavisualization.Diagram.DiagramContext.update(group, this.diagram);
                        } else {
                            var vertical = false;
                            var horizontal = false;
                            group = this.diagram.nameTable[newObj.parent];
                            if (newObj.container && newObj.container.type == "stack") {
                                if (newObj.container.orientation == "vertical")
                                    vertical = true;
                                else
                                    horizontal = true;
                            }
                            bounds = this.diagram._getBoundsWithoutStretch(group, vertical, horizontal); // ej.datavisualization.Diagram.SvgContext._measureStackSize(group, this.diagram, true);
                            bounds.width += group.paddingLeft + group.paddingRight;
                            bounds.height += group.paddingTop + group.paddingBottom;
                            newSize = this.diagram._getMinMaxSize(group, (bounds.width), (bounds.height), true);
                            widDif = newSize.width - group.width;
                            heiDif = newSize.height - group.height;
                            group.offsetX += (widDif / 2);
                            group.width = newSize.width;
                            group.offsetY += (heiDif / 2);
                            group.height = newSize.height;
                            ej.datavisualization.Diagram.SvgContext._alignOnCanvas1(group, this.diagram);
                            ej.datavisualization.Diagram.DiagramContext.update(group, this.diagram);
                        }
                        if (group.parent) {
                            if (this.diagram.nameTable[group.parent])
                                isDrop = true;
                            this._updateContainer(group, null, isDrop);
                        }
                    }
                    else if (parObj.container.type == "stack") {
                        group = this.diagram.nameTable[newObj.parent];
                        bounds = ej.datavisualization.Diagram.SvgContext._measureStackSize(group, this.diagram, true);
                        newSize = this.diagram._getMinMaxSize(group, (bounds.width), (bounds.height), true);
                        var widDif = newSize.width - group.width;
                        var heiDif = newSize.height - group.height;
                        group.offsetX += (widDif / 2);
                        group.width = newSize.width;
                        group.offsetY += (heiDif / 2);
                        group.height = newSize.height;
                        ej.datavisualization.Diagram.SvgContext._alignOnStack(group, this.diagram);
                        ej.datavisualization.Diagram.DiagramContext.update(group, this.diagram);
                        if (group.parent)
                            this._updateContainer(group);
                    }
                }
            }
        };
        RotateTool.prototype.mouseup = function (evt) {

            if (this.inAction) {
                this.inAction = false;
                var isContainer = false;
                var canvasChild = false;
                if (this.selectedObject.parent) {
                    var parent = this.diagram.nameTable[this.selectedObject.parent];
                    if (parent.container) {
                        isContainer = true;
                    }
                }
                else if (this.selectedObject.type == "pseudoGroup" && this.hasSameParent() && this._fromContainer(this.diagram._getChildren(this.selectedObject.children))) {
                    var fNode = this.diagram.nameTable[this.diagram._getChild(this.selectedObject.children[0])];
                    parent = this.diagram.nameTable[fNode.parent];
                    if (parent.container) {
                        isContainer = true;
                    }
                }
                if (isContainer) {
                    ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._svg, this.diagram._adornerLayer);
                    this._removeHighLighter(); //ej.datavisualization.Diagram.SvgContext._removeNodeHighlighter(this.diagram._svg, this.diagram._adornerLayer);
                    if (parent.container.type == "canvas")
                        canvasChild = true;
                    if (canvasChild) {
                        var object = this._updateRotateObject();
                        this._updateContainer(object, null, true);
                    }
                }
                if (this.selectedObject.type != "pseudoGroup")
                    this._rotate(this.selectedObject);
                else {
                    if (!this._fromContainer(this.diagram._getChildren(this.selectedObject.children)))
                        this._rotate(this.selectedObject);
                }
                ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);

                var data;
                var childTable = {};
                if (this.selectedObject.type == "group" || this.selectedObject.type == "pseudoGroup")
                    childTable = this.diagram._getChildTable(this.selectedObject, childTable);
                var temp = { "childTable": childTable, "node": this.selectedObject };
                data = $.extend(true, {}, temp);
                var entry = { type: "rotationchanged", undoObject: this.undoObject, redoObject: jQuery.extend(true, {}, data), isMultipleNode: this.selectedObject.type == "group" ? true : false };
                this.diagram.addHistoryEntry(entry);

                //var entry = new ej.datavisualization.Diagram.HistoryEntry(new ej.datavisualization.Diagram.RotationHandleCmd(this.undoObject, ej.datavisualization.Diagram.Util.clone(this.selectedObject), this.selectedObject.type == "pseudoGroup" ? true : false));
                //this.diagram.historyManager.addHistoryEntry(entry);
                this.diagram._updateSelectionHandle();
                this.diagram._removeTooltip();
            }
            //this.diagram._removeTooltip();
            base.prototype.mouseup.call(this, evt);
        };
        return RotateTool;
    })(ToolBase);

    ej.datavisualization.Diagram.RotateTool = RotateTool;
    //#endregion 

    //#region PivotTool
    var PivotTool = (function (base) {
        ej.datavisualization.Diagram.extend(PivotTool, base);
        function PivotTool(diagram) {
            base.call(this, "PivotTool", diagram);
            this._mouseOffset = ej.datavisualization.Diagram.Size(0, 0);
        }
        PivotTool.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            this.selectedObject = this.diagram.selectionList[0];
        };
        PivotTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);

            if (this.selectedObject) {
                if (!this.inAction) {
                    this.inAction = true;
                }
                else {
                    var delx = this.currentPoint.x - this.previousPoint.x;
                    var dely = this.currentPoint.y - this.previousPoint.y;
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, -this.selectedObject.rotateAngle);
                    var delta = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(delx, dely));
                    var difx = (this.selectedObject.width * this.selectedObject.pivot.x + delta.x) / this.selectedObject.width;
                    var dify = (this.selectedObject.height * this.selectedObject.pivot.y + delta.y) / this.selectedObject.height;
                    this.selectedObject.pivot.x = difx;
                    this.selectedObject.pivot.y = dify;
                    this.selectedObject.offsetX += delx;
                    this.selectedObject.offsetY += dely;
                    this.diagram._updateSelectionHandle();
                }
            }
            this.previousPoint = this.currentPoint;
        };
        PivotTool.prototype._rotate = function (node) {
            var pt = ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY);
            var crntpoint = this.currentPoint;
            var angle = this.FindAngle(pt, crntpoint);
            this.diagram._rotate(node, angle - node.rotateAngle, pt, this.diagram.nameTable);
        };
        PivotTool.prototype.mouseup = function (evt) {
            if (this.inAction) {
                this.inAction = false;
                this.diagram._updateSelectionHandle();
            }
            base.prototype.mouseup.call(this, evt);
        };
        return PivotTool;
    })(ToolBase);
    ej.datavisualization.Diagram.PivotTool = PivotTool;
    //#endregion

    //#region PanTool
    var PanTool = (function (base) {
        ej.datavisualization.Diagram.extend(PanTool, base);
        function PanTool(diagram) {
            base.call(this, "panTool", diagram);
            this.diagram = diagram;
            this._isMouseDown = false;
            this.cursor = "pointer";
        }
        PanTool.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            var svgDocument = this.diagram._svg.document;
            var pt = this.diagram._svg.document.createSVGPoint();
            pt.x = evt.clientX; pt.y = evt.clientY;
            var mousept = pt.matrixTransform(this.diagram._svg.document.getScreenCTM().inverse());
            svgDocument.lastMouseX = mousept.x;
            svgDocument.lastMouseY = mousept.y;
            this._isMouseDown = true;
            return false;
        };

        PanTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            if (this._isMouseDown) {
                this.inAction = true;
                var svgDocument = this.diagram._svg.document;
                var pt = this.diagram._svg.document.createSVGPoint();
                pt.x = evt.clientX; pt.y = evt.clientY;
                var mousept = pt.matrixTransform(this.diagram._svg.document.getScreenCTM().inverse());
                var ex = mousept.x;
                var ey = mousept.y;
                var nx, ny;

                nx = ((ex - svgDocument.lastMouseX));
                ny = ((ey - svgDocument.lastMouseY));
                if (!(this.diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.PannableX))
                    nx = 0;
                if (!(this.diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.PannableY))
                    ny = 0;
                ej.datavisualization.Diagram.ZoomUtil.zoomPan(this.diagram, 1, nx, ny, ej.datavisualization.Diagram.Point(ex, ey));
                svgDocument.lastMouseX = ex;
                svgDocument.lastMouseY = ey;
                return false;
            }
        };
        PanTool.prototype.mouseup = function (evt) {
            this.inAction = false;
            document.onmousemove = null;
            document.onmouseup = null;
            this._isMouseDown = false;
            base.prototype.mouseup.call(this, evt);
        };
        return PanTool;
    })(ToolBase);
    ej.datavisualization.Diagram.PanTool = PanTool;
    //#endregion

    //#region RectangleToolBase
    var RectangleToolBase = (function (base) {
        ej.datavisualization.Diagram.extend(RectangleToolBase, base);
        function RectangleToolBase(name, diagram) {
            base.call(this, name, diagram);
            this.cursor = "crosshair";
        }
        RectangleToolBase.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            this.selectedObject = this.createNode();
        };
        RectangleToolBase.prototype.createNode = function () {
        };
        RectangleToolBase.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            if (this.selectedObject) {
                if (!this.inAction) {
                    this.inAction = true;
                    this._initHelper();
                    this._renderHelper();
                    this._calcOffset();
                }
                else {
                    this._updateHelper();
                }
            }
        };
        RectangleToolBase.prototype.mouseup = function (evt) {
            if (this.inAction) {
                this.inAction = false;
                if (this.diagram.model.snapSettings.snapConstraints.snapToLines) {
                    this._calcOffset();
                }
                this._updateSize(this.selectedObject, this.startPoint, this.currentPoint);
                this.diagram.add(this.selectedObject);
                this.diagram._clearSelection();
                this.diagram._addSelection(this.selectedObject);
            }
            this.diagram._toolToActivate = "selectTool";
            this.diagram._drawingTool = false;
            base.prototype.mouseup.call(this, evt);
        };
        RectangleToolBase.prototype._calcOffset = function () {
            var scale = this.diagram.model.magnification / 100;
            var bounds = ej.datavisualization.Diagram.Util.bounds(this.helper);
            var location = bounds.topLeft;
            location = ej.datavisualization.Diagram.Point(bounds.x + bounds.width, bounds.y + bounds.height);
            var x = location.x * scale;
            var y = location.y * scale;
            var xy = ej.datavisualization.Diagram.Point(x, y);
            var snapxy = this.snap(ej.datavisualization.Diagram.Point(x, y));
            this._mouseOffset = ej.datavisualization.Diagram.Size(xy.x - snapxy.x, xy.y - snapxy.y);
        };
        RectangleToolBase.prototype.getBoundingRect = function (startPoint, currentPoint) {
            var width = Math.abs(this.startPoint.x - this.currentPoint.x);
            var height = Math.abs(this.startPoint.y - this.currentPoint.y);
            var diff = ej.datavisualization.Diagram.Size(width, height);
            if (this.diagram.model.snapSettings.snapConstraints.snapToVerticalLines) {
                if (this._mouseOffset.width != 0) {
                    diff.width -= this._mouseOffset.width;
                    this._mouseOffset.width = 0;
                }
            }
            if (this.diagram.model.snapSettings.snapConstraints.snapToHorizontalLines) {
                if (this._mouseOffset.height != 0) {
                    diff.height -= this._mouseOffset.height;
                    this._mouseOffset.height = 0;
                }
            }
            var x = (this.startPoint.x > this.currentPoint.x) ? this.currentPoint.x : this.startPoint.x;
            var y = (this.startPoint.y > this.currentPoint.y) ? this.currentPoint.y : this.startPoint.y;
            return { size: diff, offset: ej.datavisualization.Diagram.Point(x, y) };
        };
        RectangleToolBase.prototype._renderHelper = function () {
            if (!this.svgHelper) {
                this.svgHelper = ej.datavisualization.Diagram.SvgContext.renderNode(this.helper, this.diagram._svg, this.diagram._diagramLayer);
                this.svgHelper = document.getElementById(this.helper.name);
                this.svgHelper.setAttribute("pointer-events", "none");
            }
        };
        RectangleToolBase.prototype._updateHelper = function () {
            this._updateSize(this.helper, this.startPoint, this.currentPoint);
            ej.datavisualization.Diagram.SvgContext.update(this.helper, this.diagram);
        };
        RectangleToolBase.prototype._updateSize = function (shape, startPoint, currentPoint) {
            var rect = this.getBoundingRect(startPoint, currentPoint);
            var size = rect.size;
            var offset = rect.offset;
            if (!ej.datavisualization.Diagram.Geometry.isEmptySize(size)) {
                shape.offsetX = offset.x + size.width / 2;
                shape.offsetY = offset.y + size.height / 2;
                shape.width = size.width;
                shape.height = size.height;
            }
        };
        return RectangleToolBase;
    })(ej.datavisualization.Diagram.ToolBase);
    ej.datavisualization.Diagram.RectangleToolBase = RectangleToolBase;
    //#endregion

    //#region PolygonToolBase
    var PolygonToolBase = (function (base) {
        ej.datavisualization.Diagram.extend(PolygonToolBase, base);
        function PolygonToolBase(name, diagram) {
            base.call(this, name, diagram);
            this.cursor = "crosshair";
        }
        PolygonToolBase.prototype.createNode = function () {

        };
        PolygonToolBase.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
        };
        PolygonToolBase.prototype.mousemove = function (evt) {

            base.prototype.mousemove.call(this, evt);
            if (this.selectedObject) {
                if (!this.inAction) {
                    this.inAction = true;
                    this._initHelper();
                    this._renderHelper();
                    this._calcOffset();
                }
                else {
                    this._updateHelper(this.snap(this.currentPoint));
                }
            }
        };
        PolygonToolBase.prototype.mouseup = function (evt) {
            if (!this.selectedObject) {
                if (this.startPoint) {
                    this.selectedObject = this.createNode();
                    var sp = this.snap(this.startPoint);
                    var ep = this.snap(this.currentPoint);
                    this.selectedObject.shape.points.push(ej.datavisualization.Diagram.Point(sp.x, sp.y));
                    this.selectedObject.shape.points.push(ej.datavisualization.Diagram.Point(ep.x, ep.y));
                }
            }
            else if (this.inAction) {
                this.helper.shape.points.push(ej.datavisualization.Diagram.Point(this.currentPoint.x, this.currentPoint.y));
            }
        };
        PolygonToolBase.prototype._calcOffset = function () {
            var scale = this.diagram.model.magnification / 100;
            var bounds = ej.datavisualization.Diagram.Util.bounds(this.helper);
            var location = bounds.topLeft;
            location = ej.datavisualization.Diagram.Point(bounds.x + bounds.width, bounds.y + bounds.height);
            var x = location.x * scale;
            var y = location.y * scale;
            var xy = ej.datavisualization.Diagram.Point(x, y);
            var snapxy = this.snap(ej.datavisualization.Diagram.Point(x, y));
            this._mouseOffset = ej.datavisualization.Diagram.Size(xy.x - snapxy.x, xy.y - snapxy.y);
        };
        PolygonToolBase.prototype._renderHelper = function () {
            if (!this.svgHelper) {

                var rect = ej.datavisualization.Diagram.Geometry.rect(this.helper.shape.points);
                this.helper.offsetX = rect.x + rect.width / 2;
                this.helper.offsetY = rect.y + rect.height / 2;
                this.helper.width = rect.width;
                this.helper.height = rect.height;
                this.svgHelper = ej.datavisualization.Diagram.SvgContext.renderNode(this.helper, this.diagram._svg, this.diagram._diagramLayer);
                this.svgHelper = document.getElementById(this.helper.name);
                this.svgHelper.setAttribute("pointer-events", "none");
            }
        };
        PolygonToolBase.prototype.doubleclick = function (currentPoint) {
            if (this.selectedObject) {

                ej.datavisualization.Diagram.Util.removeItem(this.helper.shape.points, this.helper.shape.points[this.helper.shape.points.length - 2]);
                ej.datavisualization.Diagram.Util.removeItem(this.helper.shape.points, this.helper.shape.points[this.helper.shape.points.length - 1]);
                this.selectedObject.shape.points = this.helper.shape.points;
                var rect = ej.datavisualization.Diagram.Geometry.rect(this.helper.shape.points);
                this.selectedObject.offsetX = rect.x + rect.width / 2;
                this.selectedObject.offsetY = rect.y + rect.height / 2;
                this.selectedObject.width = rect.width;
                this.selectedObject.height = rect.height;
                this.diagram.nodes().push(this.selectedObject);
                this.diagram.nameTable[this.selectedObject.name] = this.selectedObject;
                ej.datavisualization.Diagram.DiagramContext.renderNode(this.selectedObject, this.diagram);

                this.diagram._clearSelection();
                this.diagram._addSelection(this.selectedObject);
            }
            if (this._svgHelper) {
                this.diagram._svg.removeChild(this._svgHelper);
                this._svgHelper = null;
            }
            this._endAction();
            this.diagram._drawingTool = false;
            this.diagram._toolToActivate = "selectTool";
            this._mouseOffset = ej.datavisualization.Diagram.Size(0, 0);
        };
        PolygonToolBase.prototype._updateHelper = function (currentPoint) {
            this.helper.shape.points[this.helper.shape.points.length - 1] = ej.datavisualization.Diagram.Point(currentPoint.x, currentPoint.y);
            var rect = ej.datavisualization.Diagram.Geometry.rect(this.helper.shape.points);
            this.helper.offsetX = rect.x + rect.width / 2;
            this.helper.offsetY = rect.y + rect.height / 2;
            this.helper.width = rect.width;
            this.helper.height = rect.height;
            ej.datavisualization.Diagram.SvgContext.update(this.helper, this.diagram);
        };
        return PolygonToolBase;
    })(ej.datavisualization.Diagram.ToolBase);
    ej.datavisualization.Diagram.PolygonToolBase = PolygonToolBase;
    //#endregion

    //#region TextToolBase
    var TextToolBase = (function (base) {
        ej.datavisualization.Diagram.extend(TextToolBase, base);
        function TextToolBase(name, diagram) {
            base.call(this, name, diagram);
            this.boundingRect = ej.datavisualization.Diagram.Rectangle();
            this.activeLabel = null;
            this.cursor = "crosshair";
        }
        TextToolBase.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            if (this.diagram._isEditing) {
                this.diagram._endEdit();
            }
        };
        TextToolBase.prototype.createNode = function (rect) {

        };
        TextToolBase.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            if (ej.datavisualization.Diagram.Util.isPageEditable(this.diagram)) {
                if (!this.selectedObject && !ej.datavisualization.Diagram.Geometry.isEmptyPoint(this.startPoint) && !this.diagram._isEditing) {
                    if (!this.inAction) {
                        this.inAction = true;
                        this._initHelper();
                    }
                    else {
                        this._updateHelper();
                    }
                }
            }
        };
        TextToolBase.prototype.mouseup = function (evt) {
            this.activeLabel = null;
            var minHeight = 12;
            if (this.inAction) {
                var rect = this.getBoundingRect(this.startPoint, this.currentPoint);
                this._endAction();
                if (ej.browserInfo().name === "chrome" && (rect.width === 0 || rect.height === 0)) {
                    rect.width = 90;
                    rect.height = minHeight;
                }
                this.selectedObject = this.createNode(rect.x + (rect.width / 2), (rect.y + (rect.height / 2)), rect.width, rect.height);
                this.diagram._startEdit(this.selectedObject);
            }
            else {
                var node = this._findNodeUnderMouse(evt);
                if (node != null && ej.datavisualization.Diagram.Util.isPageEditable(this.diagram)) {
                    this.selectedObject = node;
                    this.diagram._startEdit(this.selectedObject);
                }
                else {
                    var rect = ej.datavisualization.Diagram.Rectangle(this.currentPoint.x - (90 / 2), this.currentPoint.y - (minHeight / 2), 90, minHeight);
                    this._endAction();
                    this.selectedObject = this.createNode(rect.x + (rect.width / 2), rect.y + (rect.height / 2), rect.width, minHeight);
                    this.diagram._startEdit(this.selectedObject);
                }
            }
        };
        TextToolBase.prototype.getBoundingRect = function (startPoint, currentPoint) {
            var width = Math.abs(this.startPoint.x - this.currentPoint.x);
            var height = Math.abs(this.startPoint.y - this.currentPoint.y);
            var x = (this.startPoint.x > this.currentPoint.x) ? this.currentPoint.x : this.startPoint.x;
            var y = (this.startPoint.y > this.currentPoint.y) ? this.currentPoint.y : this.startPoint.y;
            return { x: x, y: y, width: width, height: height };
        };
        TextToolBase.prototype._initHelper = function () {
            if (!this._svgHelper) {
                var g = this.diagram._svg.g();
                this.diagram._adornerLayer.appendChild(g);
                var scale = this.diagram._currZoom;
                var selectionRect = this.diagram._svg.rect({ "id": "helper", "x": this.startPoint.x * scale, "y": this.startPoint.y * scale, "fill": "transparent", "stroke": "gray", "stroke-dasharray": "2 2", "shape-rendering": "crispEdges" });
                g.appendChild(selectionRect);
                g.setAttribute("pointer-events", "none");
                this._svgHelper = g;
            }
        };
        TextToolBase.prototype._updateHelper = function () {
            var helper = this.diagram._svg.getElementById("helper");
            var width = Math.abs(this.startPoint.x - this.currentPoint.x);
            var height = Math.abs(this.startPoint.y - this.currentPoint.y);
            var scale = this.diagram._currZoom;
            var x = ((this.startPoint.x > this.currentPoint.x) ? this.currentPoint.x : this.startPoint.x) * scale;
            var y = ((this.startPoint.y > this.currentPoint.y) ? this.currentPoint.y : this.startPoint.y) * scale;
            if (helper) {
                this.diagram._svg.rect({ "id": helper.id, "x": x, "y": y, "width": width * scale, "height": height * scale });
            }
        };
        TextToolBase.prototype._endAction = function () {
            if (this._svgHelper) {
                this.diagram._adornerLayer.removeChild(this._svgHelper);
                this._svgHelper = null;
            }
            base.prototype._endAction.apply(this);
        };
        TextToolBase.prototype._findNodeUnderMouse = function (evt, skip) {
            var obj;
            var textElement = $(evt.target).parents("text")[0];
            if (textElement != null) {
                if (textElement.getAttribute("class") == "ej-d-label") {
                    var parentNode = $(textElement).parents("g")[0];
                    obj = this._findObj(parentNode);
                    if (obj.shape.type != "text") {
                        var label = textElement.id.split('_');
                        this.activeLabel = obj.labels.find(label[1]);
                    }
                }
            }
            else {
                var parents = $(evt.target).parents("g");
                if (parents.length > 3) {
                    var element = parents[parents.length - 4];
                    var id = element.getAttribute("id");
                    var type = element.getAttribute("class");
                    if (type) {
                        if (type === "ej-d-node" || type === "ej-d-group") {
                            obj = this.diagram._findNode(id);
                            var curlabel = this.diagram._findLabelAtPoint(this.currentPoint, obj);
                            this.activeLabel = curlabel;
                        }
                        else if (type === "ej-d-connector") {
                            obj = this.diagram._findConnector(id);
                            var curlabel = this.diagram._findLabelAtPoint(this.currentPoint, obj);
                            this.activeLabel = curlabel;
                        }
                    }
                }
            }
            return obj;
        };
        TextToolBase.prototype.getLabelUnderMouse = function () {
            return this.activeLabel;
        };
        return TextToolBase;
    })(ej.datavisualization.Diagram.ToolBase);
    ej.datavisualization.Diagram.TextToolBase = TextToolBase;
    //#endregion

    //#region RectangleTool
    var RectangleTool = (function (base) {
        ej.datavisualization.Diagram.extend(RectangleTool, base);
        function RectangleTool(diagram) {
            base.call(this, "rectangleTool", diagram);
        }
        RectangleTool.prototype.createNode = function () {
            var node = this.diagram._getNewNode({ name: "rectangle" + ej.datavisualization.Diagram.Util.randomId() });
            node.offsetX = 0;
            node.offsetY = 0;
            node.width = 0;
            node.height = 0;
            return node;
        };
        return RectangleTool;
    })(ej.datavisualization.Diagram.RectangleToolBase);
    ej.datavisualization.Diagram.RectangleTool = function (diagram) {
        return new RectangleTool(diagram);
    };
    //#endregion

    //#region EllipseTool
    var EllipseTool = (function (base) {
        ej.datavisualization.Diagram.extend(EllipseTool, base);
        function EllipseTool(diagram) {
            base.call(this, "ellipseTool", diagram);
        }
        EllipseTool.prototype.createNode = function () {
            var node = this.diagram._getNewNode({ name: "ellipse" + ej.datavisualization.Diagram.Util.randomId() });
            node.shape.type = ej.datavisualization.Diagram.Shapes.Ellipse;
            node.fillColor = "white";
            node.offsetX = 0;
            node.offsetY = 0;
            node.width = 0;
            node.height = 0;

            return node;
        };
        return EllipseTool;
    })(ej.datavisualization.Diagram.RectangleToolBase);
    ej.datavisualization.Diagram.EllipseTool = function (diagram) {
        return new EllipseTool(diagram);
    };
    //#endregion

    //#region RoundRectTool
    var RoundRectTool = (function (base) {
        ej.datavisualization.Diagram.extend(RoundRectTool, base);
        function RoundRectTool(diagram) {
            base.call(this, "roundRectTool", diagram);
        }
        RoundRectTool.prototype.createNode = function () {
            var node = this.diagram._getNewNode({ name: "roundrect" + ej.datavisualization.Diagram.Util.randomId() });
            node.shape.type = ej.datavisualization.Diagram.Shapes.Rectangle;
            node.shape.cornerRadius = 15;
            node.offsetX = 0;
            node.offsetY = 0;
            node.width = 0;
            node.height = 0;

            return node;
        };
        return RoundRectTool;
    })(ej.datavisualization.Diagram.RectangleToolBase);
    ej.datavisualization.Diagram.RoundRectTool = function (diagram) {
        return new RoundRectTool(diagram);
    };
    //#endregion

    //#region TextTool
    var TextTool = (function (base) {
        ej.datavisualization.Diagram.extend(TextTool, base);
        function TextTool(diagram) {
            base.call(this, "textTool", diagram);
        }
        TextTool.prototype.createNode = function (x, y, width, height) {
            var node = ej.datavisualization.Diagram.Node({ name: "text" + ej.datavisualization.Diagram.Util.randomId(), offsetX: x, offsetY: y, width: width, height: height, borderColor: "transparent", fillColor: "transparent", labels: [], ports: [], shape: { type: "text", textBlock: ej.datavisualization.Diagram.TextBlockDefaults } });
            return node;
        };
        return TextTool;
    })(ej.datavisualization.Diagram.TextToolBase);
    ej.datavisualization.Diagram.TextTool = function (diagram) {
        return new TextTool(diagram);
    };
    //#endregion

    //#region PolygonTool
    var PolygonTool = (function (base) {
        ej.datavisualization.Diagram.extend(PolygonTool, base);
        function PolygonTool(diagram) {
            base.call(this, "polygonTool", diagram);
        }
        PolygonTool.prototype.createNode = function () {
            var node = this.diagram._getNewNode({ name: "polygon" + ej.datavisualization.Diagram.Util.randomId() });
            node.shape.type = ej.datavisualization.Diagram.Shapes.Polygon;
            node.offsetX = 0;
            node.offsetY = 0;
            node.width = 0;
            node.height = 0;
            return node;
        };
        return PolygonTool;
    })(ej.datavisualization.Diagram.PolygonToolBase);
    ej.datavisualization.Diagram.PolygonTool = function (diagram) {
        return new PolygonTool(diagram);
    };;
    //#endregion

    //#region ImageTool
    var ImageTool = (function (base) {
        ej.datavisualization.Diagram.extend(ImageTool, base);
        function ImageTool(saveUrl, removeUrl, uploadfileUrl, autoOpenUpload, diagram) {
            base.call(this, "imageTool", diagram);
            this.saveUrl = saveUrl;
            this.removeUrl = removeUrl;
            this.uploadfileUrl = uploadfileUrl;
            this.autoOpenUpload = autoOpenUpload;
            this.bounds = ej.datavisualization.Diagram.Rectangle(0, 0, 0, 0);
            this.cursor = "crosshair";
        }
        ImageTool.prototype.createNode = function (imageUrl) {
            var node = this.diagram._getNewNode();
            node.name = "image" + ej.datavisualization.Diagram.Util.randomId();
            node.shape = ej.datavisualization.Diagram.Shapes.Image(imageUrl);
            node.borderDashArray = "5,5";
            node.offsetX = 0;
            node.offsetY = 0;
            node.width = 0;
            node.height = 0;

            return node;
        };
        ImageTool.prototype.mouseup = function (evt) {
            if (this.inAction)
                this.bounds = this.getBoundingRect(this.snap(this.startPoint), this.snap(this.currentPoint));
            this._renderDialogControl();
            this.diagram._toolToActivate = "selectTool";
            this.diagram._drawingTool = false;
            this._endAction();
        };
        ImageTool.prototype._showPopup = function () {
            this._renderDialogControl();
            this.diagram._toolToActivate = "selectTool";
            this.diagram._drawingTool = false;
            this._endAction();
        };
        ImageTool.prototype._renderDialogControl = function () {
            var dialogDiv = document.createElement("div");
            var attr = {
                "id": "basicDialog",
                "title": "Insert Image",
                "style": "display:none"
            };
            ej.datavisualization.Diagram.Util.attr(dialogDiv, attr);
            document.body.appendChild(dialogDiv);
            var uploadDiv = document.createElement("div");
            attr = {
                "id": "UploadDefault",
                "style": "padding-Left:15px; float:left"
            };
            ej.datavisualization.Diagram.Util.attr(uploadDiv, attr);
            var table = document.createElement("table");
            var tr = document.createElement("tr");
            var td = document.createElement("td");
            attr = {
                "align": "left",
                "style": "padding-Top:10px"
            }
            ej.datavisualization.Diagram.Util.attr(td, attr);
            var childDiv = document.createElement("div");
            childDiv.style.cssFloat = "left";
            var rdoComputer = document.createElement("input");
            attr = {
                "type": "radio",
                "name": "uploadOption",
                "id": "rdoComputer",
                "checked": "true"
            };
            ej.datavisualization.Diagram.Util.attr(rdoComputer, attr);
            rdoComputer.onchange = $.proxy(this._rdoChanged, this);
            childDiv.appendChild(rdoComputer);
            var label = document.createElement("label");
            label.innerHTML = "My Computer";
            label.className = "dialogLabel";
            attr = {
                "style": "font-weight:normal; padding-left:5px; vertical-align: top;"
            }
            ej.datavisualization.Diagram.Util.attr(label, attr);
            label.onclick = $.proxy(this._labelClick, this);
            childDiv.appendChild(label);
            td.style.paddingBottom = "5px";
            td.appendChild(childDiv);
            td.appendChild(uploadDiv);
            var label = document.createElement("label");
            attr = {
                "id": "lblComputerUrl",
                "style": "font-weight:normal;padding-left:10px; vertical-align: top;color:red;"
            };
            ej.datavisualization.Diagram.Util.attr(label, attr);
            td.appendChild(label);
            tr.appendChild(td);
            table.appendChild(tr);
            tr = document.createElement("tr");
            td = document.createElement("td");
            var rdoWebUrl = document.createElement("input");
            attr = {
                "id": "rdoWebUrl",
                "type": "radio",
                "name": "uploadOption"
            };
            ej.datavisualization.Diagram.Util.attr(rdoWebUrl, attr);
            rdoWebUrl.onchange = $.proxy(this._rdoChanged, this);
            td.appendChild(rdoWebUrl);
            var label = document.createElement("label");
            label.innerHTML = "Web URL";
            label.className = "dialogLabel";
            attr = {
                "style": "font-weight:normal; padding-left:5px; vertical-align: top;"
            };
            ej.datavisualization.Diagram.Util.attr(label, attr);
            label.onclick = $.proxy(this._labelClick, this);
            td.appendChild(label);
            var label = document.createElement("label");
            attr = {
                "id": "lblWebUrl",
                "style": "font-weight:normal;padding-left:25px; vertical-align: top;color:red;"
            };
            ej.datavisualization.Diagram.Util.attr(label, attr);
            td.appendChild(label);
            tr.appendChild(td);
            table.appendChild(tr);
            tr = document.createElement("tr");
            td = document.createElement("td");
            attr = {
                "style": "padding-Top:5px;padding-Bottom:15px"
            };
            ej.datavisualization.Diagram.Util.attr(td, attr);
            var txtImageUrl = document.createElement("input");
            attr = {
                "id": "txtImageUrl",
                "type": "text",
                "placeholder": "Image URL",
                "style": "width:460px;height:20px"
            };
            ej.datavisualization.Diagram.Util.attr(txtImageUrl, attr);
            txtImageUrl.onfocus = $.proxy(this._textFocus, this);
            txtImageUrl.onfocusout = $.proxy(this._textFocusOut, this);
            td.appendChild(txtImageUrl);
            tr.appendChild(td);
            table.appendChild(tr);
            tr = document.createElement("tr");
            td = document.createElement("td");
            var btnOk = document.createElement("input");
            attr = {
                "value": "Ok",
                "type": "button",
                "id": "btnOk",
                "style": "width : 100px; height: 30px; margin-Right: 5px; border: 1px solid #F7952E; color : white; font-Family:Segoe UI;font-weight:bold"
            };
            ej.datavisualization.Diagram.Util.attr(btnOk, attr);
            btnOk.onclick = $.proxy(this._uploadClick, this);
            td.appendChild(btnOk);
            var btnCancel = document.createElement("input");
            attr = {
                "value": "Cancel",
                "type": "button",
                "id": "btnCancel",
                "style": "width : 100px; height: 30px; border: 1px solid #DFDFDE; font-Family:Segoe UI;font-weight:bold"
            };
            ej.datavisualization.Diagram.Util.attr(btnCancel, attr);
            btnCancel.onclick = $.proxy(this._closeDialog, this);
            td.appendChild(btnCancel);
            attr = {
                "align": "right"
            };
            ej.datavisualization.Diagram.Util.attr(td, attr);
            tr.appendChild(td);
            table.appendChild(tr);
            dialogDiv.appendChild(table);
            $("#UploadDefault").ejUploadbox({
                saveUrl: this.saveUrl,
                removeUrl: this.removeUrl,
                complete: $.proxy(this.fileuploadComplete, this)
            });
            $("#basicDialog").ejDialog({ height: 230, width: 500, modal: true });
            $("#basicDialog").ejDialog("open");
        };
        ImageTool.prototype.fileuploadComplete = function (e, ui) {
            var fileName = this.uploadfileUrl + "/" + e.files.name;
            this._renderImageNode(fileName);
            this._closeDialog();
        };
        ImageTool.prototype._uploadClick = function () {
            var imageUrl = document.getElementById("txtImageUrl").value;
            if (/^(http:\/\/www\.|https:\/\/www\.)[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(:[0-9]{1,5})?(\/.*)?$/.test(imageUrl)) {
                this._renderImageNode(imageUrl);
                this._closeDialog();
            }
            else {
                if (document.getElementById("rdoComputer").checked === true) {
                    var lblComputerUrl = document.getElementById("lblComputerUrl");
                    var lblWebUrl = document.getElementById("lblWebUrl");
                    lblComputerUrl.innerHTML = "Browse any image to insert";
                    lblWebUrl.innerHTML = "";
                }
                else {
                    var lblComputerUrl = document.getElementById("lblComputerUrl");
                    var lblWebUrl = document.getElementById("lblWebUrl");
                    lblComputerUrl.innerHTML = "";
                    lblWebUrl.innerHTML = "Invalid Url";
                    document.getElementById("txtImageUrl").focus();
                }
            }
        };
        ImageTool.prototype._rdoChanged = function () {
            var lblComputerUrl = document.getElementById("lblComputerUrl");
            var lblWebUrl = document.getElementById("lblWebUrl");
            lblComputerUrl.innerHTML = "";
            lblWebUrl.innerHTML = "";
        };
        ImageTool.prototype._closeDialog = function () {
            $("#basicDialog").ejDialog("close");
            var dialog = document.getElementById("basicDialog");
            dialog.parentNode.removeChild(dialog);
        };
        ImageTool.prototype._labelClick = function (evt) {
            if (evt.target.innerHTML == "My Computer") {
                var radio = document.getElementById("rdoComputer");
                radio.checked = true;
            }
            else {
                var radio = document.getElementById("rdoWebUrl");
                radio.checked = true;
            }
            this._rdoChanged();
        };
        ImageTool.prototype._textFocus = function (evt) {
            var radio = document.getElementById("rdoWebUrl");
            radio.checked = true;
        };
        ImageTool.prototype._renderImageNode = function (fileName) {
            var node = this.createNode(fileName);
            if (this.bounds.size.width != undefined && !ej.datavisualization.Diagram.Geometry.isEmptySize(this.bounds.size)) {
                node.offsetX = this.bounds.offset.x + this.bounds.size.width / 2;
                node.offsetY = this.bounds.offset.y + this.bounds.size.height / 2;
                node.width = this.bounds.size.width;
                node.height = this.bounds.size.height;
            }
            else {
                node.offsetX = 150;
                node.offsetY = 150;
                node.width = 100;
                node.height = 100;
            }
            node.borderDashArray = "";

            this.diagram.nodes().push(node);
            ej.datavisualization.Diagram.DiagramContext.renderNode(node, this.diagram);

            this.diagram._clearSelection();
            this.diagram._addSelection(node);
        };
        return ImageTool;
    })(ej.datavisualization.Diagram.RectangleToolBase);
    ej.datavisualization.Diagram.ImageTool = function (saveUrl, removeUrl, uploadfileUrl, autoOpenUpload, diagram) {
        return new ImageTool(saveUrl, removeUrl, uploadfileUrl, autoOpenUpload, diagram);
    };;
    //#endregion


    var PhaseTool = (function (base) {
        ej.datavisualization.Diagram.extend(PhaseTool, base);
        function PhaseTool(diagram) {
            base.call(this, "phase", diagram);
            this.selectedSeperetor = null;
            this._svgHelper = null;
        }

        PhaseTool.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            this._inAction = true;
        };
        PhaseTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            if (this._inAction) {
                if ($(evt.target).parents("g").first()[0]) {
                    var id = $(evt.target).parents("g").first()[0].id;
                    var phase = this._getphase(id);
                    if (phase && !this.selectedSeperetor) {
                        this.selectedSeperetor = phase;
                    }
                }
            }
            if (this.selectedSeperetor) {
                var dx = this.previousPoint.x - this.currentPoint.x;
                var dy = this.previousPoint.y - this.currentPoint.y;

                if (this.selectedSeperetor.orientation == "horizontal")
                    this.selectedSeperetor.offset -= dx;
                else
                    this.selectedSeperetor.offset -= dy;
                ej.datavisualization.Diagram.SvgContext._updatephase(this.selectedSeperetor, this.diagram);
            }
            this.previousPoint = this.currentPoint;
        };
        PhaseTool.prototype._getphase = function (id) {
            if (this.diagram.model.phases) {
                for (var i = 0; i < this.diagram.model.phases.length; i++) {
                    if (this.diagram.model.phases[i].name == id)
                        return this.diagram.model.phases[i];
                }
            }
        };
        PhaseTool.prototype.mouseup = function (evt) {
            base.prototype.mouseup.call(this, evt);
            this._inAction = false;
            this.selectedSeperetor = null;
        };
        return PhaseTool;
    })(ToolBase);
    ej.datavisualization.Diagram.PhaseTool = PhaseTool;
})(jQuery, Syncfusion);;
(function ($, ej) {
    "use strict";

    ej.datavisualization.Diagram.LayoutTypes = { None: "none", HierarchicalTree: "hierarchicaltree", OrganizationalChart: "organizationalchart" };

    ej.datavisualization.Diagram.Layout = {
        doLayout: function (diagram) {
            if (diagram.model.layout.type === "hierarchicaltree") {
                ej.datavisualization.Diagram.HierarchicalLayout.doLayout(diagram);
            }
            else if (diagram.model.layout.type === "organizationalchart") {
                ej.datavisualization.Diagram.HierarchicalLayout.doLayout(diagram, true);
            }
        },
    };

    //region Hierarchical layout
    ej.datavisualization.Diagram.HierarchicalLayout = {
        // #region Methods
        doLayout: function (diagram, findLevel) {
            var layout = {
                _mDepths: [], _mMaxDepth: 0, fixedNode: null, diagram: diagram, rootNode: null, _mAnchorX: 0, _mAnchorY: 0,
                _mEqualities: {}, _firstLevelNodes: [], level: null
            };
            var model = diagram.model;
            layout = $.extend(true, {}, layout, model.layout);
            if (diagram.nodes().length > 0) {
                layout._mEqualities = {};
                layout._firstLevelNodes = [];
                for (var i = 0; i < diagram.nodes().length; i++) {
                    var node = diagram.nameTable[diagram.nodes()[i].name];
                    if (node.parent == "") {

                        //diagram._translate(node, -node.offsetX, -node.offsetY, diagram.nameTable, true);
                        var layoutInfo = layout._mEqualities[node.name] = this._setUpLayoutInfo(node);
                        layoutInfo.split = true;
                        layoutInfo.waterfall = true;
                        if (!node.inEdges || !node.inEdges.length) { layout._firstLevelNodes.push(node); }
                    }
                }
                if (findLevel) {
                    layout.level = Math.max(this._findLevel(layout, layout._firstLevelNodes[0], 1), 2);
                    layout.orientation = "toptobottom";
                }
                for (var i = 0; i < layout._firstLevelNodes.length; i++) {
                    var node = layout._firstLevelNodes[i];
                    this._updateEdges(layout, node, 1);
                }
                if (layout._firstLevelNodes.length > 0) {
                    layout._rootNode = layout._firstLevelNodes[0];

                    this._doLayout(layout, diagram);

                }
            }
        },

        _findLevel: function (layout, node, depth, min) {
            var layoutInfo = layout._mEqualities[node.name];

            var hasChild = true;
            if (node.outEdges && node.outEdges.length && node.isExpanded) {
                for (var j = 0; j < node.outEdges.length; j++) {
                    var edge = layout.diagram.nameTable[layout.diagram.nameTable[node.outEdges[j]].targetNode];
                    if (edge.outEdges && edge.outEdges.length && edge.isExpanded) {
                        var level = this._findLevel(layout, edge, depth + 1, min);
                        if (!min) min = level;
                        min = Math.min(min, level);
                        hasChild = false;
                    }
                    else return depth;
                }
                if (hasChild) return depth;
            }
            return min;
        },

        _updateEdges: function (layout, node, depth) {
            var layoutInfo = layout._mEqualities[node.name];
            if (node.outEdges && node.outEdges.length) {
                for (var j = 0; j < node.outEdges.length; j++) {
                    var edge = layout.diagram.nameTable[layout.diagram.nameTable[node.outEdges[j]].targetNode];
                    if (!edge.excludeFromLayout) {
                        if (depth < layout.level || layout.level === null) {
                            layoutInfo.children.push(edge.name);
                        }
                        else layoutInfo.waterfallChildren.push(edge.name);
                    }
                    if (node.outEdges.length > 1) {
                        if (edge.outEdges && edge.outEdges.length && edge.isExpanded) {
                            layoutInfo.split = false;
                            layoutInfo.waterfall = false;
                        }
                    }
                    this._updateEdges(layout, edge, depth + 1);
                }

            }
        },

        _getNextSibling: function (layout, node, edge, waterfall, i) {
            i = i ? i : 1;
            var node = layout._mEqualities[node.name];
            if (!waterfall) {
                if (node.children && node.children.length) {
                    var index = node.children.indexOf(edge);
                    if (index < node.children.length - i)
                        return layout.diagram.nameTable[node.children[index + i]];
                }
            }
            else {
                if (node.waterfallChildren && node.waterfallChildren.length) {
                    var index = node.waterfallChildren.indexOf(edge);
                    if (index < node.waterfallChildren.length - i)
                        return layout.diagram.nameTable[node.waterfallChildren[index + i]];
                }
            }
        },

        _getPrevSibling: function (layout, node, edge, waterfall) {
            var node = layout._mEqualities[node.name];
            if (!waterfall) {
                if (node.children && node.children.length) {
                    var index = node.children.indexOf(edge);
                    if (index > 0)
                        return layout.diagram.nameTable[node.children[index - 1]];
                }
            }
            else {
                if (node.waterfallChildren && node.waterfallChildren.length) {
                    var index = node.waterfallChildren.indexOf(edge);
                    if (index > 0)
                        return layout.diagram.nameTable[node.waterfallChildren[index - 1]];
                }
            }
        },

        _getLastChild: function (layout, node, waterfall) {
            var node = layout._mEqualities[node.name];
            if (!waterfall) {
                if (node.children && node.children.length)
                    return layout.diagram.nameTable[node.children[node.children.length - 1]];
            }
            else {
                if (node.waterfallChildren && node.waterfallChildren.length)
                    return layout.diagram.nameTable[node.waterfallChildren[node.waterfallChildren.length - 1]];
            }
        },

        _getFirstChild: function (layout, node, waterfall) {
            var node = layout._mEqualities[node.name];
            if (!waterfall) {
                if (node.children && node.children.length)
                    return layout.diagram.nameTable[node.children[0]];
            }
            else {
                if (node.waterfallChildren && node.waterfallChildren.length)
                    return layout.diagram.nameTable[node.waterfallChildren[0]];
            }
        },
        _getParentNode: function (layout, node) {
            if (node.inEdges && node.inEdges.length) {
                return layout.diagram.nameTable[layout.diagram.nameTable[node.inEdges[0]].sourceNode];
            }
        },

        _hasChild: function (layout, shape) {
            var shape = layout._mEqualities[shape.name];
            return shape.children && shape.children.length || shape.waterfallChildren && shape.waterfallChildren.length;
        },

        _getSpace: function (layout, l, r, siblings) {
            var hspace = 0;
            var stree = 0;
            var w = (layout.orientation == "toptobottom" || layout.orientation == "bottomtotop");
            hspace = layout.horizontalSpacing;
            stree = layout.horizontalSpacing;
            var info = layout._mEqualities[l.name];
            if (info.bounds) {
                return (siblings ? hspace : stree) + info.bounds.right;
            }
            return (siblings ? hspace : stree) + 0.5 * (w ? l.width + r.width : l.height + r.height);
        },

        _updateDepths: function (layout, depth, item) {
            var v = (layout.orientation == "toptobottom" || layout.orientation == "bottomtotop");
            var d = (v ? item.height : item.width);
            if (layout.orientation == "bottomtotop" || layout.orientation == "righttoleft") {
                d = -d;
                layout._mDepths[depth] = Math.min(layout._mDepths[depth] || 0, d);
            }
            else {
                layout._mDepths[depth] = Math.max(layout._mDepths[depth] || 0, d);
            }
            layout._mMaxDepth = Math.max(layout._mMaxDepth, depth);
        },

        _checkDepths: function (layout) {
            for (var i = 1; i <= layout._mMaxDepth; ++i) {
                var vspace = 0;
                vspace = layout.verticalSpacing;
                if (layout.orientation == "bottomtotop" || layout.orientation == "righttoleft")
                    vspace = -vspace;
                layout._mDepths[i] += (layout._mDepths[i - 1] || 0) + vspace;
            }
        },

        _doLayout: function (layout, diagram) {
            layout._mDepths = [];
            layout._mDepths[0] = 0;
            layout._mAnchorX = 0;
            layout._mAnchorY = 0;
            layout._mMaxDepth = 0;
            layout.diagram._layoutInAction = true;
            var fixedNode, fixedX, fixedY;

            if (layout._firstLevelNodes.length > 1) {
                this._doFirstWalk(layout, layout._firstLevelNodes[0], 0, 1, null, null, layout._firstLevelNodes[1]);
            }
            else {
                this._doFirstWalk(layout, layout._firstLevelNodes[0], 0, 1, null, null, null);
            }

            this._checkDepths(layout);
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(layout.diagram);

            if (layout.orientation == "toptobottom") {
                layout._mAnchorX = viewPort.width / 2 - layout._rootNode.width / 2 + layout.marginX;
                layout._mAnchorY = 0;
            }
            else if (layout.orientation == "bottomtotop") {
                layout._mAnchorX = viewPort.width / 2 - layout._rootNode.width / 2 + layout.marginX;
                layout._mAnchorY = viewPort.height - layout.marginY;
            }
            else if (layout.orientation == "lefttoright") {
                layout._mAnchorX = layout.marginX;
                layout._mAnchorY = viewPort.height / 2 + layout.marginY;
            }
            else if (layout.orientation == "righttoleft") {
                layout._mAnchorX = viewPort.width - layout.marginX;
                layout._mAnchorY = viewPort.height / 2 + layout.marginY;
            }
            if (layout.fixedNode) {
                var fixedNode = layout.diagram.nameTable[layout.fixedNode];
                var fixedX = fixedNode.offsetX;
                var fixedY = fixedNode.offsetY;
            }

            var rp = layout._mEqualities[layout._firstLevelNodes[0].name];
            this._doSecondWalk(layout, layout._firstLevelNodes[0], null, -rp.prelim, 0, diagram);
            this._updateNodes(layout, fixedX || 0, fixedY || 0, diagram);
            this._updateConnectors(layout, layout._rootNode, 1);
        },
        _updateNodes: function (layout, fixedx, fixedy, diagram) {

            if (layout.fixedNode) {
                var fixedNode = layout.diagram.nameTable[layout.fixedNode];
                var delx = fixedx - fixedNode.offsetX;
                var dely = fixedy - fixedNode.offsetY;
            }
            else { delx = 0; dely = 0; }
            var nodes = layout.diagram.nodes();
            for (var i = 0; i < nodes.length; i++) {
                var node = diagram.nameTable[nodes[i].name];
                if (node.parent == "") {
                    if (!nodes[i].excludeFromLayout) {
                        nodes[i].offsetX += delx;
                        nodes[i].offsetY += dely;
                    }
                    ej.datavisualization.Diagram.SpatialUtil._updateQuad(layout.diagram, layout.diagram._spatialSearch, node);
                    if (layout.diagram._svg)
                        ej.datavisualization.Diagram.DiagramContext.update(node, layout.diagram, true);
                }
            }
        },
        _updateConnectors: function (layout, node, level) {
            for (var i = 0; i < node.outEdges.length; i++) {
                var conn = layout.diagram.nameTable[node.outEdges[i]];
                var target = layout.diagram.nameTable[conn.targetNode];
                if (layout.type == "organizationalchart") {
                    conn.sourcePoint = { x: node.offsetX, y: node.offsetY + node.height / 2 };
                    conn.targetPoint = { x: target.offsetX + target.width / 2, y: node.offsetY };
                    var info = layout._mEqualities[node.name];
                    if (!layout.level || level < layout.level) {
                        layout.diagram.updateConnector(conn.name, { segments: [{ type: "orthogonal" }] });
                    }
                    else {
                        if (target.offsetX == node.offsetX) {
                            conn.sourcePoint = { x: node.offsetX, y: node.offsetY + node.height / 2 };
                            conn.targetPoint = { x: target.offsetX, y: target.offsetY - target.height / 2 };
                            layout.diagram.updateConnector(conn.name, { segments: [{ type: "orthogonal" }] });
                        }
                        else {
                            var segments = [{ type: "orthogonal", length: target.offsetY - (node.offsetY + node.height / 2), direction: "bottom" },
                            { type: "orthogonal" }];
                            layout.diagram.updateConnector(conn.name, { segments: segments });
                        }
                    }
                    //layout.diagram._dock(conn, layout.diagram.nameTable);
                }
                layout.diagram._dock(conn, layout.diagram.nameTable);
                if (layout.diagram._svg)
                    ej.datavisualization.Diagram.DiagramContext.update(conn, layout.diagram);
                if (target.isExpanded || this._hasChild(layout, target))
                    this._updateConnectors(layout, target, level + 1);
            }
        },

        _doFirstWalk: function (layout, shape, number, depth, parent, prev, next) {
            var layoutInfo = layout._mEqualities[shape.name];
            layoutInfo.number = number;
            this._updateDepths(layout, depth, shape);
            var isExpanded = shape.isExpanded;
            if (!this._hasChild(layout, shape) || !isExpanded || depth == layout.level) {
                if (depth == layout.level) {
                    if (prev) {
                        var prevInfo = layout._mEqualities[prev.name];
                    }
                    var bounds = this._doWaterFallFirstWalk(layout, shape, null, null, 0, 0, prevInfo ? prevInfo.bounds : {});
                    layoutInfo.bounds = bounds;
                    layoutInfo.waterfallMod = layoutInfo.dimensions.x;
                    layoutInfo.prelim = 0;
                    if (prevInfo) {
                        layoutInfo.prelim += (prevInfo.prelim - prevInfo.mod) + prevInfo.bounds.right + layout.horizontalSpacing;
                    }
                }
                else {
                    var l = prev;
                    if (l == null) {
                        layoutInfo.prelim = 0;
                    }
                    else {
                        layoutInfo.prelim = layout._mEqualities[l.name].prelim + this._getSpace(layout, l, shape, true);
                    }
                }
            }
            else if (isExpanded) {
                var leftMostShape = this._getFirstChild(layout, shape);
                var rightMostShape = this._getLastChild(layout, shape);
                var defaultAncestor = leftMostShape;
                var c = leftMostShape;
                for (var i = 0; c != null; ++i, c = this._getNextSibling(layout, shape, c.name)) {
                    var p = this._getPrevSibling(layout, shape, c.name);
                    var n = this._getNextSibling(layout, shape, c.name);
                    this._doFirstWalk(layout, c, i, depth + 1, shape, p, n);///////////////////
                    defaultAncestor = this._allocateSpace(layout, c, defaultAncestor, shape, p, n, depth);
                }

                this._translateShapePosition(layout, shape);

                var midpoint = 0.5 *
                    (layout._mEqualities[leftMostShape.name].prelim + layout._mEqualities[leftMostShape.name].waterfallMod +
                    layout._mEqualities[rightMostShape.name].prelim + layout._mEqualities[rightMostShape.name].waterfallMod);

                var left = null;
                if (layout._firstLevelNodes.indexOf(shape) != -1) {
                    if (layout._firstLevelNodes.indexOf(shape) > 0) {
                        left = layout._firstLevelNodes[layout._firstLevelNodes.indexOf(shape) - 1];
                    }
                }
                else {
                    if (this._getPrevSibling(layout, parent, shape.name))
                        left = this._getPrevSibling(layout, parent, shape.name);
                }
                if (left) {
                    layoutInfo.prelim = layout._mEqualities[left.name].prelim + this._getSpace(layout, left, shape, true);
                    layoutInfo.mod = layoutInfo.prelim - midpoint;
                }
                else {
                    layoutInfo.prelim = (midpoint);
                }
            }
            if (layout._firstLevelNodes.indexOf(shape) != -1 && layout._firstLevelNodes.length > 1)
                this._allocateSpace(layout, shape, layout._firstLevelNodes[0], null, prev, next);

            //finding the next root level node

            if (layout._firstLevelNodes.indexOf(shape) != -1 && layout._firstLevelNodes.length > 1) {
                var node = null;

                if (layout._firstLevelNodes.indexOf(shape) < layout._firstLevelNodes.length - 1) {
                    node = layout._firstLevelNodes[layout._firstLevelNodes.indexOf(shape) + 1];
                }
                if (node != null) {
                    var prevRoot, nextRoot;

                    if (layout._firstLevelNodes.indexOf(node) == 0) {
                        prevRoot = null;
                    }
                    else {
                        prevRoot = layout._firstLevelNodes[layout._firstLevelNodes.indexOf(node) - 1];
                    }

                    if (layout._firstLevelNodes.indexOf(node) == layout._firstLevelNodes.length - 1) {
                        nextRoot = null;
                    }
                    else {
                        nextRoot = layout._firstLevelNodes[layout._firstLevelNodes.indexOf(shape) + 1];
                    }

                    this._doFirstWalk(layout, node, 0, 1, null, prevRoot, nextRoot);
                }
            }
        },


        _setUpLayoutInfo: function (item) {
            var info = {};
            info.ancestor = item;
            info.number = -1;
            info.ancestor = info.thread = null;
            info.shift = 0;
            info.change = 0;
            info.mod = 0;
            info.children = [];
            info.waterfallChildren = [];
            info.waterfallMod = 0;
            return info;
        },

        _allocateSpace: function (layout, v, a, parent, prev, next, depth) {
            var w = prev;
            if (w != null) {
                var vip, vim, vop, vom;
                var sip, sim, sop, som;

                vip = vop = v;
                vim = w;
                vom = null;
                if (parent)
                    vom = this._getFirstChild(layout, parent);
                else {
                    vom = layout._firstLevelNodes[0];
                }
                sip = layout._mEqualities[vip.name].mod;
                sop = layout._mEqualities[vop.name].mod;
                sim = layout._mEqualities[vim.name].mod;
                som = layout._mEqualities[vom.name].mod;
                var nr = this._adjacentRight(layout, vim);
                var nl = this._adjacentLeft(layout, vip);
                while (nr != null && nl != null) {
                    vim = nr;
                    vip = nl;
                    vom = this._adjacentLeft(layout, vom) || vom;
                    vop = this._adjacentRight(layout, vop) || vop;
                    var parms = layout._mEqualities[vop.name];
                    parms.ancestor = v;
                    var shift = (layout._mEqualities[vim.name].prelim + sim) -
                        (layout._mEqualities[vip.name].prelim + sip) + this._getSpace(layout, vim, vip, false);
                    if (shift > 0) {
                        this._shiftSubTree(layout, this._ancestorShape(layout, vim, v, a), v, shift);
                        sip += shift;
                        sop += shift;
                    }
                    if (!vom || !vop)
                        break;
                    sim += layout._mEqualities[vim.name].mod;
                    sip += layout._mEqualities[vip.name].mod;
                    som += layout._mEqualities[vom.name].mod;
                    sop += layout._mEqualities[vop.name].mod;

                    nr = this._adjacentRight(layout, vim);
                    nl = this._adjacentLeft(layout, vip);
                    if (this._adjacentRight(layout, vop) == null || this._adjacentLeft(layout, vom) == null)
                        break;
                }
                if (nr != null && this._adjacentRight(layout, vop) == null) {
                    var vopp = layout._mEqualities[vop.name];
                    vopp.thread = nr;
                    vopp.mod += sim - sop;
                }
                if (nl != null && this._adjacentLeft(layout, vom) == null) {
                    var vomp = layout._mEqualities[vom.name];
                    vomp.thread = nl;
                    vomp.mod += sip - som;
                    a = v;
                }
            }
            return a;
        },

        _adjacentLeft: function (layout, shape) {
            var tempshape = null;
            if (shape.isExpanded) tempshape = this._getFirstChild(layout, shape);
            return (tempshape || layout._mEqualities[shape.name].thread);
        },

        _adjacentRight: function (layout, shape) {
            var tempShape = null;
            if (shape.isExpanded) tempShape = this._getLastChild(layout, shape);
            return (tempShape || layout._mEqualities[shape.name].thread);
        },

        _shiftSubTree: function (layout, shape, shape2, shift) {
            var wmp = layout._mEqualities[shape.name];
            var wpp = layout._mEqualities[shape2.name];
            var distance = wpp.number - wmp.number;
            wpp.change -= shift / distance;
            wmp.change += shift / distance;
            wpp.shift += shift;
            wpp.prelim += shift;
            wpp.mod += shift;
        },

        _translateShapePosition: function (layout, shape) {
            var shift = 0, change = 0;
            var c;
            var index;
            for (c = this._getLastChild(layout, shape), index = shape.outEdges.length - 1; c != null; c = this._getPrevSibling(layout, shape, c.name), index--) {
                var cp = layout._mEqualities[c.name];
                cp.prelim += shift;
                cp.mod += shift;
                change += cp.change;
                shift += cp.shift + change;
            }
        },

        _ancestorShape: function (layout, shape, shape1, adjucentShape) {
            var parentshape = this._getParentNode(layout, shape1);
            var shapeLayoutInfo = layout._mEqualities[shape.name];
            if (shapeLayoutInfo.ancestor != null && this._getParentNode(layout, shapeLayoutInfo.ancestor) == parentshape) {
                return shapeLayoutInfo.ancestor;
            }
            else {
                return adjucentShape;
            }
        },

        _doSecondWalk: function (layout, node, previousShape, space, depth, diagram) {
            var np = layout._mEqualities[node.name];
            if (layout.orientation == "lefttoright" || layout.orientation == "righttoleft") {
                this._setBreadthSpace(layout, node, layout._mDepths[depth], diagram);
                this._setDepthSpace(layout, node, np.prelim + space, diagram);
            }
            else {
                this._setBreadthSpace(layout, node, np.prelim + space + (np.waterfallMod || 0) + node.width / 2, diagram);
                this._setDepthSpace(layout, node, layout._mDepths[depth], diagram);
            }
            if (node.isExpanded && this._hasChild(layout, node)) {
                depth += 1;
                var i = 0;
                if (depth < layout.level || layout.level === null) {
                    for (var c = this._getFirstChild(layout, node) ; c != null; c = this._getNextSibling(layout, node, c.name), i++) {
                        this._doSecondWalk(layout, c, node, space + np.mod, depth, diagram);
                    }
                }
                else {
                    for (var c = this._getFirstChild(layout, node, true) ; c != null; c = this._getNextSibling(layout, node, c.name, true), i++) {
                        this._waterFallSecondWalk(layout, c, node.offsetX - node.width / 2 - np.waterfallMod || 0, depth, diagram);
                    }
                }
            }
            if (layout._firstLevelNodes.indexOf(node) != -1) {
                var nextnode = null;

                if (layout._firstLevelNodes.indexOf(node) < layout._firstLevelNodes.length - 1) {
                    nextnode = layout._firstLevelNodes[layout._firstLevelNodes.indexOf(node) + 1];
                }
                if (nextnode != null) {
                    this._doSecondWalk(layout, nextnode, null, space, 0, diagram);
                }
            }

            //np.ClearInfo();
        },

        isContainer: function (shape, diagram) {
            var status = true;
            if (shape && diagram && shape.type == "group" && shape.container) {
                status = false;
            }
            return status;
        },

        _waterFallSecondWalk: function (layout, shape, space, depth, diagram) {
            var layoutInfo = layout._mEqualities[shape.name];
            var offX = layoutInfo.dimensions.x + space + shape.width / 2 + layoutInfo.mod;
            var offY = layoutInfo.dimensions.y + shape.height / 2 + layout._mDepths[depth - 1];
            diagram._translate(shape, -shape.offsetX + offX, -shape.offsetY + offY, diagram.nameTable, this.isContainer(shape, diagram));
            if (shape.isExpanded)
                for (var c = this._getFirstChild(layout, shape, true) ; c != null; c = this._getNextSibling(layout, shape, c.name, true)) {
                    this._waterFallSecondWalk(layout, c, space + layoutInfo.mod, depth, diagram);
                }
        },
        _setBreadthSpace: function (layout, shapeNext, space, diagram) {
            if (layout.orientation == "righttoleft") {
                this._setX(shapeNext, layout._mAnchorX + space - shapeNext.width / 2, diagram);
            }
            else
                if (layout.orientation == "lefttoright") {
                    this._setX(shapeNext, layout._mAnchorX + space + shapeNext.width / 2, diagram);
                }
                else {
                    this._setX(shapeNext, layout._mAnchorX + space, diagram);
                }
        },

        _setDepthSpace: function (layout, shapeNext, space, diagram) {
            if (layout.orientation == "bottomtotop") {
                this._setY(shapeNext, layout._mAnchorY + space - shapeNext.height / 2, diagram);
            }
            else if (layout.orientation == "toptobottom") {
                this._setY(shapeNext, layout._mAnchorY + space + shapeNext.height / 2, diagram);
            }
            else
                this._setY(shapeNext, layout._mAnchorY + space, diagram);
        },
        _setX: function (item, x, diagram) {
            diagram._translate(item, -item.offsetX + x, 0, diagram.nameTable, this.isContainer(item, diagram), true);
        },
        _setY: function (item, y, diagram) {
            diagram._translate(item, 0, -item.offsetY + y, diagram.nameTable, this.isContainer(item, diagram), true);
        },
        _doWaterFallFirstWalk: function (layout, shape, parent, bounds, x, y, limit) {
            if (!limit) limit = { x: 0, y: 0 };
            if (!layout._mEqualities[shape.name]) {
                var layoutInfo = {};
                this._setUpLayoutInfo(shape, layoutInfo);
                layout._mEqualities[shape.name] = layoutInfo;
            }
            else {
                var layoutInfo = layout._mEqualities[shape.name];
            }
            if (!parent) {
                var bounds = { x: 0, y: 0, right: 0, bottom: 0 };
                var initx = 0, inity = 0;
                layoutInfo.dimensions = { x: x, y: y };
            }
            else {
                var parentInfo = layout._mEqualities[parent.name];
                layoutInfo.dimensions = { x: x, y: y };
            }
            var leftMostShape = this._getFirstChild(layout, shape, true);
            var v = y + shape.height + layout.verticalSpacing / 2;
            var h;
            var c = leftMostShape;
            var ver = v;
            var leftChilds = [];
            if (shape.isExpanded && this._hasChild(layout, shape)) {
                if (layoutInfo.waterfallChildren.length > 1 && layoutInfo.waterfallChildren.length <= 2 || !layoutInfo.split) {
                    h = x + shape.width / 2 + 20;
                    for (var i = 0; c != null; i++, c = this._getNextSibling(layout, shape, c.name, true)) {
                        var bnds = this._doWaterFallFirstWalk(layout, c, shape, bounds, h, v, { x: 0, y: 0 });
                        v = bnds.bottom + layout.verticalSpacing / 2;
                        limit.x = Math.max(bnds.right, limit.x);
                        limit.y = Math.max(bnds.bottom, limit.y);
                        bounds.right = Math.max(bounds.right, bnds.right);
                        bounds.bottom = Math.max(bounds.bottom, bnds.bottom);
                    }
                }
                else {
                    for (var i = 0; c != null && (i < shape.outEdges.length) ; i = i + 2, c = this._getNextSibling(layout, shape, c.name, true, 2)) {
                        h = x;
                        var bnds = this._doWaterFallFirstWalk(layout, c, shape, bounds, h, v, { x: 0, y: 0 });
                        layout._mEqualities[c.name].bounds = bnds;
                        v = bnds.bottom + layout.verticalSpacing / 2;
                        leftChilds.push({ name: c.name, right: bnds.right });
                        limit.x = Math.max(bnds.right, limit.x);
                        limit.y = Math.max(bnds.bottom, limit.y);
                        bounds.right = Math.max(bounds.right, bnds.right);
                        bounds.bottom = Math.max(bounds.bottom, bnds.bottom);
                    }
                    if (leftChilds.length > 1) {
                        for (var i = 0; i < leftChilds.length; i++) {
                            layout._mEqualities[leftChilds[i].name].mod = limit.x - leftChilds[i].right;
                        }
                    }
                    layoutInfo.dimensions.x = shape.outEdges.length > 1 ? limit.x + 20 - shape.width / 2 : layout._mEqualities[leftMostShape.name].dimensions.x;
                    h = limit.x + 40;
                    v = ver;
                    c = this._getNextSibling(layout, shape, leftMostShape.name, true);
                    for (var i = 1; c != null && i < shape.outEdges.length; i = i + 2, c = this._getNextSibling(layout, shape, c.name, true, 2)) {
                        var bnds = this._doWaterFallFirstWalk(layout, c, shape, bounds, h, v, { x: 0, y: 0 });
                        v = bnds.bottom + layout.verticalSpacing / 2;
                        bounds.right = Math.max(bounds.right, bnds.right);
                        bounds.bottom = Math.max(bounds.bottom, bnds.bottom);
                        limit.x = Math.max(bnds.right, limit.x);
                        limit.y = Math.max(bnds.bottom, limit.y);
                    }
                }
                return !parent ? bounds : { x: 0, y: 0, right: limit.x, bottom: limit.y };
            }
            else return { x: x || 0, y: y || 0, right: (x || 0) + shape.width, bottom: (y || 0) + shape.height };
        }
        // #endregion

    };
    //end region
})(jQuery, Syncfusion);;

(function ($, ej) {
    "use strict";

    //#region ZoomAndPan
    ej.datavisualization.Diagram.ZoomUtil = {
        zoomPan: function (diagram, currentZoom, deltaX, deltaY, focusPoint, isZoom) {
            if (ej.datavisualization.Diagram.Util.canZooming(diagram)) {
                var matrix = ej.Matrix.identity();
                ej.Matrix.scale(matrix, diagram._currZoom, diagram._currZoom);
                ej.Matrix.translate(matrix, -diagram._hScrollOffset, -diagram._vScrollOffset);
                var newScale = diagram._currZoom * currentZoom;
                if (newScale > 30) {
                    currentZoom = 30 / diagram._currZoom;
                }
                else if (newScale < 0.25) {
                    currentZoom = 0.25 / diagram._currZoom;
                }
                var dMatrix = ej.Matrix.identity();
                var pivot;
                if (focusPoint) {
                    pivot = ej.Matrix.transform(matrix, focusPoint);
                }
                else {
                    pivot = ej.datavisualization.Diagram.Point($(diagram.element).width() / 2, $(diagram.element).height() / 2);
                }
                ej.Matrix.scale(dMatrix, currentZoom, currentZoom, pivot.x, pivot.y);
                newScale = diagram._currZoom * currentZoom;
                ej.Matrix.translate(dMatrix, deltaX, deltaY);
                ej.Matrix.multiply(matrix, dMatrix);
                var point = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(0, 0));
                this._applyTransform(diagram, newScale, point, isZoom);
            }
        },
        _applyTransform: function (diagram, currentZoom, point, isZoom) {
            diagram._currZoom = currentZoom;
            var zoomX = point.x * -1;
            var zoomY = point.y * -1;
            if (!isZoom) {
                if (diagram._scrollLimit() !== ej.datavisualization.Diagram.ScrollLimit.Infinity) {
                    if (zoomX < diagram._hScrollbar.model.minimum)
                        zoomX = diagram._hScrollbar.model.minimum;
                    else if (zoomX > diagram._hScrollbar.model.maximum) {
                        zoomX = diagram._hScrollbar.model.maximum;
                    }
                    if (zoomY < diagram._vScrollbar.model.minimum)
                        zoomY = diagram._vScrollbar.model.minimum;
                    else if (zoomY > diagram._vScrollbar.model.maximum) {
                        zoomY = diagram._vScrollbar.model.maximum;
                    }
                }
            }
            diagram._updateScrollOffset(zoomX, zoomY, true, isZoom);
        }
    };
    //#endregion 

    //#region PageSettings
    ej.datavisualization.Diagram.PageUtil = {
        _createPageBreaks: function (diagram) {
            this._removePageBreaks(diagram);
            var attr = { id: diagram._canvas.id + "pagebreaks", "pointer-events": "none" };
            var g = ej.datavisualization.Diagram.SvgContext._initializePageBreaks(diagram._svg, attr, diagram._pageBackgroundLayer);
            this._updatePageBreaks(g, diagram);
        },
        _removePageBreaks: function (diagram) {
            var g = diagram._svg.getElementById(diagram._canvas.id + "pagebreaks");
            if (g) { ej.datavisualization.Diagram.SvgContext._removePageBreaks(diagram._svg, g, diagram._pageBackgroundLayer); }
        },
        _updatePageBreaks: function (g, diagram) {
            var bounds = diagram._getDigramBounds();
            var pageSettings = diagram.model.pageSettings;
            var left = bounds.x;
            var right = bounds.width +bounds.x;
            var top = bounds.y;
            var bottom = bounds.height + bounds.y;
            var zoom = diagram._currZoom;
            var pHeight = diagram._pageHeight();
            var pWidth = diagram._pageWidth();
            var pMargin = diagram._pageMargin();
            var columncount = parseInt(Math.ceil((right - left) / pWidth));
            var rowcount = parseInt(Math.ceil((bottom - top) / pHeight));
            left = -diagram._canvas.clientLeft + (pMargin + left) * zoom;
            top = -diagram._canvas.clientTop + (pMargin + top) * zoom;
            var width = (pWidth * columncount - pMargin * 2) * zoom;
            var height = (pHeight * rowcount - pMargin * 2) * zoom;
            ej.datavisualization.Diagram.SvgContext._renderVPageBreakLine(ej.datavisualization.Diagram.Point(left, top), ej.datavisualization.Diagram.Point(left + width, top), diagram._svg, g);
            ej.datavisualization.Diagram.SvgContext._renderHPageBreakLine(ej.datavisualization.Diagram.Point(left, top), ej.datavisualization.Diagram.Point(left, top + height), diagram._svg, g);
            for (var column = 1; column < columncount; column++) {
                ej.datavisualization.Diagram.SvgContext._renderVPageBreakLine(ej.datavisualization.Diagram.Point(left + (pWidth * column - pMargin) * zoom, top),
                    ej.datavisualization.Diagram.Point(left + (pWidth * column - pMargin) * zoom, top + height), diagram._svg, g);
            }
            for (var row = 1; row < rowcount; row++) {
                ej.datavisualization.Diagram.SvgContext._renderHPageBreakLine(ej.datavisualization.Diagram.Point(left, top + (pHeight * row - pMargin) * zoom),
                    ej.datavisualization.Diagram.Point(left + width, top + (pHeight * row - pMargin) * zoom), diagram._svg, g);
            }
            ej.datavisualization.Diagram.SvgContext._renderVPageBreakLine(ej.datavisualization.Diagram.Point(left + width, top), ej.datavisualization.Diagram.Point(left + width, top + height), diagram._svg, g);
            ej.datavisualization.Diagram.SvgContext._renderHPageBreakLine(ej.datavisualization.Diagram.Point(left, top + height), ej.datavisualization.Diagram.Point(left + width, top + height), diagram._svg, g);
        },
        _updatePageSize: function (diagram) {
            var swap = false;
            if (diagram._pageOrientation() == ej.datavisualization.Diagram.PageOrientations.Landscape) {
                if (diagram._pageHeight() > diagram._pageWidth()) {
                    swap = true;
                }
            }
            else {
                if (diagram._pageWidth() > diagram._pageHeight()) {
                    swap = true;
                }
            }
            if (swap) {
                var temp = diagram._pageWidth();
                diagram._pageWidth(diagram._pageHeight());
                diagram._pageHeight(temp);
            }
            var bounds = diagram._getDigramBounds();
            var zoom = diagram._currZoom;
            var left = bounds.x * zoom;
            var top = bounds.y * zoom;
            var width = bounds.width * zoom;
            var height = bounds.height * zoom;
            var pageSettings = diagram.model.pageSettings;
            if (diagram._pageBackgroundLayer && diagram._pageBackgroundLayer.firstChild) {
                ej.datavisualization.Diagram.SvgContext._updatePageBakground(ej.datavisualization.Diagram.Point(left, top), ej.datavisualization.Diagram.Point(width, height), diagram._svg, diagram._pageBackgroundLayer, diagram._pageBorderColor(), diagram._pageBackgroundColor(), diagram._pageBorderWidth());
            }
            else {
                ej.datavisualization.Diagram.SvgContext._renderPageSettingsRect(ej.datavisualization.Diagram.Point(left, top), ej.datavisualization.Diagram.Point(width, height), diagram._svg, diagram._pageBackgroundLayer, diagram._pageBorderColor(), diagram._pageBackgroundColor(), diagram._pageBorderWidth());
            }
            diagram._svg.document.style.left = 0;
            diagram._svg.document.style.top = 0;
            var check = false;
            if (!diagram._pageWidth()) {
                if (!diagram._pageHeight()) {
                    check = true;
                }
            }
            if (pageSettings.pageWidth && diagram._pageHeight()) {
                if (diagram._showPageBreak()) {
                    this._createPageBreaks(diagram);
                }
                else {
                    this._removePageBreaks(diagram);
                }
            }
            ej.datavisualization.Diagram.ScrollUtil._setScrollContentSize(diagram);
        }
    };
    //#endregion

    //#region Scroller
    ej.datavisualization.Diagram.ScrollUtil = {
        _transform: function (diagram, hOffset, vOffset, canScale) {
            ej.datavisualization.Diagram.SvgContext.transformView(diagram, -hOffset, -vOffset);
            if (canScale) {
                ej.datavisualization.Diagram.SvgContext.scaleContent(diagram, diagram._currZoom);
            }
            ej.datavisualization.Diagram.PageUtil._updatePageSize(diagram);
            ej.datavisualization.Diagram.SvgContext._updateBackground(hOffset, vOffset, diagram._currZoom, diagram);
            ej.datavisualization.Diagram.SvgContext._updateGrid(hOffset, vOffset, diagram._currZoom, diagram);
        },
        _viewPort: function (diagram) {
            var element = diagram.element[0];
            var eWidth = $(element).width();
            var eHeight = $(element).height();
            var bRect = diagram.element[0].getBoundingClientRect();
            var screenX = (window.screenX < 0) ? window.screenX * -1 : window.screenX;
            if (eWidth === 0) {
                eWidth = Math.floor(((window.innerWidth - screenX) - Math.floor(bRect.left)));
            }
            var screenY = (window.screenY < 0) ? window.screenY * -1 : window.screenY;
            if (eHeight === 0) {
                eHeight = Math.floor(((window.innerHeight - screenY) - Math.floor(bRect.top)));
            }
            return ej.datavisualization.Diagram.Size(eWidth, eHeight);
        },

        _union: function (rect, rect1) {
            if (rect.width <= 0) {
                rect = rect1;
                return rect;
            }
            if (rect.width > 0) {
                var num = Math.min(rect.x, rect1.x);
                var num2 = Math.min(rect.y, rect1.y);
                if (rect1.width === Infinity || rect.width === Infinity) {
                    rect.width = Infinity;
                }
                else {
                    var num3 = Math.max(rect.x + rect.width, rect1.x + rect1.width);
                    rect.width = Math.max(num3 - num, 0);
                }
                if (rect1.height === Infinity || rect.height === Infinity) {
                    rect.height = Infinity;
                }
                else {
                    var num4 = Math.max(rect.y + rect.height, rect1.y + rect1.height);
                    rect.height = Math.max(num4 - num2, 0);
                }
                rect.x = num;
                rect.y = num2;
                return rect;
            }
        },

        _setScrollContentSize: function (diagram) {
            var scale = diagram._currZoom;
            var viewPort = this._viewPort(diagram);
            viewPort = ej.datavisualization.Diagram.Rectangle(diagram._hScrollOffset, diagram._vScrollOffset, viewPort.width, viewPort.height);
            var left = diagram._spatialSearch.pageLeft;
            var right = diagram._spatialSearch.pageRight;
            var top = diagram._spatialSearch.pageTop;
            var bottom = diagram._spatialSearch.pageBottom;
            if (left > right) {
                left = right = 0;
            }
            if (top > bottom) {
                top = bottom = 0;
            }

            if (diagram.model.pageSettings) {
                var pageWidth = diagram._pageWidth();
                var pageHeight = diagram._pageHeight();

                if (pageWidth > 0 && pageHeight > 0) {
                    if (diagram._multiplePage()) {
                        left = Math.floor(left / pageWidth) * pageWidth;
                        top = Math.floor(top / pageHeight) * pageHeight;
                        right = Math.ceil(right / pageWidth) * pageWidth;
                        bottom = Math.ceil(bottom / pageHeight) * pageHeight;
                    }
                    else {
                        left = 0;
                        top = 0;
                        right = pageWidth;
                        bottom = pageHeight;
                    }
                }
                else {
                    left = left < 0 ? left : 0;
                    top = top < 0 ? top : 0;
                    right = right > viewPort.width ? right : viewPort.width;
                    bottom = bottom > viewPort.height ? bottom : viewPort.height;
                }
            }
            left = left * scale;
            top = top * scale;
            right = right * scale;
            bottom = bottom * scale;
            
            var diagramArea = ej.datavisualization.Diagram.Rectangle(0, 0, 0, 0);
            diagramArea = this._union(diagramArea, ej.datavisualization.Diagram.Rectangle(0, 0, viewPort.width, viewPort.height));
            diagramArea = this._union(diagramArea, ej.datavisualization.Diagram.Geometry.rect([{ x: left, y: top }, { x: right, y: bottom }]));

            diagramArea.width -= viewPort.width;
            diagramArea.height -= viewPort.height;

            if (diagramArea.x > diagram._hScrollOffset) {
                var diff = diagramArea.x - diagram._hScrollOffset;
                diagramArea.x -= diff;
                diagramArea.width += diff;
            }
            if (diagram._hScrollOffset > diagramArea.x + diagramArea.width) {
                diagramArea.width = diagram._hScrollOffset - diagramArea.x;
            }

            var minimumX = diagramArea.x;
            var maximumX = Math.max(0, diagramArea.x + diagramArea.width);

            if (diagramArea.y > diagram._vScrollOffset) {
                var diff = diagramArea.y - diagram._vScrollOffset;
                diagramArea.y -= diff;
                diagramArea.height += diff;
            }
            if (diagram._vScrollOffset > diagramArea.y + diagramArea.height) {
                diagramArea.height = diagram._vScrollOffset - diagramArea.y;
            }
            var minimumY = diagramArea.y;
            var maximumY = Math.max(0, diagramArea.y + diagramArea.height);

            diagramArea.width = diagramArea.width < viewPort.width ? viewPort.width : diagramArea.width;
            diagramArea.height = diagramArea.height < viewPort.height ? viewPort.height : diagramArea.height;

            if (diagram._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Limited) {
                var range = this._setMinMaxValues(diagram, minimumX, minimumY, maximumX, maximumY);
                minimumX = range.minX;
                minimumY = range.minY;
                maximumX = range.maxX;
                maximumY = range.maxY;
            }
            
            if (left >= diagram._hScrollOffset && right <= viewPort.width + diagram._hScrollOffset) {
                $("#" + diagram._canvas.id + "_hScrollbar").ejScrollbar("remove");
				diagram._hScrollbar.model.width = 0;
            }
            else {
                $("#" + diagram._canvas.id + "_hScrollbar").ejScrollbar({ width: viewPort.width - 18, viewportSize: viewPort.width - 18, maximum: maximumX, minimum: minimumX });
                $("#" + diagram._canvas.id + "_hScrollbar").ejScrollbar("scrollX", diagram._hScrollOffset);
                var hScroll = document.getElementById(diagram._canvas.id + "_hScrollbar");
                hScroll.style.marginTop = viewPort.height - 18 + "px";
            }

            if (top >= diagram._vScrollOffset && bottom <= viewPort.height + diagram._vScrollOffset) {
                $("#" + diagram._canvas.id + "_vScrollbar").ejScrollbar("remove");
				diagram._vScrollbar.model.height = 0;
            }
            else {
                $("#" + diagram._canvas.id + "_vScrollbar").ejScrollbar({ height: viewPort.height - 18, viewportSize: viewPort.height - 18, maximum: maximumY, minimum: minimumY });
                $("#" + diagram._canvas.id + "_vScrollbar").ejScrollbar("scrollY", diagram._vScrollOffset);
            }
            ej.datavisualization.Diagram.SvgContext.setSize(diagram._svg, diagramArea.width, diagramArea.height);
        },

        _setMinMaxValues: function (diagram, minX, minY, maxX, maxY) {
            var scrollableArea = diagram.model.pageSettings.scrollableArea;
            if (minX < scrollableArea.left)
                minX = scrollableArea.left;
            if (minY < scrollableArea.top)
                minY = scrollableArea.top;
            if (maxX > scrollableArea.right)
                maxX = scrollableArea.right;
            if (maxY > scrollableArea.bottom)
                maxY = scrollableArea.bottom;
            return { minX: minX, minY: minY, maxX: maxX, maxY: maxY }
        },
        
        _initScrollbar: function (diagram) {
            var canvas = diagram._canvas;
            var hScrollbar = document.getElementById(canvas.id + "_hScrollbar");
            var vScrollbar = document.getElementById(canvas.id + "_vScrollbar");
            var viewPort = this._viewPort(diagram);
            $(hScrollbar).ejScrollbar({
                orientation: ej.Scrollbar.Orientation.Horizontal,
                width: viewPort.width - 18,
                viewportSize: viewPort.width - 18,
                scroll: function (e) {
                    if (e.source != null) {
                        if (e.source == "thumb" || e.source == "button" || e.source == "key") {
                            if (e.scrollData != null) {
                                diagram._updateScrollOffset(e.scrollLeft, diagram._vScrollOffset);
                            }
                        }
                    }
                }
            });
            diagram._hScrollbar = $(hScrollbar).ejScrollbar("instance");

            $(vScrollbar).ejScrollbar({
                orientation: ej.Scrollbar.Orientation.Vertical,
                height: viewPort.height - 18,
                viewportSize: viewPort.height - 18,
                scroll: function (e) {
                    if (e.source != null) {
                        if (e.source == "thumb" || e.source == "button" || e.source == "key") {
                            if (e.scrollData != null) {
                                diagram._updateScrollOffset(diagram._hScrollOffset, e.scrollTop);
                            }
                        }
                    }
                }
            });
            diagram._vScrollbar = $(vScrollbar).ejScrollbar("instance");

        },
    };
    //#endregion

    //#region Snapping
    ej.datavisualization.Diagram.SnapUtil = {
        _canConsider: function (nameTable, selectedObject, target) {
            var consider = false;
            if (selectedObject.type == "group") {
                consider = !this._contains(nameTable, selectedObject, target);
            }
            else if (!selectedObject.segments) {
                consider = !(selectedObject == target);
            }
            return consider;
        },
        _contains: function (nameTable, group, child) {
            var name = child.name;
            var node = null;
            if (group.children.indexOf(name) >= 0)
                node = nameTable[name];
            if (node && !node.segments) {
                if (node.type == "group")
                    return this._contains(nameTable, node, child);
                else if (node == child)
                    return true;
            }
            return false;
        },
        _round: function (value, snapintervals, scale) {
            var cutoff = 0, i;
            for (i = 0; i < snapintervals.length; i++) {
                cutoff += snapintervals[i];
            }
            cutoff /= scale;
            var quotient = Math.floor(Math.abs(value) / cutoff);
            var bal = value % cutoff;
            var prev = quotient * cutoff;
            if (value >= 0) {
                for (i = 0; i < snapintervals.length ; i++) {
                    if (bal <= snapintervals[i] / scale) {
                        return prev + (bal < (snapintervals[i] / (2 * scale)) ? 0 : snapintervals[i] / scale);
                    }
                    else {
                        prev += snapintervals[i] / scale;
                        bal -= snapintervals[i] / scale;
                    }
                }
            }
            else {
                prev = prev * -1;
                for (i = snapintervals.length - 1; i >= 0; i--) {
                    if (Math.abs(bal) <= snapintervals[i] / scale) {
                        return prev - (Math.abs(bal) < (snapintervals[i] / (2 * scale)) ? 0 : snapintervals[i] / scale);
                    }
                    else {
                        prev -= snapintervals[i] / scale;
                        bal += snapintervals[i] / scale;
                    }
                }
            }
            return value;
        },
        _findNodes: function (spatialSearch, node, child, viewPort, nodesInView) {
            var nodes = [], quad, nd, bounds;
            var quads = ej.datavisualization.Diagram.SpatialUtil.findQuads(spatialSearch, viewPort);
            var childBounds = ej.datavisualization.Diagram.Util.bounds(child);
            for (var i = 0; i < quads.length; i++) {
                quad = quads[i];
                if (quad.objects.length > 0) {
                    for (var j = 0; j < quad.objects.length; j++) {
                        nd = quad.objects[j];
                        if (!nd.segments) {
                            bounds = ej.datavisualization.Diagram.Util.bounds(nd);
                            if (nodes.indexOf(nd) == -1 && ej.datavisualization.Diagram.Geometry.intersectsRect(childBounds, bounds))
                                nodes.push(nd);
                            if (nodesInView && nodesInView.indexOf(nd) && ej.datavisualization.Diagram.Geometry.intersectsRect(viewPort, bounds)) {
                                nodesInView.push(nd);
                            }
                        }
                    }
                }
            }
            return nodes;
        },
        _snapAngle: function (diagram, angle) {
            var snapAngle = diagram._snapAngle();
            var width = angle % snapAngle;
            if (width >= (snapAngle / 2)) {
                return angle + snapAngle - width;
            }
            else {
                return angle - width;
            }
        },
        _snapPoint: function (diagram, selectedObject, towardsLeft, towardsTop, del, endPoint, startPoint) {
            var snapSettings = diagram.model.snapSettings;
            var zoomFactor = diagram._currZoom;
            var offset = ej.datavisualization.Diagram.Point();
            var bounds = ej.datavisualization.Diagram.Util.bounds(selectedObject);
            var horizontallysnapped = { snapped: false, offset: 0 };
            var verticallysnapped = { snapped: false, offset: 0 };
            if (diagram._enableSnapToObject())
                this._snapObject(diagram, selectedObject, horizontallysnapped,
                    verticallysnapped, del, startPoint == endPoint);
            //original position
            var left = bounds.x + del.x;
            var top = bounds.y + del.y;
            var right = bounds.x + bounds.width + del.x;
            var bottom = bounds.y + bounds.height + del.y;
            //snapped positions
            var roundedRight = this._round(right, snapSettings.verticalGridLines.snapInterval, zoomFactor);
            var roundedLeft = this._round(left, snapSettings.verticalGridLines.snapInterval, zoomFactor);
            var roundedTop = this._round(top, snapSettings.horizontalGridLines.snapInterval, zoomFactor);
            var roundedBottom = this._round(bottom, snapSettings.horizontalGridLines.snapInterval, zoomFactor);
            //currentposition
            var currentright = bounds.x + bounds.width;
            var currentbottom = bounds.y + bounds.height;
            if (!horizontallysnapped.snapped) {
                if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToVerticalLines) {
                    if (Math.abs(del.x) >= 1) {
                        if (towardsLeft) {
                            if (Math.abs(roundedRight - currentright) > Math.abs(roundedLeft - bounds.x)) {
                                offset.x += roundedLeft - bounds.x;
                            } else
                                offset.x += roundedRight - currentright;
                        } else {
                            if (Math.abs(roundedRight - currentright) < Math.abs(roundedLeft - bounds.x)) {
                                offset.x += roundedRight - currentright;
                            } else
                                offset.x += roundedLeft - bounds.x;
                        }
                    }
                } else {
                    offset.x = endPoint.x - startPoint.x;
                }
            } else {
                if (diagram._enableSnapToObject())
                    offset.x = horizontallysnapped.offset;
                else
                    offset.x = endPoint.x - startPoint.x;
            }
            if (!verticallysnapped.snapped) {
                if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToHorizontalLines) {
                    if (Math.abs(del.y) >= 1) {
                        if (towardsTop) {
                            if (Math.abs(roundedBottom - currentbottom) > Math.abs(roundedTop - bounds.y)) {
                                offset.y += roundedTop - bounds.y;
                            }
                            else
                                offset.y += roundedBottom - currentbottom;
                        }
                        else {
                            if (Math.abs(roundedBottom - currentbottom) < Math.abs(roundedTop - bounds.y)) {
                                offset.y += roundedBottom - currentbottom;
                            }
                            else
                                offset.y += roundedTop - bounds.y;
                        }
                    }
                }
                else
                    offset.y = endPoint.y - startPoint.y;
            }
            else
                offset.y = verticallysnapped.offset;

            return offset;
        },
        _snapObject: function (diagram, selectedObject, hSnap, vSnap, del, ended) {
            var lengthX = null, lengthY = null;
            var hTarget, vTarget;
            var objectsAtLeft = [], objectsAtRight = [], objectsAtTop = [], objectsAtBottom = [];
            var bounds = ej.datavisualization.Diagram.Util.bounds(selectedObject);
            var scale = diagram._currZoom;
            var hoffset = diagram._hScrollOffset;
            var voffset = diagram._vScrollOffset;
            var snapObjDistance = diagram._snapObjectDistance();
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(diagram);
            var hIntersectRect = ej.datavisualization.Diagram.Rectangle(hoffset / scale, (bounds.y - 5), viewPort.width / scale,
                (bounds.height + 10));
            var vIntersectRect = ej.datavisualization.Diagram.Rectangle((bounds.x - 5), voffset / scale,
                (bounds.width + 10), viewPort.height / scale);
            viewPort = ej.datavisualization.Diagram.Rectangle(hoffset / scale, voffset / scale, viewPort.width / scale,
                viewPort.height / scale);
            var nodes = this._findNodes(diagram._spatialSearch, selectedObject, vIntersectRect, viewPort);
            var i, target, targetBounds;
            var nameTable = diagram.nameTable;
            for (i = 0; i < nodes.length; i++) {
                target = nodes[i];
                if (!target.segments && this._canConsider(nameTable, selectedObject, target)) {
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(target);
                    if (targetBounds.y + targetBounds.height < bounds.y + del.y) {
                        objectsAtTop.push({ object: target, distance: Math.abs(bounds.y + del.y - targetBounds.y - targetBounds.height) });
                    }
                    else if (targetBounds.y > bounds.y + del.y + bounds.height) {
                        objectsAtBottom.push({ object: target, distance: Math.abs(bounds.y + del.y + bounds.height - targetBounds.y) });
                    }
                    if (lengthX == null || lengthX > Math.abs(targetBounds.y - bounds.y - del.y)) {
                        if (Math.abs(targetBounds.x + targetBounds.width / 2 - (bounds.x + bounds.width / 2 + del.x)) <= snapObjDistance) {
                            hTarget = this._createSnapObject(targetBounds, bounds, "centerX");
                            lengthX = Math.abs(targetBounds.y - bounds.y);
                        } else if (Math.abs(targetBounds.x - (bounds.x + del.x)) <= snapObjDistance) {
                            hTarget = this._createSnapObject(targetBounds, bounds, "left");
                            lengthX = Math.abs(targetBounds.y - bounds.y);
                        } else if (Math.abs(targetBounds.x + targetBounds.width - (bounds.x + bounds.width + del.x)) <= snapObjDistance) {
                            hTarget = this._createSnapObject(targetBounds, bounds, "right");
                            lengthX = Math.abs(targetBounds.y - bounds.y);
                        } else if (Math.abs(targetBounds.x + targetBounds.width - (bounds.x + del.x)) <= snapObjDistance) {
                            hTarget = this._createSnapObject(targetBounds, bounds, "leftRight");
                            lengthX = Math.abs(targetBounds.y - bounds.y);
                        } else if (Math.abs(targetBounds.x - (bounds.x + bounds.width + del.x)) <= snapObjDistance) {
                            hTarget = this._createSnapObject(targetBounds, bounds, "rightLeft");
                            lengthX = Math.abs(targetBounds.y - bounds.y);
                        }
                    }
                }
            }
            nodes = this._findNodes(diagram._spatialSearch, selectedObject, hIntersectRect, viewPort);
            for (i = 0; i < nodes.length; i++) {
                target = nodes[i];
                if (!target.segments && this._canConsider(nameTable, selectedObject, target)) {
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(target);
                    if (targetBounds.x + targetBounds.width < bounds.x + del.x) {
                        objectsAtLeft[objectsAtLeft.length] = { object: target, distance: Math.abs((bounds.x + del.x) - targetBounds.x - targetBounds.width) };
                    }
                    if (targetBounds.x > bounds.x + del.x + bounds.width) {
                        objectsAtRight[objectsAtRight.length] = { object: target, distance: Math.abs(bounds.x + del.x + bounds.width - targetBounds.x) };
                    }
                    if (lengthY == null || lengthY > Math.abs(targetBounds.x - bounds.x - del.x)) {
                        if (Math.abs(targetBounds.y + targetBounds.height / 2 - (bounds.y + bounds.height / 2 + del.y)) <= snapObjDistance) {
                            vTarget = this._createSnapObject(targetBounds, bounds, "centerY");
                            lengthY = Math.abs(targetBounds.x - bounds.x);
                        } else if (Math.abs(targetBounds.y - bounds.y - del.y) <= snapObjDistance) {
                            vTarget = this._createSnapObject(targetBounds, bounds, "top");
                            lengthY = Math.abs(targetBounds.x - bounds.x);
                        } else if (Math.abs(targetBounds.y + targetBounds.height - (bounds.y + bounds.height + del.y)) <= snapObjDistance) {
                            vTarget = this._createSnapObject(targetBounds, bounds, "bottom");
                            lengthY = Math.abs(targetBounds.x - bounds.x);
                        } else if (Math.abs(targetBounds.y + targetBounds.height - bounds.y - del.y) <= snapObjDistance) {
                            vTarget = this._createSnapObject(targetBounds, bounds, "topBottom");
                            lengthY = Math.abs(targetBounds.x - bounds.x);
                        } else if (Math.abs(targetBounds.y - (bounds.y + bounds.height + del.y)) <= snapObjDistance) {
                            vTarget = this._createSnapObject(targetBounds, bounds, "bottomTop");
                            lengthY = Math.abs(targetBounds.x - bounds.x);
                        }
                    }
                }
            }
            var g = this._createGuidelines(diagram, hTarget, vTarget, hSnap, vSnap, ended);
            if (!hSnap.snapped) {
                this._createHSpacingLines(diagram, selectedObject, objectsAtLeft, objectsAtRight, hSnap, vSnap, ended, g, del, snapObjDistance);
            }
            if (!vSnap.snapped) {
                this._createVSpacingLines(diagram, selectedObject, objectsAtTop, objectsAtBottom, hSnap, vSnap, ended, g, del, snapObjDistance);
            }
        },
        _snapSize: function (diagram, hSnap, vSnap, delx, dely, selectedObject, ended) {
            var lengthX = null, lengthY = null;
            var hTarget;
            var vTarget;
            var bounds = ej.datavisualization.Diagram.Util.bounds(selectedObject);
            var nameTable = diagram.nameTable;
            var sameWidth = [];
            var sameHeight = [];
            var scale = diagram._currZoom;
            var hoffset = diagram._hScrollOffset;
            var voffset = diagram._vScrollOffset;
            var snapObjDistance = diagram._snapObjectDistance();
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(diagram);
            var hintersectedrect = ej.datavisualization.Diagram.Rectangle(hoffset / scale, (bounds.y - 5) / scale,
                viewPort.width / scale, (bounds.height + 10) / scale);
            var vintersectedrect = ej.datavisualization.Diagram.Rectangle((bounds.x - 5) / scale, voffset / scale,
                (bounds.width + 10) / scale, viewPort.height / scale);
            viewPort = ej.datavisualization.Diagram.Rectangle(hoffset / scale, voffset / scale, viewPort.width / scale,
               viewPort.height / scale);
            var nodesInView = [];
            var nodes = this._findNodes(diagram._spatialSearch, selectedObject, vintersectedrect, viewPort, nodesInView);
            var i, target, targetBounds;
            for (i = 0; i < nodes.length; i++) {
                target = nodes[i];
                if (this._canConsider(nameTable, selectedObject, target) && !target.segments) {
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(target);
                    if (lengthX == null || lengthX > Math.abs(targetBounds.y - bounds.y)) {
                        if (hSnap.left) {
                            if (Math.abs(bounds.x + delx - targetBounds.x) <= snapObjDistance) {
                                hTarget = this._createSnapObject(targetBounds, bounds, "left");
                                lengthX = Math.abs(targetBounds.y - bounds.y);
                            }
                            else if (Math.abs(bounds.x + delx - targetBounds.x - targetBounds.width) <= snapObjDistance) {
                                hTarget = this._createSnapObject(targetBounds, bounds, "leftRight");
                                lengthX = Math.abs(targetBounds.y - bounds.y);
                            }
                        }
                        else if (hSnap.right) {
                            if (Math.abs(bounds.x + delx + bounds.width - targetBounds.x - targetBounds.width) <= snapObjDistance) {
                                hTarget = this._createSnapObject(targetBounds, bounds, "right");
                                lengthX = Math.abs(targetBounds.y - bounds.y);
                            }
                            else if (Math.abs(bounds.x + delx + bounds.width - targetBounds.x) <= snapObjDistance) {
                                hTarget = this._createSnapObject(targetBounds, bounds, "rightLeft");
                                lengthX = Math.abs(targetBounds.y - bounds.y);
                            }
                        }
                    }
                }
            }
            nodes = this._findNodes(diagram._spatialSearch, selectedObject, hintersectedrect, viewPort);
            for (i = 0; i < nodes.length; i++) {
                target = nodes[i];
                if (this._canConsider(nameTable, selectedObject, target) && !target.segments) {
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(target);
                    if (lengthY == null || lengthY > Math.abs(targetBounds.x - bounds.x)) {
                        if (vSnap.top) {
                            if (Math.abs(bounds.y + dely - targetBounds.y) <= snapObjDistance) {
                                vTarget = this._createSnapObject(targetBounds, bounds, "top");
                                lengthY = Math.abs(targetBounds.x - bounds.x);
                            }
                            else if (Math.abs(bounds.y + dely - targetBounds.y - targetBounds.height) <= snapObjDistance) {
                                vTarget = this._createSnapObject(targetBounds, bounds, "topBottom");
                                lengthY = Math.abs(targetBounds.x - bounds.x);
                            }
                        }
                        else if (vSnap.bottom) {
                            if (Math.abs(bounds.y + bounds.height + dely - targetBounds.y - targetBounds.height) <= snapObjDistance) {
                                vTarget = this._createSnapObject(targetBounds, bounds, "bottom");
                                lengthY = Math.abs(targetBounds.x - bounds.x);
                            }
                            else if (Math.abs(bounds.y + bounds.height + dely - targetBounds.y) <= snapObjDistance) {
                                vTarget = this._createSnapObject(targetBounds, bounds, "bottomTop");
                                lengthY = Math.abs(targetBounds.x - bounds.x);
                            }
                        }
                    }
                }
            }
            for (i = 0; i < nodesInView.length; i++) {
                target = nodesInView[i];
                if (this._canConsider(nameTable, selectedObject, target)) {
                    var targetbounds = ej.datavisualization.Diagram.Util.bounds(target);
                    var del = hSnap.left ? -delx : delx;
                    var diff = Math.abs(bounds.width + del - targetbounds.width);
                    var actualDiff;
                    if (diff <= snapObjDistance) {
                        actualDiff = hSnap.left ? -targetbounds.width + bounds.width : targetbounds.width - bounds.width;
                        sameWidth[sameWidth.length] = { source: target, diff: diff, offset: actualDiff };
                    }
                    del = vSnap.top ? -dely : dely;
                    var dify = Math.abs(bounds.height + del - targetbounds.height);
                    if (dify <= snapObjDistance) {
                        actualDiff = vSnap.top ? -targetbounds.height + bounds.height : targetbounds.height - bounds.height;
                        sameHeight[sameHeight.length] = { source: target, diff: dify, offset: actualDiff };
                    }
                }
            }
            var g = this._createGuidelines(diagram, hTarget, vTarget, hSnap, vSnap, ended);
            if (!hSnap.snapped && sameWidth.length > 0 && (hSnap.left || hSnap.right)) {
                this._addSameWidthLines(diagram, sameWidth, hSnap, ended, g, selectedObject);
            }
            if (!vSnap.snapped && sameHeight.length > 0 && (vSnap.top || vSnap.bottom)) {
                this._addSameHeightLines(diagram, sameHeight, vSnap, ended, g, selectedObject);
            }
        },
        _createSnapObject: function (targetbounds, bounds, snap) {
            var snapObject;
            switch (snap) {
                case "left":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(targetbounds.x, Math.min(targetbounds.y, bounds.y)),
                        end: ej.datavisualization.Diagram.Point(targetbounds.x, Math.max(targetbounds.y + targetbounds.height, bounds.y + bounds.height)),
                        offsetX: targetbounds.x - bounds.x, offsetY: 0, type: "sideAlign"
                    };
                    break;
                case "right":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(targetbounds.x + targetbounds.width, Math.min(targetbounds.y, bounds.y)),
                        end: ej.datavisualization.Diagram.Point(targetbounds.x + targetbounds.width, Math.max(targetbounds.y + targetbounds.height, bounds.y + bounds.height)),
                        offsetX: targetbounds.x + targetbounds.width - bounds.x - bounds.width, offsetY: 0, type: "sideAlign"
                    };
                    break;
                case "top":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(Math.min(targetbounds.x, bounds.x), targetbounds.y),
                        end: ej.datavisualization.Diagram.Point(Math.max(targetbounds.x + targetbounds.width, bounds.x + bounds.width), targetbounds.y),
                        offsetY: targetbounds.y - bounds.y, offsetX: 0, type: "sideAlign"
                    };
                    break;
                case "bottom":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(Math.min(targetbounds.x, bounds.x), targetbounds.y + targetbounds.height),
                        end: ej.datavisualization.Diagram.Point(Math.max(targetbounds.x + targetbounds.width, bounds.x + bounds.width), targetbounds.y + targetbounds.height),
                        offsetY: targetbounds.y + targetbounds.height - bounds.y - bounds.height, offsetX: 0, type: "sideAlign"
                    };
                    break;
                case "topBottom":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(Math.min(targetbounds.x, bounds.x), targetbounds.y + targetbounds.height),
                        end: ej.datavisualization.Diagram.Point(Math.max(targetbounds.x + targetbounds.width, bounds.x + bounds.width), targetbounds.y + targetbounds.height),
                        offsetY: targetbounds.y + targetbounds.height - bounds.y, offsetX: 0, type: "sideAlign"
                    };
                    break;
                case "bottomTop":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(Math.min(targetbounds.x, bounds.x), targetbounds.y),
                        end: ej.datavisualization.Diagram.Point(Math.max(targetbounds.x + targetbounds.width, bounds.x + bounds.width), targetbounds.y),
                        offsetY: targetbounds.y - bounds.y - bounds.height, offsetX: 0, type: "sideAlign"
                    };
                    break;
                case "leftRight":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(targetbounds.x + targetbounds.width, Math.min(targetbounds.y, bounds.y)),
                        end: ej.datavisualization.Diagram.Point(targetbounds.x + targetbounds.width, Math.max(targetbounds.y + targetbounds.height, bounds.y + bounds.height)),
                        offsetX: targetbounds.x + targetbounds.width - bounds.x, offsetY: 0, type: "sideAlign"
                    };
                    break;
                case "rightLeft":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(targetbounds.x, Math.min(targetbounds.y, bounds.y)),
                        end: ej.datavisualization.Diagram.Point(targetbounds.x, Math.max(targetbounds.y + targetbounds.height, bounds.y + bounds.height)),
                        offsetX: targetbounds.x - bounds.x - bounds.width, offsetY: 0, type: "sideAlign"
                    };
                    break;
                case "centerX":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(targetbounds.x + targetbounds.width / 2, Math.min(targetbounds.y, bounds.y)),
                        end: ej.datavisualization.Diagram.Point(targetbounds.x + targetbounds.width / 2, Math.max(targetbounds.y + targetbounds.height, bounds.y + bounds.height)),
                        offsetX: targetbounds.x + targetbounds.width / 2 - (bounds.x + bounds.width / 2), offsetY: 0, type: "centerAlign"
                    };
                    break;
                case "centerY":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(Math.min(targetbounds.x, bounds.x), targetbounds.y + targetbounds.height / 2),
                        end: ej.datavisualization.Diagram.Point(Math.max(targetbounds.x + targetbounds.width, bounds.x + bounds.width), targetbounds.y + targetbounds.height / 2),
                        offsetY: targetbounds.y + targetbounds.height / 2 - (bounds.y + bounds.height / 2), offsetX: 0, type: "centerAlign"
                    };
                    break;
            }
            return snapObject;
        },
        _createGuidelines: function (diagram, hTarget, vTarget, hsnap, vsnap, ended) {
            var attr = { id: diagram._canvas.id + "guideline", "pointer-events": "none", "style": "pointer-events:none;" };
            var g = ej.datavisualization.Diagram.SvgContext._initializeGuidelines(diagram._svg, attr, diagram._adornerLayer);
            var scale = diagram._currZoom;
            var hOffset = diagram._hScrollOffset;
            var vOffset = diagram._vScrollOffset;
            if (hTarget) {
                hsnap.offset = hTarget.offsetX;
                hsnap.snapped = true;
                if (!ended) {
                    if (hTarget.type == "sideAlign") {
                        ej.datavisualization.Diagram.SvgContext._renderSideAlignmentLines(hTarget.start, hTarget.end, g, diagram._svg, scale, hOffset, vOffset);
                    }
                    else if (hTarget.type == "centerAlign") {
                        ej.datavisualization.Diagram.SvgContext._renderCenterAlignmentLines(hTarget.start, hTarget.end, g, diagram._svg, scale, hOffset, vOffset);
                    }
                }
            }
            if (vTarget) {
                vsnap.offset = vTarget.offsetY;
                vsnap.snapped = true;
                if (!ended) {
                    if (vTarget.type == "sideAlign") {
                        ej.datavisualization.Diagram.SvgContext._renderSideAlignmentLines(vTarget.start, vTarget.end, g, diagram._svg, scale, hOffset, vOffset);
                    }
                    else if (vTarget.type == "centerAlign") {
                        ej.datavisualization.Diagram.SvgContext._renderCenterAlignmentLines(vTarget.start, vTarget.end, g, diagram._svg, scale, hOffset, vOffset);
                    }
                }
            }
            return g;
        },
        _removeGuidelines: function (diagram) {
            var g = diagram._svg.getElementById(diagram._canvas.id + "guideline");
            if (g != null) { ej.datavisualization.Diagram.SvgContext._removeGuidelines(diagram._adornerLayer, g); }
        },
        _createHSpacingLines: function (diagram, shape, objectsAtLeft, objectsAtRight, hSnap, vSnap, ended, g, del, snapObjDistance) {
            var top = null;
            objectsAtLeft.sort(function (a, b) { return a.distance - b.distance; });
            objectsAtRight.sort(function (a, b) { return a.distance - b.distance; });
            var equallySpaced = [];
            var bounds = ej.datavisualization.Diagram.Util.bounds(shape);
            var nearestleft, nearestright;
            var targetBounds;
            if (objectsAtLeft.length > 0) {
                equallySpaced[equallySpaced.length] = objectsAtLeft[0];
                nearestleft = ej.datavisualization.Diagram.Util.bounds(objectsAtLeft[0].object);
                top = nearestleft.y;
                if (objectsAtLeft.length > 1) {
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtLeft[1].object);
                    var equaldistance = nearestleft.x - targetBounds.x - targetBounds.width;
                    if (Math.abs(equaldistance - objectsAtLeft[0].distance) <= snapObjDistance) {
                        top = this._findEquallySpacedNodesAtLeft(objectsAtLeft, equaldistance, top, equallySpaced);

                    } else equaldistance = objectsAtLeft[0].distance;
                } else equaldistance = objectsAtLeft[0].distance;
            }
            equallySpaced.sort(function (a, b) { return b.distance - a.distance; });
            equallySpaced[equallySpaced.length] = { object: shape, distance: 0 };
            top = bounds.y < top || !top ? bounds.y : top;
            if (objectsAtRight.length > 0) {
                var dist;
                nearestright = ej.datavisualization.Diagram.Util.bounds(objectsAtRight[0].object);
                top = nearestright.y < top ? nearestright.y : top;
                if (objectsAtRight.length > 1) {
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtRight[1].object);
                    dist = targetBounds.x - nearestright.x - nearestright.width;
                }
                if (objectsAtLeft.length > 0) {
                    if (Math.abs(objectsAtRight[0].distance - objectsAtLeft[0].distance) <= snapObjDistance) {
                        var adjustablevalue = Math.abs(objectsAtRight[0].distance - objectsAtLeft[0].distance) / 2;
                        (objectsAtRight[0].distance < objectsAtLeft[0].distance) ?
                        equaldistance -= adjustablevalue : equaldistance += adjustablevalue;
                        equallySpaced[equallySpaced.length] = objectsAtRight[0];
                    }
                    else if (objectsAtLeft.length == 1) {
                        nearestleft = undefined;
                        equallySpaced.splice(0, 1);
                        equallySpaced[equallySpaced.length] = objectsAtRight[0];
                        equaldistance = dist;
                    }
                }
                else {
                    equaldistance = dist;
                    equallySpaced[equallySpaced.length] = objectsAtRight[0];
                }
                if (objectsAtRight.length > 1 && nearestright.x + nearestright.width < targetBounds.x) {
                    top = this._findEquallySpacedNodesAtRight(objectsAtRight, dist, top, equallySpaced, snapObjDistance);
                }
            }
            if (equallySpaced.length > 2) {
                this._addHSpacingLines(diagram, equallySpaced, ended, g, top);
                var delta = 0;
                if (ended)
                    delta = del.x;
                if (nearestleft)
                    hSnap.offset = equaldistance - Math.abs(bounds.x + delta - nearestleft.x - nearestleft.width) + delta;
                else if (nearestright)
                    hSnap.offset = Math.abs(bounds.x + bounds.width + delta - nearestright.x) - equaldistance + delta;
                hSnap.snapped = true;
            }
        },
        _createVSpacingLines: function (diagram, shape, objectsAtTop, objectsAtBottom, hSnap, vSnap, ended, g, del, snapObjDistance) {
            var right = null;
            objectsAtTop.sort(function (a, b) { return a.distance - b.distance; });
            objectsAtBottom.sort(function (a, b) { return a.distance - b.distance; });
            var equallySpaced = [];
            var bounds = ej.datavisualization.Diagram.Util.bounds(shape);
            var nearesttop, nearestbottom;
            var targetBounds;
            if (objectsAtTop.length > 0) {
                equallySpaced[equallySpaced.length] = objectsAtTop[0];
                nearesttop = ej.datavisualization.Diagram.Util.bounds(objectsAtTop[0].object);
                right = nearesttop.x + nearesttop.width;
                if (objectsAtTop.length > 1) {
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtTop[1].object);
                    var equaldistance = nearesttop.y - targetBounds.y - targetBounds.height;
                    if (Math.abs(equaldistance - objectsAtTop[0].distance) <= snapObjDistance) {
                        right = this._findEquallySpacedNodesAtTop(objectsAtTop, equaldistance, right, equallySpaced);
                    } else equaldistance = objectsAtTop[0].distance;
                } else equaldistance = objectsAtTop[0].distance;
            }

            equallySpaced.sort(function (a, b) { return b.distance - a.distance; });
            equallySpaced[equallySpaced.length] = { object: shape, distance: 0 };
            right = bounds.x + bounds.width > right || !right ? bounds.x + bounds.width : right;
            var dist;
            if (objectsAtBottom.length > 0) {
                nearestbottom = ej.datavisualization.Diagram.Util.bounds(objectsAtBottom[0].object);
                right = nearestbottom.x + nearestbottom.width > right ? nearestbottom.x + nearestbottom.width : right;
                if (objectsAtBottom.length > 1) {
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtBottom[1].object);
                    dist = targetBounds.y - nearestbottom.y - nearestbottom.height;
                }

                if (objectsAtTop.length > 0) {
                    if (Math.abs(objectsAtBottom[0].distance - objectsAtTop[0].distance) <= snapObjDistance) {
                        var adjustablevalue = Math.abs(objectsAtBottom[0].distance - objectsAtTop[0].distance) / 2;
                        (objectsAtBottom[0].distance < objectsAtTop[0].distance) ?
                        equaldistance -= adjustablevalue : equaldistance += adjustablevalue;
                        equallySpaced[equallySpaced.length] = objectsAtBottom[0];
                    }
                    else if (objectsAtTop.length == 1) {
                        nearesttop = undefined;
                        equallySpaced.splice(0, 1);
                        equallySpaced[equallySpaced.length] = objectsAtBottom[0];
                        equaldistance = dist;
                    }
                }
                else {
                    equaldistance = dist;
                    equallySpaced[equallySpaced.length] = objectsAtBottom[0];
                }
                if (objectsAtBottom.length > 1 && targetBounds.y > nearestbottom.y + nearestbottom.height) {
                    right = this._findEquallySpacedNodesAtBottom(objectsAtBottom, dist, right, equallySpaced, snapObjDistance);
                }

            }
            if (equallySpaced.length > 2) {
                this._addVSpacingLine(diagram, equallySpaced, ended, g, right);
                var delta = 0;
                if (ended)
                    delta = del.y;
                if (nearesttop)
                    vSnap.offset = equaldistance - Math.abs(bounds.y + delta - nearesttop.y - nearesttop.height) + delta;
                else if (nearestbottom)
                    vSnap.offset = Math.abs(bounds.y + bounds.height + delta - nearestbottom.y) - equaldistance + delta;
                vSnap.snapped = true;
            }
        },
        _addHSpacingLines: function (diagram, equallySpaced, ended, g, top) {
            var scale = diagram._currZoom;
            var hoffset = diagram._hScrollOffset;
            var voffset = diagram._vScrollOffset;
            if (equallySpaced.length > 2) {
                if (!ended) {
                    for (var i = 0; i < equallySpaced.length - 1; i++) {
                        var crnt = ej.datavisualization.Diagram.Util.bounds(equallySpaced[i].object);
                        var next = ej.datavisualization.Diagram.Util.bounds(equallySpaced[i + 1].object);
                        ej.datavisualization.Diagram.SvgContext._renderSpacingLines(ej.datavisualization.Diagram.Point(crnt.x + crnt.width, top - 15),
                       ej.datavisualization.Diagram.Point(next.x, top - 15), g, diagram._svg, scale, hoffset, voffset);
                    }
                }

            }
        },
        _addVSpacingLine: function (diagram, equallySpaced, ended, g, right) {
            var scale = diagram._currZoom;
            var hoffset = diagram._hScrollOffset;
            var voffset = diagram._vScrollOffset;
            if (equallySpaced.length > 2) {
                if (!ended) {
                    var crnt, next;
                    for (var i = 0; i < equallySpaced.length - 1; i++) {
                        crnt = ej.datavisualization.Diagram.Util.bounds(equallySpaced[i].object);
                        next = ej.datavisualization.Diagram.Util.bounds(equallySpaced[i + 1].object);
                        ej.datavisualization.Diagram.SvgContext._renderSpacingLines(ej.datavisualization.Diagram.Point(right + 15, crnt.y + crnt.height),
                      ej.datavisualization.Diagram.Point(right + 15, next.y), g, diagram._svg, scale, hoffset, voffset);
                    }
                }

            }
        },
        _addSameWidthLines: function (diagram, sameWidths, hSnap, ended, g, shape) {
            var scale = diagram._currZoom;
            var hOffset = diagram._hScrollOffset;
            var vOffset = diagram._vScrollOffset;
            sameWidths.sort(function (a, b) { return a.offset - b.offset; });
            var bounds = ej.datavisualization.Diagram.Util.bounds(shape);
            var target = sameWidths[0];
            var targetBounds = ej.datavisualization.Diagram.Util.bounds(target.source);
            var sameSizes = [];
            sameSizes.push(sameWidths[0]);
            var i, crntbounds;
            for (i = 1; i < sameWidths.length; i++) {
                crntbounds = ej.datavisualization.Diagram.Util.bounds(sameWidths[i].source);
                if (crntbounds.width == targetBounds.width)
                    sameSizes.push(sameWidths[i]);
            }
            if (sameSizes.length > 0) {
                if (!ended) {
                    ej.datavisualization.Diagram.SvgContext._renderSpacingLines(ej.datavisualization.Diagram.Point(bounds.x + target.offset, bounds.y - 15),
                        ej.datavisualization.Diagram.Point(bounds.x + bounds.width + target.offset, bounds.y - 15), g, diagram._svg, scale, hOffset, vOffset);
                    for (i = 0; i < sameSizes.length; i++) {
                        bounds = ej.datavisualization.Diagram.Util.bounds(sameSizes[i].source);
                        ej.datavisualization.Diagram.SvgContext._renderSpacingLines(ej.datavisualization.Diagram.Point(bounds.x, bounds.y - 15),
                        ej.datavisualization.Diagram.Point(bounds.x + bounds.width, bounds.y - 15), g, diagram._svg, scale, hOffset, vOffset);
                    }
                }
            }
            hSnap.offset = target.offset;
            hSnap.snapped = true;
        },
        _addSameHeightLines: function (diagram, sameHeights, vSnap, ended, g, shape) {
            var scale = diagram._currZoom;
            var hOffset = diagram._hScrollOffset;
            var vOffset = diagram._vScrollOffset;
            sameHeights.sort(function (a, b) { return a.offset - b.offset; });
            var bounds = ej.datavisualization.Diagram.Util.bounds(shape);
            var target = sameHeights[0];
            var targetBounds = ej.datavisualization.Diagram.Util.bounds(target.source);
            var sameSizes = [];
            sameSizes.push(sameHeights[0]);
            var i, crntBounds;
            for (i = 0; i < sameHeights.length; i++) {
                crntBounds = ej.datavisualization.Diagram.Util.bounds(sameHeights[i].source);
                if (crntBounds.height == targetBounds.height)
                    sameSizes.push(sameHeights[i]);
            }
            if (sameSizes.length > 0) {
                if (!ended) {
                    ej.datavisualization.Diagram.SvgContext._renderSpacingLines(ej.datavisualization.Diagram.Point(bounds.x + bounds.width + 15, bounds.y + target.offset),
                        ej.datavisualization.Diagram.Point(bounds.x + bounds.width + 15, bounds.y + bounds.height + target.offset), g, diagram._svg, scale, hOffset, vOffset);
                    for (i = 0; i < sameSizes.length; i++) {
                        bounds = ej.datavisualization.Diagram.Util.bounds(sameSizes[i].source);
                        ej.datavisualization.Diagram.SvgContext._renderSpacingLines(ej.datavisualization.Diagram.Point(bounds.x + bounds.width + 15, bounds.y),
                        ej.datavisualization.Diagram.Point(bounds.x + bounds.width + 15, bounds.y + bounds.height), g, diagram._svg, scale, hOffset, vOffset);

                    }
                }
                vSnap.offset = target.offset;
                vSnap.snapped = true;
            }
        },
        _findEquallySpacedNodesAtLeft: function (objectsAtLeft, equalDistance, top, equallySpaced) {
            var prevBounds, targetBounds, dist;
            for (var i = 1; i < objectsAtLeft.length; i++) {
                prevBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtLeft[i - 1].object);
                targetBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtLeft[i].object);
                dist = prevBounds.x - targetBounds.x - targetBounds.width;
                if (Math.abs(dist - equalDistance) <= 1) {
                    equallySpaced[equallySpaced.length] = objectsAtLeft[i];
                    if (targetBounds.y < top)
                        top = targetBounds.y;
                }
                else
                    break;
            }
            return top;
        },
        _findEquallySpacedNodesAtRight: function (objectsAtRight, equalDistance, top, equallySpaced, snapObjDistance) {
            var actualDistance = objectsAtRight[0].distance;
            var target, targetBounds, prevBounds, dist;
            if (Math.abs(equalDistance - actualDistance) <= snapObjDistance) {
                for (var i = 0; i < objectsAtRight.length - 1; i++) {
                    target = objectsAtRight[i].object;
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtRight[i + 1].object);
                    prevBounds = ej.datavisualization.Diagram.Util.bounds(target);
                    dist = targetBounds.x - prevBounds.x - prevBounds.width;
                    if (Math.abs(dist - equalDistance) <= 1) {
                        equallySpaced[equallySpaced.length] = objectsAtRight[i + 1];
                        if (prevBounds.y < top) {
                            top = prevBounds.y;
                        }
                    }
                    else
                        break;
                }
            }
            return top;
        },
        _findEquallySpacedNodesAtTop: function (objectsAtTop, equalDistance, right, equallySpaced) {
            var prevBounds, targetBounds, dist;
            for (var i = 1; i < objectsAtTop.length; i++) {
                prevBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtTop[i - 1].object);
                targetBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtTop[i].object);
                dist = prevBounds.y - targetBounds.y - targetBounds.height;
                if (Math.abs(dist - equalDistance) <= 1) {
                    equallySpaced[equallySpaced.length] = objectsAtTop[i];
                    if (targetBounds.x + targetBounds.width > right)
                        right = targetBounds.x + targetBounds.width;
                }
                else
                    break;
            }
            return right;
        },
        _findEquallySpacedNodesAtBottom: function (objectsAtBottom, equalDistance, right, equallySpaced, snapObjDistance) {
            var actualDistance = objectsAtBottom[0].distance;
            var target, targetBounds, prevBounds, dist;
            if (Math.abs(equalDistance - actualDistance) <= snapObjDistance) {
                for (var i = 0; i < objectsAtBottom.length - 1; i++) {
                    target = objectsAtBottom[i].object;
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtBottom[i + 1].object);
                    prevBounds = ej.datavisualization.Diagram.Util.bounds(target);
                    dist = targetBounds.y - prevBounds.y - prevBounds.height;
                    if (Math.abs(dist - equalDistance) <= 1) {
                        equallySpaced[equallySpaced.length] = objectsAtBottom[i + 1];
                        if (prevBounds.x + prevBounds.width > right)
                            right = prevBounds.x + prevBounds.width;
                    }
                    else
                        break;
                }
            }
            return right;
        },

    };
    //#endregion

    //#region SpatialSearch
    ej.datavisualization.Diagram.SpatialUtil = {
        findQuads: function (spatialSearch, viewPort) {
            spatialSearch.quads = [];
            var quad = spatialSearch.parentQuad;
            this._findQuads(spatialSearch, quad, viewPort);
            return spatialSearch.quads;
        },
        _addIntoAQuad: function (spatialSearch) {
            var isAdded = false;
            while (!isAdded) {
                isAdded = this._add(spatialSearch, spatialSearch.parentQuad);
            }
        },
        _setCurrentNode: function (spatialSearch, node) {
            spatialSearch.childnode = node;
            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
            spatialSearch.childLeft = bounds.left;
            spatialSearch.childTop = bounds.top;
            spatialSearch.childRight = bounds.right;
            spatialSearch.childBottom = bounds.bottom;
        },
        _add: function (spatialSearch, quad) {
            if (this._isContained(spatialSearch, quad)) {
                this._selectQuad(spatialSearch, quad);
                return true;
            } else {
                var newParent;
                var isEmpty = !quad.objects.length && quad.first == null && quad.second == null && quad.third == null && quad.fourth == null;
                if (spatialSearch.childLeft < quad.left) {
                    if (spatialSearch.childTop < quad.top) {
                        newParent = ej.datavisualization.Diagram.Quad(quad.left - quad.width, quad.top - quad.height, quad.width * 2, quad.height * 2);
                        if (!isEmpty)
                            newParent.fourth = quad;
                    }
                    else {
                        newParent = ej.datavisualization.Diagram.Quad(quad.left - quad.width, quad.top, quad.width * 2, quad.height * 2);
                        if (!isEmpty)
                            newParent.second = quad;
                    }
                }
                else if (spatialSearch.childTop < quad.top) {
                    newParent = ej.datavisualization.Diagram.Quad(quad.left, quad.top - quad.height, quad.width * 2, quad.height * 2);
                    if (!isEmpty)
                        newParent.third = quad;
                }
                else {
                    newParent = ej.datavisualization.Diagram.Quad(quad.left, quad.top, quad.width * 2, quad.height * 2);
                    if (!isEmpty)
                        newParent.first = quad;
                }
                quad.parent = newParent;
                spatialSearch.parentQuad = newParent;
                return false;
            }
        },
        _isContained: function (spatialSearch, quad) {
            if (spatialSearch.childLeft >= quad.left && spatialSearch.childRight <= quad.left + quad.width &&
                spatialSearch.childTop >= quad.top && spatialSearch.childBottom <= quad.top + quad.height) {
                return true;
            }
            return false;
        },
        _selectQuad: function (spatialSearch, quad) {
            var current = quad;
            while (current !== null) {
                current = this._getQuad(spatialSearch, current);
            }
        },
        _getQuad: function (spatialSearch, quad) {
            var halfWidth = quad.width / 2;
            var halfHeight = quad.height / 2;
            if (halfWidth >= 100 && halfHeight >= 100) {
                var xCenter = quad.left + halfWidth;
                var yCenter = quad.top + halfHeight;
                if (spatialSearch.childRight <= xCenter) {
                    if (spatialSearch.childBottom <= yCenter) {
                        return quad.first ? quad.first :
                               quad.first = ej.datavisualization.Diagram.Quad(quad.left, quad.top, halfWidth, halfHeight, quad);
                    }
                    else if (spatialSearch.childTop >= yCenter) {
                        return quad.third ? quad.third :
                                quad.third = ej.datavisualization.Diagram.Quad(quad.left, yCenter, halfWidth, halfHeight, quad);
                    }
                }
                else if (spatialSearch.childLeft >= xCenter) {
                    if (spatialSearch.childBottom <= yCenter) {
                        return quad.second ? quad.second :
                               quad.second = ej.datavisualization.Diagram.Quad(xCenter, quad.top, halfWidth, halfHeight, quad);
                    }
                    else if (spatialSearch.childTop >= yCenter) {
                        return quad.fourth ? quad.fourth :
                                quad.fourth = ej.datavisualization.Diagram.Quad(xCenter, yCenter, halfWidth, halfHeight, quad);
                    }
                }
            }
            quad.objects.push(spatialSearch.childnode);
            spatialSearch.quadTable[spatialSearch.childnode.name] = quad;
            return null;
        },
        _findQuads: function (spatialSearch, quad, viewPort) {
            if (quad.first && this._isIntersect(quad.first, viewPort)) {
                this._findQuads(spatialSearch, quad.first, viewPort);
            }
            if (quad.second && this._isIntersect(quad.second, viewPort)) {
                this._findQuads(spatialSearch, quad.second, viewPort);
            }
            if (quad.third && this._isIntersect(quad.third, viewPort)) {
                this._findQuads(spatialSearch, quad.third, viewPort);
            }
            if (quad.fourth && this._isIntersect(quad.fourth, viewPort)) {
                this._findQuads(spatialSearch, quad.fourth, viewPort);
            }
            if (quad.objects.length > 0)
                spatialSearch.quads.push(quad);
        },
        _isIntersect: function (quad, viewPort) {
            if (quad.left + quad.width < viewPort.left || quad.top + quad.height < viewPort.top || quad.left > viewPort.right || quad.top > viewPort.bottom) {
                return false;
            }
            return true;
        },
        _update: function (quad) {
            if (quad.parent != null && quad.objects.length == 0 && quad.first == null &&
                quad.second == null && quad.third == null && quad.fourth == null) {
                var parent = quad.parent;
                if (parent.first == quad) {
                    parent.first = null;
                }
                else if (parent.second == quad) {
                    parent.second = null;
                }
                else if (parent.third == quad) {
                    parent.third = null;
                }
                else if (parent.fourth == quad) {
                    parent.fourth = null;
                }
                this._update(quad.parent);
            }
            else
                return;
        },
        _isWithinPageBounds: function (spatialSearch, bounds) {
            if (bounds.left >= spatialSearch.pageLeft && bounds.right <= spatialSearch.pageRight &&
                bounds.top >= spatialSearch.pageTop && bounds.bottom <= spatialSearch.pageBottom)
                return true;
            else
                return false;
        },
        _updateBounds: function (diagram, spatialSearch, node) {
            var modified = false;
            if (spatialSearch.topElement && node.name == spatialSearch.topElement.name) {
                modified = true;
                spatialSearch.pageTop = null;
                this._findQuadElement(spatialSearch, spatialSearch.parentQuad, "top");
            }
            if (spatialSearch.leftElement && node.name == spatialSearch.leftElement.name) {
                modified = true;
                spatialSearch.pageLeft = null;
                this._findQuadElement(spatialSearch, spatialSearch.parentQuad, "left");
            }
            if (spatialSearch.rightElement && node.name == spatialSearch.rightElement.name) {
                modified = true;
                spatialSearch.pageRight = null;
                this._findQuadElement(spatialSearch, spatialSearch.parentQuad, "right");
            }
            if (spatialSearch.bottomElement && node.name == spatialSearch.bottomElement.name) {
                modified = true;
                spatialSearch.pageBottom = null;
                this._findQuadElement(spatialSearch, spatialSearch.parentQuad, "bottom");
            }
            if (modified) {
                if (diagram._pageBackgroundLayer) {
                    ej.datavisualization.Diagram.PageUtil._updatePageSize(diagram);
                }
            }
        },
        _findQuadElement: function (spatialSearch, quad, direction) {
            switch (direction) {
                case "bottom":
                    if (quad.third != null || quad.fourth != null) {
                        if (quad.third != null) {
                            this._findQuadElement(spatialSearch, quad.third, direction);
                        }
                        if (quad.fourth != null) {
                            this._findQuadElement(spatialSearch, quad.fourth, direction);
                        }
                    }
                    else {
                        if (quad.first != null) {
                            this._findQuadElement(spatialSearch, quad.first, direction);
                        }
                        if (quad.second != null) {
                            this._findQuadElement(spatialSearch, quad.second, direction);
                        }
                    }
                    break;
                case "top":
                    if (quad.first != null || quad.second != null) {
                        if (quad.first != null) {
                            this._findQuadElement(spatialSearch, quad.first, direction);
                        }
                        if (quad.second != null) {
                            this._findQuadElement(spatialSearch, quad.second, direction);
                        }
                    }
                    else {
                        if (quad.third != null) {
                            this._findQuadElement(spatialSearch, quad.third, direction);
                        }
                        if (quad.fourth != null) {
                            this._findQuadElement(spatialSearch, quad.fourth, direction);
                        }
                    }
                    break;
                case "left":
                    if (quad.first != null || quad.third != null) {
                        if (quad.first != null) {
                            this._findQuadElement(spatialSearch, quad.first, direction);
                        }
                        if (quad.third != null) {
                            this._findQuadElement(spatialSearch, quad.third, direction);
                        }
                    }
                    else {
                        if (quad.second != null) {
                            this._findQuadElement(spatialSearch, quad.second, direction);
                        }
                        if (quad.fourth != null) {
                            this._findQuadElement(spatialSearch, quad.fourth, direction);
                        }
                    }
                    break;
                case "right":
                    if (quad.second != null || quad.fourth != null) {
                        if (quad.second != null) {
                            this._findQuadElement(spatialSearch, quad.second, direction);
                        }
                        if (quad.fourth != null) {
                            this._findQuadElement(spatialSearch, quad.fourth, direction);
                        }
                    }
                    else {
                        if (quad.third != null) {
                            this._findQuadElement(spatialSearch, quad.third, direction);
                        }
                        if (quad.first != null) {
                            this._findQuadElement(spatialSearch, quad.first, direction);
                        }
                    }

                    break;
            }

            var bounds;
            for (var i = 0; i < quad.objects.length; i++) {
                bounds = ej.datavisualization.Diagram.Util.bounds(quad.objects[i]);
                if (direction === "bottom" && (spatialSearch.pageBottom <= bounds.bottom || spatialSearch.pageBottom == null)) {
                    spatialSearch.pageBottom = bounds.bottom;
                    spatialSearch.bottomElement = quad.objects[i];
                }
                else if (direction === "top" && (spatialSearch.pageTop >= bounds.top || spatialSearch.pageTop == null)) {
                    spatialSearch.pageTop = bounds.top;
                    spatialSearch.topElement = quad.objects[i];
                }
                else if (direction === "left" && (spatialSearch.pageLeft >= bounds.left || spatialSearch.pageLeft == null)) {
                    spatialSearch.pageLeft = bounds.left;
                    spatialSearch.leftElement = quad.objects[i];
                }
                else if (direction === "right" && (spatialSearch.pageRight <= bounds.right || spatialSearch.pageRight == null)) {
                    spatialSearch.pageRight = bounds.right;
                    spatialSearch.rightElement = quad.objects[i];
                }
            }
        },
        _initializeNodes: function (diagram, spatialSearch) {
            var nodes = diagram.nodes();
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                if (node.type != "group") {
                    this._updateQuad(diagram, spatialSearch, node);
                }
            }
        },

        _initializeConnectors: function (diagram, spatialSearch) {
            var connectors = diagram.connectors();
            for (var i = 0; i < connectors.length; i++) {
                this._updateQuad(diagram, spatialSearch, connectors[i]);
            }
        },

        _updateQuad: function (diagram, spatialSearch, node, layoutinAction) {
            this._setCurrentNode(spatialSearch, node);
            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
            var quad = spatialSearch.quadTable[node.name];
            if (quad) {
                if (node.segments) {
                    this._removeFromaQuad(spatialSearch, quad, node);
                    this._addIntoAQuad(spatialSearch);
                }
                else if (!this._isContained(spatialSearch, quad)) {
                    this._removeFromaQuad(spatialSearch, quad, node);
                    this._addIntoAQuad(spatialSearch);
                }
            }
            else {
                if (!spatialSearch.parentQuad)
                    spatialSearch.parentQuad = ej.datavisualization.Diagram.Quad(0, 0, 200, 200);
                this._addIntoAQuad(spatialSearch);
            }
            if (!(this._isWithinPageBounds(spatialSearch, bounds) && spatialSearch.leftElement != node &&
                spatialSearch.topElement != node && spatialSearch.rightElement != node && spatialSearch.bottomElement != node)) {
                var modified = false;
                if (spatialSearch.pageLeft >= spatialSearch.childLeft || spatialSearch.pageLeft == null) {
                    spatialSearch.pageLeft = spatialSearch.childLeft;
                    spatialSearch.leftElement = node;
                    modified = true;
                }
                else if (node == spatialSearch.leftElement) {
                    spatialSearch.pageLeft = null;
                    this._findQuadElement(spatialSearch, spatialSearch.parentQuad, "left");
                    modified = true;
                }

                if (spatialSearch.pageTop >= spatialSearch.childTop || spatialSearch.pageTop == null) {
                    spatialSearch.pageTop = spatialSearch.childTop;
                    spatialSearch.topElement = node;
                    modified = true;
                }
                else if (node == spatialSearch.topElement) {
                    spatialSearch.pageTop = null;
                    this._findQuadElement(spatialSearch, spatialSearch.parentQuad, "top");
                    modified = true;
                }

                if (spatialSearch.pageBottom <= spatialSearch.childBottom || spatialSearch.pageBottom == null) {
                    modified = true;
                    spatialSearch.pageBottom = spatialSearch.childBottom;
                    spatialSearch.bottomElement = node;
                }
                else if (node == spatialSearch.bottomElement) {
                    spatialSearch.pageBottom = null;
                    this._findQuadElement(spatialSearch, spatialSearch.parentQuad, "bottom");
                    modified = true;
                }

                if (spatialSearch.pageRight <= spatialSearch.childRight || spatialSearch.pageRight == null) {
                    spatialSearch.pageRight = spatialSearch.childRight;
                    spatialSearch.rightElement = node;
                    modified = true;
                }
                else if (node == spatialSearch.rightElement) {
                    spatialSearch.pageRight = null;
                    this._findQuadElement(spatialSearch, spatialSearch.parentQuad, "right");
                    modified = true;
                }
            }
            if (modified) {
                diagram._views.forEach(function (viewid) {
                    var view = diagram._views[viewid];
                    if (view.type == "overview") {
                        var ovw = $("#" + viewid).ejOverview("instance");
                        if (ovw)
                            ovw._updateOverview(view);
                    }
                });
                if (!diagram._layoutInAction && diagram._pageBackgroundLayer) {
                    ej.datavisualization.Diagram.PageUtil._updatePageSize(diagram);
                }
            }
        },
        _removeFromaQuad: function (spatialSearch, quad, node) {
            if (quad) {
                var index = quad.objects.indexOf(node);
                quad.objects.splice(index, 1);
                this._update(quad);
                delete spatialSearch.quadTable[node.name];
            }
        }

    };

    ej.datavisualization.Diagram.Quad = function (left, top, width, height, parent) {
        return {
            left: left, top: top, width: width, height: height, parent: parent,
            first: null, second: null, third: null, fourth: null, objects: []
        };
    }
    ej.datavisualization.Diagram.SpatialSearch = function () {
        return {
            pageLeft: null, pageRight: null, pageTop: null, pageBottom: null,
            topElement: null, bottomElement: null, rightElement: null, leftElement: null,
            childLeft: null, childTop: null, childRight: null, childBottom: null, childNode: null,
            quads: null, parentQuad: ej.datavisualization.Diagram.Quad(0, 0, 200, 200), quadTable: {}
        };
    };
    //#endregion

})(jQuery, Syncfusion);;
(function ($, ej, undefined) {
    "use strict";

    //#region SymbolPalette widget
    ej.widget("ejOverview", "ej.datavisualization.Overview", {
        // widget element will be automatically set in this
        element: null,

        validTags: ["div"],

        // user defined model will be automatically set in this
        model: null,

        //#region Initialization
        defaults: {
            /**The sourceID of the overview 
   * @default ""
   * @type string
   * @example
   * &lt;div id="overview"&gt;&lt;/div&gt;<br>
   * &lt;script&gt;
   * $("#overview").ejOverview({sourceID: "diagram"});
   * &lt;/script&gt
   * @memberof ejOverview
   * @instance
   */
            sourceID: "",
            width: null,
            height: null
        },

        _canvas: null,

        _actionName: "",
        _startPoint: null,
        _currentPoint: null,
        _prevPoint: null,
        _helper: null,
        _viewPortRatio: 1,
        _resizeDirection: "",
        _inAction: false,
        _init: function () {
            if (!(ej.browserInfo().name === "msie" && Number(ej.browserInfo().version) < 9)) {
                this._wireEvents();
                this._renderCanvas();
                this._setParent(this.model.sourceID);
            }
        },

        _renderCanvas: function () {
            var canvas = document.createElement("div");
            canvas.setAttribute("id", this.element[0].id + "_canvas");
            canvas.setAttribute("class", "drawing");
            canvas.setAttribute("style", "position:relative; height:" + this.model.height + "; width:" + this.model.width + ";style:-ms-touch-action: none;touch-action: none;");
            this.element[0].setAttribute("tabindex", 0);
            this.element.css({
                overflow: "hidden", outline: "none", display: "block", height: this.model.height, width: this.model.width
            });
            this.element.append(canvas);
            this._canvas = canvas;
        },

        _renderDocument: function (view) {
            view.canvas = this._canvas;
            if (window.SVGSVGElement) {
                var attr = {
                    id: this._canvas.id + "_svg",
                    version: "1.1",
                    xlink: "http://www.w3.org/1999/xlink",
                    "style": view.style,
                };

                var svg = new ej.datavisualization.Diagram.Svg(attr);
                this._svg = svg;
                view.svg = svg;
                var ovw = document.getElementById(this._id);
                var element = ovw;
                var eWidth = $(element).width();
                var eHeight = $(element).height();
                var bRect = element.getBoundingClientRect();
                var screenX = (window.screenX < 0) ? window.screenX * -1 : window.screenX;
                if (eWidth === 0) {
                    eWidth = Math.floor(((window.innerWidth - screenX) - Math.floor(bRect.left)));
                }
                var screenY = (window.screenY < 0) ? window.screenY * -1 : window.screenY;
                if (eHeight === 0) {
                    eHeight = Math.floor(((window.innerHeight - screenY) - Math.floor(bRect.top)));
                }
                svg.document.setAttribute("width", eWidth);
                svg.document.setAttribute("height", eHeight);
                this.width = eWidth;
                this.height = eHeight;
                var defs = svg.defs({ "id": view.canvas.id + "definition" });
                svg.appendChild(defs);
                view.diagramLayer = ej.datavisualization.Diagram.SvgContext._renderDiagramLayer(view.canvas, view.svg, view.svg);
                view.canvas.appendChild(svg.document);
                this._addOverviewRectPanel();
            }
        },
        _removeDocument: function (view) {
            var svg = document.getElementById(this._canvas.id + "_svg");
            this._canvas.removeChild(svg);
            //var rect = document.getElementById("overview_canvasrect");
            //this._canvas.removeChild(rect);
        },

        _setModel: function (options) {
            for (var option in options) {
                switch (option) {
                    case "sourceID":
                        this._setParent(options[option]);
                        break;
                }
            }
        },

        _setParent: function (diagram) {
            if (this._parent) {
                var oldparent = $("#" + this._parent._id).ejDiagram("instance");
                this._parent = null;
                oldparent._setOverview(null, this._id);
            }
            if (diagram) {
                this.model.sourceID = diagram;
                this._parent = $("#" + diagram).ejDiagram("instance");
                if (this._parent)
                    this._parent._setOverview(this);
            }
        },

        _destroy: function () {
            this.element.empty().removeClass(this.model.cssClass);
        },
        //#endregion

        //#region Events
        _wireEvents: function () {
            var canvas = $(this._canvas);
            this._on(canvas, ej.eventType.mouseDown, this._mousedown);
            this._on(canvas, ej.eventType.mouseMove, this._mousemove);
            this._on(canvas, ej.eventType.mouseUp, this._mouseup);
            this._on(canvas, ej.eventType.mouseLeave, this._documentmouseup);
            this._on(canvas, "touchstart", this.handleTouchStart);
            this._on(canvas, "touchmove", this.handleTouchMove);
            this._on(canvas, "touchend", this.handleTouchEnd);

            if (window) {
                this._on($(window), "resize", this.updateScrollerViewport);
            }
        },
        updateScrollerViewport: function () {
            //var div = document.getElementById("overview_canvasrect");
            //overview.setAttribute("style", "position:absolute;left:" + this._canvas.offsetLeft + "px;top:" + this._canvas.offsetTop + "px;-ms-touch-action: none;");
        },

        _mouseup: function (evt) {
            this._currentPoint = this._mouseposition(evt);
            var offwidth = this.width;
            var offheight = this.height;
            if (this._actionName)
                if ((this._startPoint.x != this._currentPoint.x || this._startPoint.y != this._currentPoint.y)) {
                    if (this._actionName == "pan") { }
                    else {
                        if (this._helper) {
                            var bounds = this._helper.getBBox();
                            this._resizeDirection = this._resizeDirection || "";
                            var x = bounds.x;
                            var y = bounds.y;
                            var width = bounds.width;
                            var height = bounds.height;
                            var adjust = this._resizeDirection == "topleft" || this._resizeDirection == "topright" || this._resizeDirection == "bottomleft" ||
                                this._resizeDirection == "bottomright";
                            this._renderOverviewRect(x, y, width, height);
                        }
                    }
                }
                else
                    if (evt.target.id == this._canvas.id + "overviewbackrect" || evt.target.id == "helper")
                        if (this._startPoint.x == this._currentPoint.x && this._startPoint.y == this._currentPoint.y) {
                            var g = document.getElementById(this._canvas.id + "overviewrect");
                            var bounds = g.getBBox();
                            var width = bounds.width || 100;
                            var height = bounds.height || 100 / this._viewPortRatio;
                            this.inAction = true;
                            this._actionName = "pan";
                            this._renderOverviewRect(this._currentPoint.x - width / 2, this._currentPoint.y - height / 2, width, height);
                            this.inAction = false;
                        }
            if (this._helper) {
                var g = document.getElementById(this._canvas.id + "overviewhandle");
                g.removeChild(this._helper);
                this._helper = null;
            }
            this._actionName = "";
            this._startPoint = null;
            this._currentPoint = null;
            this._prevPoint = null;
            this._helper = null;
            this._viewPortRatio = 1;
            this._resizeDirection = "";
            this._inAction = false
        },

        _mousedown: function (evt) {
            if (evt.target.className.animVal == "overviewbackrect")
                this._actionName = "draw";
            if (evt.target.id == this._canvas.id + "overviewrect") this._actionName = "pan";
            if (evt.target.className.animVal == "overviewresizer") {
                this._actionName = "scale";
                switch (evt.target.id) {
                    case this._canvas.id + "left":
                        this._resizeDirection = "left";
                        break;
                    case this._canvas.id + "right":
                        this._resizeDirection = "right"; break;
                    case this._canvas.id + "top":
                        this._resizeDirection = "top"; break;
                    case this._canvas.id + "bottom":
                        this._resizeDirection = "bottom"; break;
                    case this._canvas.id + "topleft":
                        this._resizeDirection = "topleft"; break;
                    case this._canvas.id + "topright":
                        this._resizeDirection = "topright"; break;
                    case this._canvas.id + "bottomleft":
                        this._resizeDirection = "bottomleft"; break;
                    case this._canvas.id + "bottomright":
                        this._resizeDirection = "bottomright"; break;
                }
            }
            this._startPoint = this._prevPoint = this._mouseposition(evt);
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this._parent);
            this._viewPortRatio = viewPort.width / viewPort.height;
        },

        _mouseposition: function (evt) {
            var e = this._parent._isTouchEvent(evt);
            if (!e) {
                e = evt;
            }
            var scrollLeft = this._canvas.scrollLeft;
            var scrollTop = this._canvas.scrollTop;
            var controlBBox = this._canvas.getBoundingClientRect();
            var layerx = (e.clientX + scrollLeft) - controlBBox.left;
            var layery = (scrollTop + e.clientY) - controlBBox.top;
            return new ej.datavisualization.Diagram.Point(layerx, layery);
        },

        _updateCursor: function (evt) {
            if (evt.target.className.animVal == "overviewresizer") {
                switch (evt.target.id) {
                    case this._canvas.id + "left":
                        this._canvas.style.cursor = "w-resize";
                        break;
                    case this._canvas.id + "right":
                        this._canvas.style.cursor = "e-resize"; break;
                    case this._canvas.id + "top":
                        this._canvas.style.cursor = "n-resize"; break;
                    case this._canvas.id + "bottom":
                        this._canvas.style.cursor = "s-resize"; break;
                    case this._canvas.id + "topleft":
                        this._canvas.style.cursor = "nw-resize"; break;
                    case this._canvas.id + "topright":
                        this._canvas.style.cursor = "ne-resize"; break;
                    case this._canvas.id + "bottomleft":
                        this._canvas.style.cursor = "sw-resize"; break;
                    case this._canvas.id + "bottomright":
                        this._canvas.style.cursor = "se-resize"; break;
                }
            }
            else this._canvas.style.cursor = "";

        },

        _mousemove: function (evt) {
            this._updateCursor(evt);
            this._currentPoint = this._mouseposition(evt);
            if (this._actionName)
                switch (this._actionName) {
                    case "draw":
                        if (!this._inAction) {
                            this._initHelper();
                            this._inAction = true;
                        }
                        this._updateHelper();
                        break;
                    case "scale":
                        if (!this._inAction) {
                            this._initHelper();
                            this._inAction = true;
                        }
                        this._updateOverviewRectangle();
                        break;
                    case "pan":
                        this._inAction = true;
                        this._translateOverviewRectangle();
                        break;
                }
            this._prevPoint = this._currentPoint;
        },
        _documentmouseup: function (evt) {
            this._inAction = false;
            this._actionName = "";
            if (this._helper) {
                var g = document.getElementById(this._canvas.id + "overviewhandle");
                g.removeChild(this._helper);
                this._helper = null;
            }
        },

        _addOverviewRectPanel: function (view) {
            var svg = this._svg;
            var ovw = svg.g({ "id": this._id + "_overviewlayer" });
            this._canvas.firstChild.appendChild(ovw);
            var rect = svg.rect({ "fill": "transparent", "width": "100%", "height": "100%", "class": "overviewbackrect", "id": this._canvas.id + "overviewbackrect" });
            ovw.appendChild(rect);
            var svgDocument = $(ovw);
            this._on(svgDocument, ej.eventType.mouseDown, this._mousedown);
            this._on(svgDocument, ej.eventType.mouseMove, this._mousemove);
            this._on(svgDocument, ej.eventType.mouseUp, this._mouseup);
            this._on(svgDocument, ej.eventType.mouseLeave, this._documentmouseup);
            this._on(svgDocument, "touchstart", this.handleTouchStart);
            this._on(svgDocument, "touchmove", this.handleTouchMove);
            this._on(svgDocument, "touchend", this.handleTouchEnd);
            var g = svg.g({ "id": this._canvas.id + "overviewhandle" });
            ovw.appendChild(g);
            var innerrect = svg.rect({ "id": this._canvas.id + "overviewrect", "fill": "transparent" });
            g.appendChild(innerrect);
            this._renderOverviewCorner("left", g);
            this._renderOverviewCorner("right", g);
            this._renderOverviewCorner("top", g);
            this._renderOverviewCorner("bottom", g);
            this._renderOverviewCorner("topleft", g);
            this._renderOverviewCorner("topright", g);
            this._renderOverviewCorner("bottomleft", g);
            this._renderOverviewCorner("bottomright", g);

        },

        _updateOverview: function (view) {
            view = view || this._parent._views[this._id];
            var width, height;
            var bounds = this._parent._getDigramBounds();
            width = bounds.width;
            height = bounds.height;
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this._parent);
            var offwidth = this.width;
            var offheight = this.height;
            if (view.context == ej.datavisualization.Diagram.SvgContext) {
                var w = Math.max(width, viewPort.width);
                var h = Math.max(height, viewPort.height);
                this.contentWidth = w = Math.max(w, (offwidth / offheight) * h);
                this.contentHeight = h = Math.max(h, (offheight / offwidth) * w);
                var g = document.getElementById(this._canvas.id + "_diagramLayer");
                var scale = Math.min(offwidth / w, offheight / h);
                this.scale = scale;
                g.setAttribute("transform", "scale(" + scale + "," + scale + "),translate(" + -bounds.x + "," + (-bounds.y) + ")");
                // if (bounds.x < 0 || bounds.y < 0) 
                {
                    var ovw = document.getElementById(this._id + "_overviewlayer");
                    ovw.setAttribute("transform", "translate(" + (-bounds.x * scale) + "," + (-bounds.y * scale) + ")");
                }
            }
            else {
                var context = view._canvas.document.getContext("2d");
                if (view.scale) {
                    context.scale(1 / view.scale.x, 1 / view.scale.y);
                }
                view.scale = { x: scale, y: scale };
                context.scale(scale, scale);
                ej.datavisualization.Diagram.CanvasContext.refreshCanvas(this._parent.model, view);
            }
            this._scrollOverviewRect(this._parent._hScrollOffset, this._parent._vScrollOffset, this._parent._currZoom);
        },

        _updateOverviewRectangle: function () {
            var difx = this._currentPoint.x - this._prevPoint.x;
            var dify = this._currentPoint.y - this._prevPoint.y;
            if (this._actionName == "scale") {
                var size = { "width": 0, "height": 0 };
                var x = 0, y = 0; var w, h;
                switch (this._resizeDirection) {
                    case "left":
                        size.width -= difx;
                        size.height -= difx / this._viewPortRatio;
                        x = difx;
                        y = difx / this._viewPortRatio;
                        y /= 2;
                        break;
                    case "right":
                        size.width += difx;
                        size.height += difx / this._viewPortRatio;
                        y = difx / this._viewPortRatio;
                        y /= -2;
                        break;
                    case "top":
                        size.height -= dify;
                        size.width -= dify * this._viewPortRatio;
                        y = dify;
                        x = dify * this._viewPortRatio;
                        x /= 2;
                        break;
                    case "bottom":
                        size.height += dify;
                        size.width += dify * this._viewPortRatio;
                        x = dify * this._viewPortRatio;
                        x /= -2;
                        break;
                    case "topleft":
                        if (Math.abs(dify) > Math.abs(difx)) { difx = dify * this._viewPortRatio; }
                        else
                            dify = difx / this._viewPortRatio;
                        size.width -= difx;
                        size.height -= dify;
                        x = difx;
                        y = dify;
                        break;
                    case "topright":
                        if (Math.abs(dify) > Math.abs(difx)) { difx = -dify * this._viewPortRatio; }
                        else
                            dify = -(difx / this._viewPortRatio);
                        y = dify;
                        size.width += difx;
                        size.height -= dify;
                        break;
                    case "bottomleft":
                        if (Math.abs(dify) > Math.abs(difx)) { difx = -dify * this._viewPortRatio; }
                        else
                            dify = -difx / this._viewPortRatio;
                        x = difx;
                        size.width -= difx;
                        size.height += dify;
                        break;
                    case "bottomright":
                        if (Math.abs(dify) > Math.abs(difx)) { difx = dify * this._viewPortRatio; }
                        else
                            dify = difx / this._viewPortRatio;
                        size.width += difx;
                        size.height += dify;
                        break;
                }
                this._updateHelper(x, y, size, w, h);
            }

        },

        _initHelper: function () {
            if (!this._helper) {
                var svg = this._svg;
                var g = document.getElementById(this._canvas.id + "overviewhandle");
                var scale = this._parent._currZoom;
                var x = this._startPoint.x;
                var y = this._startPoint.y; var width = 1; var height = 1;
                if (this._actionName == "scale") {
                    var rect = document.getElementById(this._canvas.id + "overviewrect");
                    var bounds = rect.getBBox();
                    x = bounds.x; y = bounds.y; width = bounds.width; height = bounds.height;
                }

                var selectionRect = svg.rect({
                    "id": "helper", x: x, y: y, width: width, height: height,
                    "fill": "transparent", "stroke": "gray", "stroke-dasharray": "2 2", "shape-rendering": "crispEdges"
                });
                g.appendChild(selectionRect);
                this._helper = selectionRect;
            }
        },

        _updateHelper: function (difx, dify, size) {
            if (size) {
                var bounds = this._helper.getBBox();
                var x = bounds.x + difx;
                var y = bounds.y + dify;
                var width = bounds.width + size.width;
                var height = bounds.height + size.height;
            }
            else {
                var difx;
                if (this._currentPoint.x > this._startPoint.x)
                    difx = this._currentPoint.x - this._prevPoint.x;
                else
                    difx = this._prevPoint.x - this._currentPoint.x;
                var dify;
                if (this._currentPoint.y > this._startPoint.y)
                    dify = this._currentPoint.y - this._prevPoint.y;
                else dify = this._prevPoint.y - this._currentPoint.y;
                var w, h;
                if (Math.abs(dify) > Math.abs(difx)) {
                    difx = this._viewPortRatio * dify; h = true; w = false;
                }
                else { dify = difx / this._viewPortRatio; w = true; h = false; }
                var bounds = this._helper.getBBox();
                var x = ((this._startPoint.x > this._currentPoint.x) ?
                    bounds.x - difx : bounds.x);
                var y = ((this._startPoint.y > this._currentPoint.y) ? bounds.y - dify : bounds.y);
                var width = bounds.width + difx;
                var height = bounds.height + dify;
            }
            if (this._helper) {
                ej.datavisualization.Diagram.Util.attr(this._helper, {
                    "id": this._helper.id, "x": x, "y": y,
                    "width": width, "height": height
                });
            }

        },

        _renderOverviewCorner: function (name, parent) {
            var svg = this._svg;
            if (name == "top" || name == "bottom" || name == "right" || name == "left") {
                var innerrect = svg.rect({ "id": this._canvas.id + "visible" + name });
                parent.appendChild(innerrect);
                var transrect = svg.rect({ "id": this._canvas.id + name, "class": "overviewresizer", "fill": "transparent" });
                parent.appendChild(transrect);
            }
            else {
                var innerrect = svg.circle({ "id": this._canvas.id + "visible" + name });
                parent.appendChild(innerrect);
                var transrect = svg.circle({ "id": this._canvas.id + name, "class": "overviewresizer", "fill": "transparent" });
                parent.appendChild(transrect);
            }
        },
        
        _updateOverviewrect: function (x, y, width, height) {
            if (width && height) {
                var rect = document.getElementById(this._canvas.id + "overviewrect");
                var attr = { x: x, y: y, width: Math.max(1, width), height: Math.max(1, height) };
                ej.datavisualization.Diagram.Util.attr(rect, attr);
                this._updateOverviewCorner("top", x + 8, y - 2, Math.max(0, width - 16), 2);
                this._updateOverviewCorner("bottom", x + 8, y + height, Math.max(0, width - 16), 2);
                this._updateOverviewCorner("left", x - 2, y + 8, 2, Math.max(0, height - 16));
                this._updateOverviewCorner("right", x + width, y + 8, 2, Math.max(0, height - 16));
                this._updateOverviewCorner("topleft", x, y, 5, 5);
                this._updateOverviewCorner("topright", x + width, y, 5, 5);
                this._updateOverviewCorner("bottomleft", x, y + height, 5, 5);
                this._updateOverviewCorner("bottomright", x + width, y + height, 5, 5);
            }
        },

        _scrollOverviewRect: function (hoffset, voffset, currentzoom) {
            if (!(this._actionName)) {
                var offwidth = this.width;
                var offheight = this.height;
                var scale = Math.min(this.contentWidth / offwidth, this.contentHeight / offheight);
                var bounds = {};
                var x = bounds.x = (hoffset / currentzoom) / scale;
                var y = bounds.y = (voffset / currentzoom) / scale;
                var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this._parent);
                var width = bounds.width = (viewPort.width / currentzoom) / scale;
                var height = bounds.height = (viewPort.height / currentzoom) / scale;
                var ratio = viewPort.width / viewPort.height;
                if (x + width > offwidth) {
                    var dif = (x + width) - offwidth;
                    x -= dif;
                }
                if (y + height > offheight) {
                    var dif = (y + height) - offheight;
                    y -= dif;
                }
                this._updateOverviewrect(x, y, width, height);
            }
        },

        _updateOverviewCorner: function (name, x, y, width, height) {
            var rectname = "visible" + name;
            var rect = document.getElementById(this._canvas.id + rectname);
            if (name == "top" || name == "bottom" || name == "right" || name == "left") {
                var attr = { x: x, y: y, width: width, height: height, fill: "#ED1C24" };
                var transattr = { x: x - 2, y: y - 2, width: width == 2 ? 4 : width, height: height == 2 ? 4 : height };
            }
            else {
                var attr = { cx: x, cy: y, "r": 4, fill: "#ED1C24" };
                var transattr = { cx: x, cy: y, "r": 6, fill: "transparent" };
            }
            ej.datavisualization.Diagram.Util.attr(rect, attr);
            var transrect = document.getElementById(this._canvas.id + name);
            ej.datavisualization.Diagram.Util.attr(transrect, transattr);
        },

        _translateOverviewRectangle: function () {
            var offwidth = this.width;
            var offheight = this.height;
            var difx = this._currentPoint.x - this._prevPoint.x;
            var dify = this._currentPoint.y - this._prevPoint.y;
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this._parent);
            var zoom = Math.min(viewPort.width / offwidth, viewPort.height / offheight);
            var panel = document.getElementById(this._canvas.id + "overviewrect");
            var bounds = panel.getBBox();
            var x = bounds.x + difx;
            var y = bounds.y + dify;
            var width = bounds.width;
            var height = bounds.height;
            this._updateOverviewrect(x, y, width, height);
            this._updateView(this._parent._currZoom, x, y, width, height, null);
        },

        _updateView: function (zoom, x, y, width, height, focuspoint) {
            var offwidth = this.width;
            var offheight = this.height;
            var scalex = this.contentWidth / offwidth;
            var scaley = this.contentHeight / offheight;
            var hoffset = x * scalex * zoom;
            var voffset = y * scaley * zoom;
            var bounds = this._parent._getDigramBounds();
            if (zoom != 1 || this._actionName == "pan") {
                var scrollModel = $("#" + this._parent._canvas.id + "_hScrollbar").ejScrollbar("instance").model;
                var scrollwidth = -hoffset + (scrollModel.maximum);
                var delx = -hoffset + this._parent._hScrollOffset;;
                var dely = -voffset + this._parent._vScrollOffset;
                if (bounds.width * zoom < scrollwidth) {
                    var difwidth = bounds.width * zoom - scrollwidth;
                    if (Math.abs(difwidth) < Math.abs(delx)) {
                        delx = delx - difwidth;
                    }
                    else delx = 0;
                }
                scrollModel = $("#" + this._parent._canvas.id + "_vScrollbar").ejScrollbar("instance").model;
                var scrollheight = -voffset + (scrollModel.maximum);
                if (bounds.height * zoom < scrollheight) {
                    var difwidth = bounds.height * zoom - scrollheight;
                    if (Math.abs(difwidth) < Math.abs(dely)) {
                        dely = dely - difwidth;
                    }
                    else dely = 0;
                }
            }
            ej.datavisualization.Diagram.ZoomUtil.zoomPan(this._parent, zoom / this._parent._currZoom, delx, dely, focuspoint, false);
        },

        _renderOverviewRect: function (x, y, width, height) {
            var offwidth = this.width;
            var offheight = this.height;
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this._parent);
            var viewwidth = (width / offwidth) * this.contentWidth;
            var viewheight = (height / offheight) * this.contentHeight;
            var zoom = Math.max(viewPort.width / viewwidth, viewPort.height / viewheight);
            if (zoom >= 0.25 && zoom <= 30) {
                this._updateView(zoom, x, y, width, height, new ej.datavisualization.Diagram.Point(0, 0));
                this._updateOverviewrect(x, y, width, height);
            }
        },

        handleTouchStart: function (evt) {
            evt.preventDefault();
        },

        handleTouchMove: function (evt) {
            evt.preventDefault();
        },

        handleTouchEnd: function (evt) {
            evt.preventDefault();
        },

        handleTouchLeave: function (evt) {
            evt.preventDefault();
        },

        //#endregion

    });
    //#endregion

})(jQuery, Syncfusion);;

(function ($, ej) {
    "use strict";

    //#region SVG
    var Canvas = (function () {
        function Canvas(attr) {
            this.document = document.createElement("canvas");
            this.id = attr.id;
            if (attr) {
                ej.datavisualization.Diagram.Util.attr(this.document, attr);
            }
            return this;
        }

        //rect
        Canvas.prototype.rect = function (x, y, width, height, rotation, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            if (style) {
                this.setStyle(style, ctx);
                if (style.dashArray)
                    this.dashedRectangle(x, y, width, height, style.dashArray);
                else
                    ctx.strokeRect(x, y, width, height);
            }
            else ctx.strokeRect(x, y, width, height);
            ctx.fillRect(x, y, width, height);
            ctx.closePath();
            if (rotation && rotation.angle)
                ctx.restore();
        }

        //ellipse
        Canvas.prototype.ellipse = function (cx, cy, rx, ry, rotation, style) {
            var ctx = this.document.getContext("2d");
            if (style) {
                this.setStyle(style, ctx);
            }
            var r = 4 * ((Math.sqrt(2) - 1) / 3);
            ctx.beginPath();
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            ctx.moveTo(cx, cy - ry);
            ctx.bezierCurveTo(cx + (r * rx), cy - ry, cx + rx, cy - (r * ry), cx + rx, cy);
            ctx.bezierCurveTo(cx + rx, cy + (r * ry), cx + (r * rx), cy + ry, cx, cy + ry);
            ctx.bezierCurveTo(cx - (r * rx), cy + ry, cx - rx, cy + (r * ry), cx - rx, cy);
            ctx.bezierCurveTo(cx - rx, cy - (r * ry), cx - (r * rx), cy - ry, cx, cy - ry);
            ctx.fill();
            if (style && style.dashArray) {
                this.bezierCurve(ej.datavisualization.Diagram.Point(cx, cy - ry),
                    new ej.datavisualization.Diagram.Point(cx + (r * rx), cy - ry),
                    new ej.datavisualization.Diagram.Point(cx + rx, cy - (r * ry)),
                    new ej.datavisualization.Diagram.Point(cx + rx, cy), style);
                this.bezierCurve(ej.datavisualization.Diagram.Point(cx + rx, cy),
                    new ej.datavisualization.Diagram.Point(cx + rx, cy + (r * ry)),
                    new ej.datavisualization.Diagram.Point(cx + (r * rx), cy + ry),
                    new ej.datavisualization.Diagram.Point(cx, cy + ry), style);
                this.bezierCurve(ej.datavisualization.Diagram.Point(cx, cy + ry),
                    new ej.datavisualization.Diagram.Point(cx - (r * rx), cy + ry),
                    new ej.datavisualization.Diagram.Point(cx - rx, cy + (r * ry)),
                    new ej.datavisualization.Diagram.Point(cx - rx, cy), style);
                this.bezierCurve(ej.datavisualization.Diagram.Point(cx - rx, cy),
                    new ej.datavisualization.Diagram.Point(cx - rx, cy - (r * ry)),
                    new ej.datavisualization.Diagram.Point(cx - (r * rx), cy - ry),
                    new ej.datavisualization.Diagram.Point(cx, cy - ry), style);
            }
            ctx.stroke();
            ctx.closePath();
            if (rotation && rotation.angle)
                ctx.restore();
        }

        //circle
        Canvas.prototype.circle = function (centerx, centery, radius, rotation, style) {
            var ctx = this.document.getContext("2d");
            if (style) {
                this.setStyle(style, ctx);
            }
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            if (style && style.dashArray) {
                ctx.beginPath();
                ctx.arc(centerx, centery, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                ctx.closePath();
            }
            else { this.ellipse(centerx, centery, radius * 2, radius * 2, rotation, style); }
            if (rotation && rotation.angle)
                ctx.restore();
        }
        Canvas.prototype.arc = function (centerx, centery, radius, angle, style) {
            var rotation = { "angle": angle, x: centerx, y: centery };
            var ctx = this.document.getContext("2d");
            if (style) {
                this.setStyle(style, ctx);
            }
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            ctx.beginPath();
            if (style && style.dashArray) {
                ctx.arc(centerx, centery, radius, 0, Math.PI);
            }
            else { ctx.arc(centerx, centery, radius, 0, Math.PI); }
            //ctx.fill();
            ctx.stroke();
            ctx.closePath();
            if (rotation && rotation.angle)
                ctx.restore();
        }

        //path
        Canvas.prototype.path = function (path, x, y, width, height, rotation, style) {
            var ctx = this.document.getContext("2d");
            if (style) {
                this.setStyle(style, ctx);
            }
            ctx.beginPath();
            ctx.translate(x, y);
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            var shape = document.createElementNS('http://www.w3.org/2000/svg', "path");
            shape.setAttribute("d", path);
            this.document.appendChild(shape);

            //path = this.absolutePath(shape);
            var segments = this.getSegments(shape);
            //var bounds = this.pathBounds(segments);
            //var oldX = bounds.x;
            //var oldY = bounds.y;
            //var newX = width / bounds.width;
            //var newY = height / bounds.height;
            var offsetX = x;
            var offsetY = y;
            var pathstr = "";
            var x0, y0, x1, y1, x2, y2, segs = segments;
            for (var x = 0, y = 0, i = 0, length = segs.length; i < length; ++i) {
                var seg = segs[i], char = seg.command;
                if ('x1' in seg) x1 = seg.x1;
                if ('x2' in seg) x2 = seg.x2;
                if ('y1' in seg) y1 = seg.y1;
                if ('y2' in seg) y2 = seg.y2;
                if ('x' in seg) x = seg.x;
                if ('y' in seg) y = seg.y;
                //if (bounds.width && bounds.height && (width != bounds.width || height != bounds.height)) {
                //    if (x != undefined) {
                //        x = this._scalePathData(x, newX, oldX, offsetX);
                //    }
                //    if (y != undefined) {
                //        y = this._scalePathData(y, newY, oldY, offsetY);
                //    }
                //    if (x1 != undefined) {
                //        x1 = this._scalePathData(x1, newX, oldX, offsetX);
                //    }
                //    if (y1 != undefined) {
                //        y1 = this._scalePathData(y1, newY, oldY, offsetY);
                //    }
                //    if (x2 != undefined) {
                //        x2 = this._scalePathData(x2, newX, oldX, offsetX);
                //    }
                //    if (y2 != undefined) {
                //        y2 = this._scalePathData(y2, newY, oldY, offsetY);
                //    }
                //}
                //else if (bounds.width && bounds.height) {
                //    if (x != undefined) {
                //        x = (x + newX);
                //    }
                //    if (y != undefined) {
                //        y = (y + newY);
                //    }
                //    if (x1 != undefined) {
                //        x1 = (x1 + newX);
                //    }
                //    if (y1 != undefined) {
                //        y1 = (y1 + newY);
                //    }
                //    if (x2 != undefined) {
                //        x2 = (x2 + newX);
                //    }
                //    if (y2 != undefined) {
                //        y2 = (y2 + newY);
                //    }
                //}

                switch (char) {
                    case 'M':
                        ctx.moveTo(x, y); seg.x = x; seg.y = y;
                        break;
                    case 'L':
                        ctx.lineTo(x, y);
                        seg.x = x; seg.y = y;
                        break;
                    case 'C':
                        ctx.bezierCurveTo(x1, y1, x2, y2, x, y);
                        seg.x = x; seg.y = y; seg.x1 = x1; seg.y1 = y1; seg.x2 = x2; seg.y2 = y2;
                        break;
                    case 'Q':
                        ctx.quadraticCurveTo(x1, y1, x, y);
                        seg.x = x; seg.y = y; seg.x1 = x1; seg.y1 = y1;
                        break;
                    case 'A'://need to update for "A"
                        var curr = new ej.datavisualization.Diagram.Point(x0, y0);
                        var rx = seg.r1, ry = seg.r2;
                        //if (isResizing) 
                        //{
                        //    rx = (rx * newX);
                        //    ry = (ry * newY);
                        //}
                        var xAxisRotation = seg.angle * (Math.PI / 180.0);
                        var largeArcFlag = seg.largeArcFlag;
                        var sweepFlag = seg.sweepFlag;
                        var cp = new ej.datavisualization.Diagram.Point(x, y);

                        // Conversion from endpoint to center parameterization
                        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
                        // x1', y1'
                        var currp = new ej.datavisualization.Diagram.Point(
                            Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
                            -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
                        );
                        // adjust radii
                        var l = Math.pow(currp.x, 2) / Math.pow(rx, 2) + Math.pow(currp.y, 2) / Math.pow(ry, 2);
                        if (l > 1) {
                            rx *= Math.sqrt(l);
                            ry *= Math.sqrt(l);
                        }
                        // cx', cy'
                        var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
                            ((Math.pow(rx, 2) * Math.pow(ry, 2)) - (Math.pow(rx, 2) * Math.pow(currp.y, 2)) - (Math.pow(ry, 2) * Math.pow(currp.x, 2))) /
                            (Math.pow(rx, 2) * Math.pow(currp.y, 2) + Math.pow(ry, 2) * Math.pow(currp.x, 2))
                        );
                        if (isNaN(s)) s = 0;
                        var cpp = new ej.datavisualization.Diagram.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
                        // cx, cy
                        var centp = new ej.datavisualization.Diagram.Point(
                            (curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
                            (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
                        );
                        // vector magnitude
                        var m = function (v) { return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2)); }
                        // ratio between two vectors
                        var r = function (u, v) { return (u[0] * v[0] + u[1] * v[1]) / (m(u) * m(v)) }
                        // angle between two vectors
                        var a = function (u, v) { return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(r(u, v)); }
                        // initial angle
                        var a1 = a([1, 0], [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry]);
                        // angle delta
                        var u = [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry];
                        var v = [(-currp.x - cpp.x) / rx, (-currp.y - cpp.y) / ry];
                        var ad = a(u, v);
                        if (r(u, v) <= -1) ad = Math.PI;
                        if (r(u, v) >= 1) ad = 0;

                        // for markers
                        var dir = 1 - sweepFlag ? 1.0 : -1.0;
                        var ah = a1 + dir * (ad / 2.0);
                        var halfWay = new ej.datavisualization.Diagram.Point(
                            centp.x + rx * Math.cos(ah),
                            centp.y + ry * Math.sin(ah)
                        );
                        seg.centp = centp;
                        seg.xAxisRotation = xAxisRotation;
                        seg.rx = rx;
                        seg.ry = ry;
                        seg.a1 = a1; seg.ad = ad; seg.sweepFlag = sweepFlag;
                        if (ctx != null) {
                            var r = rx > ry ? rx : ry;
                            var sx = rx > ry ? 1 : rx / ry;
                            var sy = rx > ry ? ry / rx : 1;
                            ctx.save();
                            ctx.translate(centp.x, centp.y);
                            ctx.rotate(xAxisRotation);
                            ctx.scale(sx, sy);
                            ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
                            ctx.scale(1 / sx, 1 / sy);
                            ctx.rotate(-xAxisRotation);
                            ctx.translate(-centp.x, -centp.y);
                            ctx.restore();
                        }
                        break;
                    case 'Z':
                        ctx.closePath();
                        x = x0; y = y0;
                        break;
                }
                // Record the start of a subpath
                x0 = x, y0 = y;
            }
            ctx.fill();
            if (style && style.dashArray)
                this.drawDashedPath(segs, style);
            else
                ctx.stroke();
            ctx.translate(-x, -y);
            if (rotation && rotation.angle)
                ctx.restore();
        }

        Canvas.prototype.getSegments = function (shape) {
            var x0, y0, x1, y1, x2, y2,initx,inity, segs = shape.pathSegList;
            var segments = [];
            for (var x = 0, y = 0, i = 0, length = segs.numberOfItems; i < length; ++i) {
                var seg = segs.getItem(i), char = seg.pathSegTypeAsLetter;
                if ('x1' in seg) x1 = seg.x1;
                if ('x2' in seg) x2 = seg.x2;
                if ('y1' in seg) y1 = seg.y1;
                if ('y2' in seg) y2 = seg.y2;
                if ('x' in seg) x = seg.x;
                if ('y' in seg) y = seg.y;
                switch (char) {
                    case 'M':
                        segments.push({ command: "M", x: x, y: y });
                        break;
                    case 'L':
                        segments.push({ command: "L", x0: x0, y0: y0, x: x, y: y });
                        break;
                    case 'H':
                        segments.push({ command: "L", x0: x0, y0: y0, x: x, y: y0 });
                        break;
                    case 'V':
                        segments.push({ command: "L", x0: x0, y0: y0, x: x0, y: y });
                        break;
                    case 'C':
                        segments.push({ command: "C", x0: x0, y0: y0, x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y });
                        break;
                    case 'S':
                        if (prev) {
                            if (prev.command == "C" || prev.command == "S") {
                                var ctrl = { x: prev.x2, y: prev.y2 };
                            }
                            else
                                var ctrl = { x: prev.x0, y: prev.y0 };
                            var cpt2 = new ej.datavisualization.Diagram.Point(2 * x0 - ctrl.x, 2 * y0 - ctrl.y);

                            segments.push({ command: "C", x0: x0, y0: y0, x1: cpt2.x, y1: cpt2.y, x2: x2, y2: y2, x: x, y: y });
                        }
                        break;
                    case 'Q':
                        //ctx.quadraticCurveTo(x1, y1, x, y);
                        segments.push({ command: "Q", x0: x0, y0: y0, x1: x1, y1: y1, x: x, y: y });
                        break;
                    case 'T':
                        if (prev) {
                            if (prev.command == "Q") {
                                var ctrl = { x: prev.x1, y: prev.y1 };
                            }
                            else
                                var ctrl = { x: prev.x0, y: prev.y0 };
                            var cpt2 = new ej.datavisualization.Diagram.Point(2 * x0 - ctrl.x, 2 * y0 - ctrl.y);

                            segments.push({ command: "Q", x0: x0, y0: y0, x1: cpt2.x, y1: cpt2.y, x: x, y: y });
                        }
                        break;
                    case 'A'://need to update for "A"
                        var newSeg = $.extend(true, {}, seg);
                        newSeg.command = "A";
                        segments.push(newSeg);
                        break;
                    case 'Z':
                        segments.push({ command: "L", x0: x, y0: y, x: initx, y: inity });
                        x = x0; y = y0;
                        break;
                }
                var prev = segments[segments.length - 1];
                // Record the start of a subpath
                if (char === 'M' || char === 'm') {
                   initx = x, inity = y;
                }
                 x0 = x, y0 = y;
            }
            return segments;
        }

        Canvas.prototype.drawDashedPath = function (segs, style) {
            var x1, y1, x2, y2, x0, y0;
            var initial;
            for (var x = 0, y = 0, i = 0, length = segs.length; i < length; ++i) {
                var seg = segs[i], char = seg.command;
                if ('x1' in seg) x1 = seg.x1;
                if ('x2' in seg) x2 = seg.x2;
                if ('y1' in seg) y1 = seg.y1;
                if ('y2' in seg) y2 = seg.y2;
                if ('x' in seg) x = seg.x;
                if ('y' in seg) y = seg.y;
                switch (char) {
                    case 'M':
                        initial = { x: x, y: y };
                        break;
                    case 'L':
                        this.dashedLine(x0, y0, x, y, style.dashArray);
                        break;
                    case 'H':
                        this.dashedLine(x0, y0, x, y0, style.dashArray);
                        break;
                    case 'V':
                        this.dashedLine(x0, y0, x0, y, style.dashArray);
                        break;
                    case 'C':
                        this.bezierCurve(ej.datavisualization.Diagram.Point(x0, y0), ej.datavisualization.Diagram.Point(x1, y1), ej.datavisualization.Diagram.Point(x2, y2), ej.datavisualization.Diagram.Point(x, y), style);
                        break;
                    case 'Q':
                        this.quadraticCurve(ej.datavisualization.Diagram.Point(x0, y0), ej.datavisualization.Diagram.Point(x1, y1), ej.datavisualization.Diagram.Point(x, y), style);
                        break;
                    case 'A':
                        var ctx = this.document.getContext("2d");
                        if (ctx != null) {
                            var r = seg.rx > seg.ry ? seg.rx : seg.ry;
                            var sx = seg.rx > seg.ry ? 1 : seg.rx / seg.ry;
                            var sy = seg.rx > seg.ry ? seg.ry / seg.rx : 1;
                            ctx.save();
                            ctx.translate(seg.centp.x, seg.centp.y);
                            ctx.rotate(seg.xAxisRotation);
                            ctx.scale(sx, sy);
                            this.dashedArc(r, 0, 0, seg.a1, seg.a1 + seg.ad, 1 - seg.sweepFlag, style.dashArray);
                            ctx.scale(1 / sx, 1 / sy);
                            ctx.rotate(-seg.xAxisRotation);
                            ctx.translate(-seg.centp.x, -seg.centp.y);
                            ctx.restore();
                        }
                        break;
                    case 'Z':
                        //ctx.closePath();
                        this.dashedLine(x, y, initial.x, initial.y, style.dashArray);
                        x = x0; y = y0;
                        break;
                }
                // Record the start of a subpath
                //if (char === 'M' || char === 'm') x0 = x, y0 = y;
                x0 = x, y0 = y;
            }
            //ctx.fill();
        }
        Canvas.prototype.calculateCirclePoints = function (radius, cx, cy, stAngle, endAngle, couterClockwise, dashSize) {
            stAngle = stAngle * 180 / Math.PI;
            endAngle = endAngle * 180 / Math.PI;
            var n = (2 * Math.PI * radius) * (Math.abs(stAngle - endAngle) / 360) * 0.7;
            var alpha = Math.abs(stAngle - endAngle) / n;
            alpha = couterClockwise ? alpha * -1 : alpha;
            var i = 0;
            var points = [];
            while (i < n) {
                points.push(ej.datavisualization.Diagram.Geometry.transform({ x: cx, y: cy }, stAngle + alpha * i, radius));
                i++;
            }
            return points;
        }

        //polygon
        Canvas.prototype.polygon = function (points, rotation, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            if (style) {
                this.setStyle(style, ctx);
            }
            ctx.moveTo(points[0].x, points[0].y);
            for (var i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.lineTo(points[0].x, points[0].y);
            ctx.fill();
            if (style && style.dashArray) {
                for (var i = 1; i < points.length; i++) {
                    this.line(points[i - 1], points[i], style);
                }
                this.line(points[i - 1], points[0], style);
            }
            ctx.stroke();
            ctx.closePath();
            if (rotation && rotation.angle)
                ctx.restore();
        }

        //image
        Canvas.prototype.image = function (image, x, y, width, height, rotation, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            if (style) {
                this.setStyle(style, ctx);
            }
            if (width && height)
                ctx.drawImage(image, x, y, width, height);
            else
                ctx.drawImage(image, x, y);
            ctx.closePath();
            if (rotation && rotation.angle)
                ctx.restore();
        }

        //text
        Canvas.prototype.text = function (text, x, y, rotation, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            if (style)
                this.setStyle(style, ctx);
            ctx.fillText(text.text, x, y);
            ctx.closePath();
            if (rotation && rotation.angle)
                ctx.restore();
        }

        //line
        Canvas.prototype.line = function (start, end, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            if (style) {
                this.setStyle(style, ctx);
            }
            if (style && style.dashArray) {
                this.dashedLine(start.x, start.y, end.x, end.y, style.dashArray);
            }
            else {
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
            }
            ctx.closePath();
        }

        //polyline
        Canvas.prototype.polyline = function (points, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            if (style) {
                this.setStyle(style, ctx);
            }
            for (var i = 1; i < points.length; i++) {
                this.line(points[i - 1], points[i], style);
            }
            ctx.stroke();
        }

        //bezier curve
        Canvas.prototype.bezierCurve = function (startPoint, cpt1, cpt2, cpt3, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            if (style) {
                this.setStyle(style, ctx);
            }
            if (style && style.dashArray) {
                var points = [];
                this.flattenCubicBezier(points, startPoint, cpt1, cpt2, cpt3);
                var dashLength = 0;
                for (var i = 0; i < style.dashArray.length; i++) {
                    dashLength += Number(style.dashArray[i]);
                }
                var dashcount = points.length / dashLength;
                var draw = true;
                var drawn = 0;
                for (var i = 0; i < dashcount; i++) {
                    for (var j = 0; j < style.dashArray.length; j++) {
                        drawn += Number(style.dashArray[j]);
                        if (drawn < points.length) {
                            if (draw) {
                                ctx.lineTo(points[drawn].x, points[drawn].y);
                            }
                            else ctx.moveTo(points[drawn].x, points[drawn].y);
                        }
                        draw = !draw;
                    }
                }


            }
            else {
                ctx.moveTo(startPoint.x, startPoint.y);
                ctx.bezierCurveTo(cpt1.x, cpt1.y, cpt2.x, cpt2.y, cpt3.x, cpt3.y);
            }
            ctx.stroke();
        }

        Canvas.prototype.quadraticCurve = function (startPoint, cpt1, cpt2, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            if (style) {
                this.setStyle(style, ctx);
            }
            if (style && style.dashArray) {
                var points = [];
                this.flattenQuadraticBezier(points, startPoint, cpt1, cpt2);
                var dashLength = 0;
                for (var i = 0; i < style.dashArray.length; i++) {
                    dashLength += Number(style.dashArray[i]);
                }
                var dashcount = points.length / dashLength;
                var draw = true;
                var drawn = 0;
                for (var i = 0; i < dashcount; i++) {
                    for (var j = 0; j < style.dashArray.length; j++) {
                        drawn += Number(style.dashArray[j]);
                        if (drawn < points.length) {
                            if (draw) {
                                ctx.lineTo(points[drawn].x, points[drawn].y);
                            }
                            else ctx.moveTo(points[drawn].x, points[drawn].y);
                        }
                        draw = !draw;
                    }
                }

            }
            else {
                ctx.moveTo(startPoint.x, startPoint.y);
                ctx.quadraticCurveTo(cpt1.x, cpt1.y, cpt2.x, cpt2.y);
            }
            ctx.stroke();
        }

        //arrow
        Canvas.prototype.arrow = function (point, rotation, size, isOpen, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            if (style) {
                this.setStyle(style, ctx);
            }
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            ctx.moveTo(point.x + size.width, point.y + size.height / 2);
            ctx.lineTo(point.x, point.y);
            ctx.lineTo(point.x + size.width, point.y - size.height / 2);
            if (!isOpen) {
                ctx.closePath();
                ctx.fill();
            }
            ctx.stroke();
            if (rotation && rotation.angle)
                ctx.restore();
        }

        //diamond
        Canvas.prototype.diamond = function (point, rotation, size, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            if (style) {
                this.setStyle(style, ctx);
            }
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            ctx.moveTo(point.x + size.width, point.y);
            ctx.lineTo(point.x + size.width / 2, point.y + size.height / 2);
            ctx.lineTo(point.x, point.y);
            ctx.lineTo(point.x + size.width / 2, point.y - size.height / 2);
            ctx.stroke();
            ctx.fill();
            ctx.closePath();
            if (rotation && rotation.angle)
                ctx.restore();
        }

        Canvas.prototype.dashedLine = function (x1, y1, x2, y2, dashArray) {
            var ctx = this.document.getContext("2d");
            ctx.save();
            var dx = (x2 - x1), dy = (y2 - y1);
            var length = Math.sqrt(dx * dx + dy * dy);
            var angle = Math.atan2(dy, dx);
            ctx.beginPath();
            ctx.translate(x1, y1);
            ctx.moveTo(0, 0);
            ctx.rotate(angle);
            var dcount = dashArray.length;
            var dindex = 0, draw = true;
            var x = 0;
            while (length > x) {
                x += Number(dashArray[dindex++ % dcount]);
                if (x > length) x = length;
                draw ? ctx.lineTo(x, 0) : ctx.moveTo(x, 0);
                draw = !draw;
                ctx.stroke();
            }
            ctx.restore();
        }

        Canvas.prototype.dashedRectangle = function (x, y, width, height, dashArray) {
            this.dashedLine(x, y, x + width, y, dashArray);
            this.dashedLine(x + width, y, x + width, y + height, dashArray);
            this.dashedLine(x + width, y + height, x, y + height, dashArray);
            this.dashedLine(x, y + height, x, y, dashArray);
        }

        Canvas.prototype.dashedArc = function (radius, cx, cy, stAngle, endAngle, couterClockwise, dashArray) {
            var dashLength = 0;
            for (var i = 0; i < dashArray.length; i++) {
                dashLength += Number(dashArray[i]);
            }
            var points = this.calculateCirclePoints(radius, cx, cy, stAngle, endAngle, couterClockwise, dashLength);
            var ctx = this.document.getContext("2d");
            ctx.beginPath();

            var dashcount = points.length / dashLength;
            var draw = true;
            var drawn = 0;
            for (var i = 0; i < dashcount; i++) {
                for (var j = 0; j < dashArray.length; j++) {
                    drawn += Number(dashArray[j]);
                    if (drawn < points.length) {
                        if (draw) {
                            ctx.lineTo(points[drawn].x, points[drawn].y);
                            ctx.stroke();
                        }
                        else ctx.moveTo(points[drawn].x, points[drawn].y);
                    }
                    draw = !draw;
                }
            }
            ctx.closePath();
        }
        Canvas.prototype.absolutePath = function (path) {
            var minx, miny, maxx, maxy;
            var x0, y0, x1, y1, x2, y2, segs = path.pathSegList;
            for (var x = 0, y = 0, i = 0, length = segs.numberOfItems; i < length; ++i) {
                var seg = segs.getItem(i), char = seg.pathSegTypeAsLetter;
                if (/[MLHVCSQTA]/.test(char)) {
                    if ('x' in seg) x = seg.x;
                    if ('y' in seg) y = seg.y;
                } else {
                    if ('x1' in seg) x1 = x + seg.x1;
                    if ('x2' in seg) x2 = x + seg.x2;
                    if ('y1' in seg) y1 = y + seg.y1;
                    if ('y2' in seg) y2 = y + seg.y2;
                    if ('x' in seg) x += seg.x;
                    if ('y' in seg) y += seg.y;
                    switch (char) {
                        case 'm': segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i); break;
                        case 'l': segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i); break;
                        case 'h': segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i); break;
                        case 'v': segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i); break;
                        case 'c': segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i); break;
                        case 's': segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i); break;
                        case 'q': segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i); break;
                        case 't': segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i); break;
                        case 'a': segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i); break;
                        case 'z': case 'Z': x = x0; y = y0; break;
                    }
                }
                if (char === 'M' || char === 'm') x0 = x, y0 = y;
            }

            Canvas.prototype._scalePathData = function (val, scaleFactor, oldOffset, newOffset) {
                if (val !== oldOffset) {
                    if (newOffset !== oldOffset) {
                        val = (((val * scaleFactor) - (Number(oldOffset) * scaleFactor - Number(oldOffset)))
                            + (newOffset - Number(oldOffset)));
                    }
                    else
                        val = ((Number(val) * scaleFactor) - (Number(oldOffset) * scaleFactor - Number(oldOffset)));
                }
                else {
                    if (newOffset !== oldOffset) {
                        val = newOffset;
                    }
                }
                return val;
            }
            return path;
        };

        Canvas.prototype.setStyle = function (style, ctx) {
            if (style.fill)
                ctx.fillStyle = style.fill;
            if (style.stroke)
                ctx.strokeStyle = style.stroke;
            if (style.font)
                ctx.font = style.font;
        }

        Canvas.prototype.rotateContext = function (rotation, ctx) {
            ctx.save();
            ctx.translate(rotation.x, rotation.y);
            ctx.rotate(rotation.angle * Math.PI / 180);
            ctx.translate(-rotation.x, -rotation.y);
        }

        Canvas.prototype.pathBounds = function (segments) {
            //var segs = shape.pathSegList;
            var x1, y1, x2, y2, x0, y0;
            var minx, miny, maxx, maxy;
            for (var x = 0, y = 0, i = 0, length = segments.length; i < length; ++i) {
                var seg = segments[i], char = seg.command;
                if (i == 0 && seg.x && seg.y) {
                    minx = maxx = seg.x;
                    miny = maxy = seg.y;
                }
                //var seg = segs.getItem(i), char = seg.pathSegTypeAsLetter;
                if ('x1' in seg) x1 = seg.x1;
                if ('x2' in seg) x2 = seg.x2;
                if ('y1' in seg) y1 = seg.y1;
                if ('y2' in seg) y2 = seg.y2;
                if ('x' in seg) x = seg.x;
                if ('y' in seg) y = seg.y;

                switch (char) {
                    case 'M':
                        x0 = x; y0 = y;
                    case 'L':
                    case 'H':
                    case 'V':
                        if (x) {
                            minx = Math.min(x, minx);
                            maxx = Math.max(x, maxx);
                        }
                        if (y) {
                            miny = Math.min(y, miny);
                            maxy = Math.max(y, maxy);
                        }
                        break;
                    case 'C':

                    case 'S':
                        var bounds = this.getBezierBounds(ej.datavisualization.Diagram.Point(x0, y0), ej.datavisualization.Diagram.Point(x1, y1), ej.datavisualization.Diagram.Point(x2, y2), ej.datavisualization.Diagram.Point(x, y));
                        minx = Math.min(bounds.x, minx);
                        maxx = Math.max(bounds.x + bounds.width, maxx);
                        miny = Math.min(bounds.y, miny);
                        maxy = Math.max(bounds.y + bounds.height, maxy);
                        break;
                    case 'Q':
                    case "q":
                    case 'T':
                        var bounds = this.getQuadraticBounds(ej.datavisualization.Diagram.Point(x0, y0), ej.datavisualization.Diagram.Point(x1, y1), ej.datavisualization.Diagram.Point(x, y));
                        minx = Math.min(bounds.x, minx);
                        maxx = Math.max(bounds.x + bounds.width, maxx);
                        miny = Math.min(bounds.y, miny);
                        maxy = Math.max(bounds.y + bounds.height, maxy);
                        break;
                    case 'A':
                        break;
                    case 'Z':
                        //ctx.closePath();
                        x = x0; y = y0;
                        break;
                }
            }
            return { x: minx, y: miny, width: maxx - minx, height: maxy - miny };
        };

        Canvas.prototype.flattenCubicBezier = function (points, ptStart, ptCtrl1, ptCtrl2, ptEnd, tolerance) {
            var tolerance = 1.5;

            var max = Number((ej.datavisualization.Diagram.Geometry.distance(ptCtrl1, ptStart) +
                              ej.datavisualization.Diagram.Geometry.distance(ptCtrl2, ptCtrl1) +
                              ej.datavisualization.Diagram.Geometry.distance(ptEnd, ptCtrl2)) / tolerance);

            for (var i = 0; i <= max; i++) {
                var t = i / max;

                var x = (1 - t) * (1 - t) * (1 - t) * ptStart.x +
                           3 * t * (1 - t) * (1 - t) * ptCtrl1.x +
                           3 * t * t * (1 - t) * ptCtrl2.x +
                           t * t * t * ptEnd.x;

                var y = (1 - t) * (1 - t) * (1 - t) * ptStart.y +
                           3 * t * (1 - t) * (1 - t) * ptCtrl1.y +
                           3 * t * t * (1 - t) * ptCtrl2.y +
                           t * t * t * ptEnd.y;

                points.push(new ej.datavisualization.Diagram.Point(x, y));
            }
        }

        Canvas.prototype.flattenQuadraticBezier = function (points, ptStart, ptCtrl1, ptEnd, tolerance) {
            var tolerance = 1.5;

            var max = Number((ej.datavisualization.Diagram.Geometry.distance(ptCtrl1, ptStart) +
                             ej.datavisualization.Diagram.Geometry.distance(ptEnd, ptCtrl1)) / tolerance);

            for (var i = 0; i <= max; i++) {
                var t = i / max;

                var x = (1 - t) * (1 - t) * ptStart.x +
                                          2 * t * (1 - t) * ptCtrl1.x +
                                          t * t * ptEnd.x;

                var y = (1 - t) * (1 - t) * ptStart.y +
                           2 * t * (1 - t) * ptCtrl1.y +
                           t * t * ptEnd.y;

                points.push(new ej.datavisualization.Diagram.Point(x, y));
            }
        }

        Canvas.prototype.getBezierBounds = function (ptStart, ptCtrl1, ptCtrl2, ptEnd, tolerance) {
            var tolerance = 3;
            var minx, miny, maxx, maxy;
            var max = Number((ej.datavisualization.Diagram.Geometry.distance(ptCtrl1, ptStart) +
                              ej.datavisualization.Diagram.Geometry.distance(ptCtrl2, ptCtrl1) +
                              ej.datavisualization.Diagram.Geometry.distance(ptEnd, ptCtrl2)) / tolerance);

            for (var i = 0; i <= max; i++) {

                var t = i / max;

                var x = (1 - t) * (1 - t) * (1 - t) * ptStart.x +
                           3 * t * (1 - t) * (1 - t) * ptCtrl1.x +
                           3 * t * t * (1 - t) * ptCtrl2.x +
                           t * t * t * ptEnd.x;

                var y = (1 - t) * (1 - t) * (1 - t) * ptStart.y +
                           3 * t * (1 - t) * (1 - t) * ptCtrl1.y +
                           3 * t * t * (1 - t) * ptCtrl2.y +
                           t * t * t * ptEnd.y;
                if (i == 0) {
                    minx = maxx = x;
                    miny = maxy = y;
                }
                else {
                    minx = Math.min(x, minx);
                    miny = Math.min(y, miny);
                    maxx = Math.max(x, maxx);
                    maxy = Math.max(y, maxy);
                }
            }
            return { x: minx, y: miny, width: maxx - minx, height: maxy - miny };
        }

        Canvas.prototype.getQuadraticBounds = function (ptStart, ptCtrl1, ptEnd, tolerance) {
            var tolerance = 3;
            var minx, miny, maxx, maxy;
            var max = Number((ej.datavisualization.Diagram.Geometry.distance(ptCtrl1, ptStart) +
                              ej.datavisualization.Diagram.Geometry.distance(ptEnd, ptCtrl1)) / tolerance);

            for (var i = 0; i <= max; i++) {
                var t = i / max;


                var x = (1 - t) * (1 - t) * ptStart.x +
                           2 * t * (1 - t) * ptCtrl1.x +
                           t * t * ptEnd.x;

                var y = (1 - t) * (1 - t) * ptStart.y +
                           2 * t * (1 - t) * ptCtrl1.y +
                           t * t * ptEnd.y;

                if (i == 0) {
                    minx = maxx = x;
                    miny = maxy = y;
                }
                else {
                    minx = Math.min(x, minx);
                    miny = Math.min(y, miny);
                    maxx = Math.max(x, maxx);
                    maxy = Math.max(y, maxy);
                }
            }
            return { x: minx, y: miny, width: maxx - minx, height: maxy - miny };
        }

        return Canvas;
    })();

    ej.datavisualization.Diagram.Canvas = Canvas;
    //#endregion

    //#region Renderer
    ej.datavisualization.Diagram.CanvasContext = {

        _renderDocument: function (view, diagram) {
            var attr = {
                id: view.canvas.id + "_canvas",
                width: diagram._canvas.clientWidth,
                height: diagram._canvas.clientHeight,
                version: "1.1",
                xlink: "http://www.w3.org/1999/xlink",
                "style": view.style,
                "pointer-events": "none"
            };
            view._canvas = new ej.datavisualization.Diagram.Canvas(attr);
            diagram._view = view.canvas;
            view.canvas.appendChild(view._canvas.document);
            if (view.type == "mainview") {
                this._canvas = view.canvas;
                diagram._svg = this._svg = view._canvas;
            }
        },

        _renderGroupBackground: function (group, canvas, diagram) {
            if (!group.pivot) {
                group.pivot = {};
                group.pivot.x = .5;
                group.pivot.y = .5;
            }

            var ctx = canvas.document.getContext("2d");
            if (group.visible) {
                var rotation = { "angle": group.rotateAngle, x: group.offsetX, y: group.offsetY };
                ctx.save();
                ctx.translate(rotation.x, rotation.y);
                ctx.rotate(rotation.angle * Math.PI / 180);
                ctx.translate(-rotation.x, -rotation.y);
                ctx.save();
                ctx.fillStyle = group.fillColor;
                ctx.strokeStyle = group.borderColor;
                ctx.lineWidth = group.borderWidth;
                if (group.borderDashArray) {
                    if (group.borderDashArray.indexOf("[") != -1 || group.borderDashArray instanceof Array) {
                        dashArray = group.borderDashArray;
                    } else if (group.borderDashArray.indexOf(",") != -1) {
                        var dashArray = group.borderDashArray.split(",");
                    } else if (group.borderDashArray.indexOf(" ") != -1) {
                        var dashArray = group.borderDashArray.split(" ");
                    }
                    if (ctx.setLineDash) {
                        ctx.setLineDash(dashArray);
                    } else if (ctx.mozDash) {
                        ctx.mozDash = dashArray;
                    } else {
                        var style = { dashArray: dashArray };
                    }
                }
            }

            var x = group.offsetX - group.width * group.pivot.x;
            var y = group.offsetY - group.height * group.pivot.y;
            canvas.rect(x, y, group.width, group.height, null, style);
        },

        renderGroup: function (group, canvas, diagram) {
            if (group.visible) {
                this._renderGroupBackground(group, canvas, diagram);
                for (var i = 0; i < group.children.length; i++) {
                    var child = diagram.nameTable[group.children[i]];
                    if (child) {
                        if (child.type == "group") {
                            this.renderGroup(child, canvas, diagram);
                        }
                        else if (child.shape) {
                            this.renderNode(child, canvas);
                        }
                        else if (child.line) {
                            this.renderConnector(child, canvas);
                        }
                    }
                }
            }
        },

        renderNode: function (node, canvas) {

            var ctx = canvas.document.getContext("2d");
            if (node.visible) {
                var rotation = { "angle": node.rotateAngle, x: node.offsetX, y: node.offsetY };
                ctx.save();
                ctx.translate(rotation.x, rotation.y);
                ctx.rotate(rotation.angle * Math.PI / 180);
                ctx.translate(-rotation.x, -rotation.y);
                ctx.save();
                ctx.fillStyle = node.fillColor;
                ctx.strokeStyle = node.borderColor;
                ctx.lineWidth = node.borderWidth;
                ctx.globalAlpha = node.opacity;
                if (node.borderDashArray) {
                    if (node.borderDashArray.indexOf("[") != -1 || node.borderDashArray instanceof Array) {
                        dashArray = node.borderDashArray;
                    }
                    else
                        if (node.borderDashArray.indexOf(",") != -1) {
                            var dashArray = node.borderDashArray.split(",");
                        }
                        else if (node.borderDashArray.indexOf(" ") != -1) { var dashArray = node.borderDashArray.split(" "); }
                    if (ctx.setLineDash) {
                        ctx.setLineDash(dashArray);
                    }
                    else if (ctx.mozDash) { ctx.mozDash = dashArray; }
                    else
                    {
                        var style = { dashArray: dashArray };
                    }
                }
                var x = node.offsetX - node.width * node.pivot.x;
                var y = node.offsetY - node.height * node.pivot.y;
                if (node.shape.type == "path")
                    this._renderGradient(node, ctx, 0, 0);
                else
                    this._renderGradient(node, ctx, x, y);
                var fill = node.fillColor;
                if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
                    ctx.save();
                    ctx.strokeStyle = "lightgrey";
                    ctx.fillStyle = fill != "none" || fill != "transparent" ? "lightgrey" : "none";
                    switch (node.shape.type) {
                        case "image":
                        case "rectangle":
                            canvas.rect(x + 5, y + 5, node.width, node.height, null);
                            break;
                        case "ellipse":
                            canvas.ellipse(node.offsetX + 5, node.offsetY + 5, node.width, node.height, null);
                            break;
                        case "path":
                            canvas.path(node._absolutePath, x + 5, y + 5, node.width, node.height, null);
                            break;
                        case "polygon":
                            this._updatePolygonPoints(node);
                            ctx.translate(5, 5);
                            canvas.polygon(node.shape.points, null, style);
                            break;
                    }
                    ctx.restore();
                }

                switch (node.shape.type) {
                    case "rectangle":
                        canvas.rect(x, y, node.width, node.height, null, style);
                        break;
                    case "ellipse":
                        canvas.ellipse(node.offsetX, node.offsetY, node.width / 2, node.height / 2, null, style);
                        break;
                    case "path":
                        canvas.path(node._absolutePath, x, y, node.width, node.height, null, style);
                        break;
                    case "image":
                        canvas.rect(x, y, node.width, node.height, null, style);
                        var image = new Image();
                        image.src = node.shape.src;
                        var rotation = { angle: node.rotateAngle, x: node.offsetX, y: node.offsetY };
                        canvas.image(image, x, y, node.width, node.height, rotation);

                        break;
                    case "text":
                        canvas.rect(x, y, node.width, node.height, null, style);
                        if (node.shape.textBlock) {
                            var font = "";
                            if (node.shape.textBlock.italic)
                                font += "italic ";
                            if (node.shape.textBlock.bold)
                                font += "bold ";
                            font += node.shape.textBlock.fontSize + " ";
                            font += node.shape.textBlock.fontFamily;
                            ctx.font = font;
                            ctx.fillStyle = node.shape.textBlock.fontColor;
                            this._renderTextElement(node, node.shape.textBlock, canvas);
                        }
                        break;
                    case "polygon":
                        this._updatePolygonPoints(node);
                        canvas.polygon(node.shape.points, null, style);
                        break;
                }
                ctx.restore();
                this.renderLabels(node, canvas);
                this.renderPorts(node, canvas, x, y);
                ctx.restore();
            }
        },

        renderPhases: function (phase, canvas, points) {
            var style;
            if (phase && canvas) {
                var ctx = canvas.document.getContext("2d");
                ctx.save();
                ctx.strokeStyle = phase.lineColor ? phase.lineColor : "black";
                ctx.lineWidth = phase.lineWidth ? phase.lineWidth : 1;
                if (phase.lineDashArray) {
                    if (phase.lineDashArray.indexOf("[") != -1 || phase.lineDashArray instanceof Array) {
                        dashArray = phase.lineDashArray;
                    }
                    else {
                        if (phase.lineDashArray.indexOf(",") != -1) {
                            var dashArray = phase.lineDashArray.split(",");
                        }
                        else if (phase.lineDashArray.indexOf(" ") != -1) { var dashArray = phase.lineDashArray.split(" "); }
                    }

                    if (ctx.setLineDash) { ctx.setLineDash(dashArray); }
                    else if (ctx.mozDash) { ctx.mozDash = dashArray; }
                    else
                        style = { "dashArray": dashArray }
                }
                if (points && points.length > 0) {
                    canvas.line(points[0], points[1], style);
                }
            }
        },

        renderConnector: function (connector, canvas) {
            if (connector.visible) {
                var ctx = canvas.document.getContext("2d");
                ctx.save();
                ctx.strokeStyle = connector.lineColor;
                ctx.lineWidth = connector.lineWidth;
                if (connector.lineDashArray) {
                    if (connector.lineDashArray.indexOf("[") != -1 || connector.lineDashArray instanceof Array) {
                        dashArray = connector.lineDashArray;
                    }
                    else {
                        if (connector.lineDashArray.indexOf(",") != -1) {
                            var dashArray = connector.lineDashArray.split(",");
                        }
                        else if (connector.lineDashArray.indexOf(" ") != -1) { var dashArray = connector.lineDashArray.split(" "); }
                    }

                    if (ctx.setLineDash) { ctx.setLineDash(dashArray); }
                    else if (ctx.mozDash) { ctx.mozDash = dashArray; }
                    else
                        var style = { "dashArray": dashArray }
                }
                if (connector.segments) {
                    this._renderSegments(connector, canvas, style);
                }
                ctx.restore();
                this.renderLabels(connector, canvas);
                this._renderDecorators(connector, canvas);
            }
        },
        _renderSegments: function (connector, canvas, style) {
            for (var i = 0; i < connector.segments.length; i++) {
                var segment = connector.segments[i];
                if (segment._bridges.length > 0) {
                    for (var n = 0; n < segment._bridges.length; n++) {
                        var bridge = segment._bridges[n];
                        bridge._rendered = false;
                    }
                }
                if (segment.type == "bezier") {
                    canvas.bezierCurve(segment._startPoint, segment._point1, segment._point2, segment._endPoint, style);
                }
                else {
                    if (connector.cornerRadius > 0) {
                        var points = segment.points;
                        var st, end;
                        for (var j = 0; j < points.length - 1; j++) {
                            if (segment._bridges.length > 0 && j > 0) {
                                this._updateBridging(segment, canvas, j, st ? st : points[j], end ? end : points[j + 1], connector.bridgeSpace, style, true);
                            }
                            var segLength = ej.datavisualization.Diagram.Geometry.distance(points[j], points[j + 1]);
                            if (segLength > 0) {
                                var endpoint = end;
                                if (i < connector.segments.length - 1 || j < points.length - 2) {
                                    if (segLength < connector.cornerRadius * 2) {
                                        end = this._adjustPoint(points[j], points[j + 1], false, segLength / 2);
                                    }
                                    else end = this._adjustPoint(points[j], points[j + 1], false, connector.cornerRadius);
                                }
                                else end = points[j + 1];

                                if (i > 0 || j > 0) {
                                    if (segLength < connector.cornerRadius * 2) {
                                        st = this._adjustPoint(points[j], points[j + 1], true, segLength / 2);
                                        if (i < connector.segments.length - 1 || j < points.length - 2)
                                            end = null;
                                    }
                                    else st = this._adjustPoint(points[j], points[j + 1], true, connector.cornerRadius);
                                }
                                if (st) {
                                    canvas.quadraticCurve(endpoint, points[j], st, style);
                                }
                                else st = points[j];
                                if (end) {
                                    if (j + 1 === points.length - 1 && segment._bridges.length > 0) {
                                        this._updateBridging(segment, canvas, j + 1, st ? st : points[j], end ? end : points[j + 1], connector.bridgeSpace, style, true);
                                        var renderLastPt = false;
                                        for (var n = 0; n < segment._bridges.length; n++) {
                                            var bridge = segment._bridges[n];
                                            if (bridge.segmentPointIndex === j + 1) {
                                                renderLastPt = true;
                                            }
                                        }
                                        if (!renderLastPt)
                                            canvas.line(st, end, style);
                                    }
                                    else if (!(segment._bridges.length > 0)) {
                                        canvas.line(st, end, style);
                                    }
                                }
                            }
                        }
                    }
                    else {
                        for (var k = 1; k < segment.points.length; k++) {
                            if (segment._bridges.length > 0) {
                                this._updateBridging(segment, canvas, k, segment.points[k - 1], segment.points[k], connector.bridgeSpace, style);
                            }
                            else
                                canvas.line(segment.points[k - 1], segment.points[k], style);
                        }
                    };
                }
            }
        },

        _updateBridging: function (seg, canvas, pointIndex, startPt, endPt, bridgeSpace, style, end) {
            var bridgeSP;
            var angle = this._findAngle(startPt, endPt);
            if (seg._bridges.length > 0) {
                if (seg.type === "straight") {
                    for (var n = 0; n < seg._bridges.length; n++) {
                        var bridge = seg._bridges[n];
                        if (!bridge._rendered) {
                            bridgeSP = seg._bridges[n - 1] != null ? seg._bridges[n - 1].endPoint : startPt;
                            canvas.line(bridgeSP, bridge.startPoint, style);
                            var centerX = bridge.startPoint.x + ((bridge.endPoint.x - bridge.startPoint.x) / 2);
                            var centerY = bridge.startPoint.y + ((bridge.endPoint.y - bridge.startPoint.y) / 2);
                            canvas.arc(centerX, centerY, bridgeSpace / 2, angle, style);
                            if (seg._bridges[n + 1] != null)
                                canvas.line(bridge.endPoint, seg._bridges[n + 1].startPoint, style);
                            else
                                canvas.line(bridge.endPoint, endPt, style);
                            bridge._rendered = true;
                        }

                    }
                }
                else if (seg.type === "orthogonal") {
                    for (var n = 0; n < seg._bridges.length; n++) {
                        var bridge = seg._bridges[n];
                        if (bridge.segmentPointIndex === pointIndex && !bridge._rendered) {
                            bridgeSP = seg._bridges[n - 1] != null ? seg._bridges[n - 1].endPoint : startPt;
                            canvas.line(bridgeSP, bridge.startPoint, style);
                            var centerX = bridge.startPoint.x + ((bridge.endPoint.x - bridge.startPoint.x) / 2);
                            var centerY = bridge.startPoint.y + ((bridge.endPoint.y - bridge.startPoint.y) / 2);
                            canvas.arc(centerX, centerY, bridgeSpace / 2, angle, style);
                            if (seg._bridges[n + 1] != null)
                                canvas.line(bridge.endPoint, seg._bridges[n + 1].startPoint, style);
                            else
                                canvas.line(bridge.endPoint, endPt, style);
                            bridge._rendered = true;
                        }
                        else {
                            if (!end)
                                canvas.line(startPt, endPt, style);
                        }
                    }
                }
            }
        },

        _findAngle: function (startPt, endPt) {
            var xDiff = startPt.x - endPt.x; var yDiff = startPt.y - endPt.y;
            return Math.atan2(yDiff, xDiff) * (180 / Math.PI);
        },

        _adjustPoint: function (source, target, isStart, length) {
            var pt = isStart ? { x: source.x, y: source.y } : { x: target.x, y: target.y };

            if (source.x == target.x) {
                if (source.y < target.y && isStart || source.y > target.y && !isStart)
                    pt.y += length;
                else pt.y -= length;
            }
            else if (source.y == target.y) {
                if (source.x < target.x && isStart || source.x > target.x && !isStart)
                    pt.x += length;
                else pt.x -= length;
            }
            else {
                var angle;
                if (isStart) {
                    angle = ej.datavisualization.Diagram.Geometry.findAngle(source, target);
                    pt = ej.datavisualization.Diagram.Geometry.transform(source, angle, length);
                }
                else {
                    angle = ej.datavisualization.Diagram.Geometry.findAngle(target, source);
                    pt = ej.datavisualization.Diagram.Geometry.transform(target, angle, length);
                }
            }
            return pt;
        },
        renderLabels: function (node, canvas) {
            for (var i = 0; i < node.labels.length; i++) {
                var label = node.labels[i];
                var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                var position = ej.datavisualization.Diagram.Util._getLabelPosition(label, bounds);
                var ctx = canvas.document.getContext("2d");
                ctx.lineWidth = label.borderWidth;
                ctx.strokeStyle = label.borderColor;
                this._renderTextElement(node, label, canvas);
            }
        },

        renderPorts: function (node, canvas, x, y) {
            var ctx = canvas.document.getContext("2d");
            for (var i = 0; i < node.ports.length; i++) {
                var port = node.ports[i];
                if (!(port.visibility & ej.datavisualization.Diagram.PortVisibility.Hidden || port.visibility & ej.datavisualization.Diagram.PortVisibility.Hover || port.visibility & ej.datavisualization.Diagram.PortVisibility.Connect)) {
                    var point = ej.datavisualization.Diagram.Util._getPortPosition(port, node.bounds());
                    ctx.fillStyle = port.fillColor;
                    ctx.strokeStyle = port.borderColor;
                    ctx.lineWidth = port.borderWidth;
                    switch (port.shape) {
                        case "x":
                            var size = new ej.datavisualization.Diagram.Size(port.size, port.size);
                            ctx.beginPath();
                            ctx.moveTo((point.x - size / 2), (point.y - size / 2));
                            ctx.lineTo((point.x + size / 2), (point.y + size / 2));
                            ctx.moveTo((point.x + size / 2), (point.y - size / 2));
                            ctx.lineTo((point.x - size / 2), (point.y + size / 2));
                            ctx.stroke();
                            ctx.fill();
                            ctx.closePath();
                            break;
                        case "circle":
                            var rx = size.width / 2;
                            var ry = size.height / 2;
                            canvas.ellipse(x + point.x, y + point.y, rx, ry);
                            break;
                        case "square":
                            canvas.rect(point.x - port.size / 2, point.y - port.size / 2, port.size, port.size);
                            break;
                    }
                }
            }
        },

        _renderTextElement: function (node, textElement, canvas) {
            if (textElement) {
                var text = { childNodes: [] };
                this._wrapText(node, text, textElement, canvas);
                this._alignTextOnLabel(textElement, node, text, canvas);
            }
        },

        _alignTextOnLabel: function (label, node, text, canvas) {
            var bounds = { "width": label.width, "height": text.childNodes.length * label.fontSize };
            var nodeBounds = ej.datavisualization.Diagram.Util.bounds(node);
            var offset = ej.datavisualization.Diagram.Util._getLabelPosition(label, nodeBounds);
            var point = { x: 0, y: 0 };
            var y = 0;

            if (label.verticalAlignment == ej.datavisualization.Diagram.VerticalAlignment.Top)
                y = offset.y;
            else if (label.verticalAlignment == ej.datavisualization.Diagram.VerticalAlignment.Center)
                y = offset.y - bounds.height / 2;
            else
                y = offset.y - bounds.height;
            point.y = y;

            switch (label.horizontalAlignment) {
                case ej.datavisualization.Diagram.HorizontalAlignment.Left:
                    switch (label.textAlign) {
                        case ej.datavisualization.Diagram.TextAlign.Left:
                            point.x = offset.x;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Center:
                            point.x = offset.x + bounds.width / 2;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Right:
                            point.x = offset.x + bounds.width;
                            break;
                    }
                    break;
                case ej.datavisualization.Diagram.HorizontalAlignment.Center:
                    switch (label.textAlign) {
                        case ej.datavisualization.Diagram.TextAlign.Left:
                            point.x = offset.x - bounds.width / 2;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Center:
                            point.x = offset.x;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Right:
                            point.x = offset.x + bounds.width / 2;
                            break;
                    }
                    break;
                case ej.datavisualization.Diagram.HorizontalAlignment.Right:
                    switch (label.textAlign) {
                        case ej.datavisualization.Diagram.TextAlign.Left:
                            point.x = offset.x - bounds.width;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Center:
                            point.x = offset.x - bounds.width / 2;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Right:
                            point.x = offset.x;
                            break;
                    }
                    break;
            }
            var ctx = canvas.document.getContext("2d");
            var font = "";
            if (label.italic)
                font += "italic ";
            if (label.bold)
                font += "bold ";
            font += label.fontSize + "px ";
            font += label.fontFamily;
            for (var i = 0; i < text.childNodes.length; i++) {
                var child = text.childNodes[i];
                var text_x = nodeBounds.x + point.x + child.x;
                var text_y = nodeBounds.y + point.y + 3 * label.fontSize / 4 + child.dy * i;
                var width = ctx.measureText(child.text).width;
                canvas.rect(text_x, text_y - 3 * label.fontSize / 4, width, label.fontSize, null, { fill: label.fillColor });
                ctx.textAlign = label.textAlign;
                canvas.text({ text: child.text }, text_x - child.x, text_y, null, { fill: label.fontColor, font: font });
            }
        },

        _wrapText: function (node, text, label, canvas) {
            var str = label.text; var attr = null;
            var textBBox = ej.datavisualization.Diagram.Util.bounds(node);
            var bbWidth, bbHeight;
            if (node.line) {
                bbWidth = textBBox.width;
                bbHeight = textBBox.height;
            }
            else {
                bbWidth = textBBox.width - label.margin.left - label.margin.right;
                bbHeight = textBBox.height - label.margin.top - label.margin.bottom;
            }
            bbWidth = bbWidth < label.width ? label.width : bbWidth;
            var eachLine = str.split('\n');
            var x, y, tspan, j, string = "", posX, posY, childNodes, bounds, i;
            var ctx = canvas.document.getContext("2d");
            for (j = 0; j < eachLine.length; j++) {
                var txt = "";
                for (i = 0; i < eachLine[j].length; i++) {
                    bounds = ctx.measureText(txt).width;
                    if (label.wrapText) {
                        if (bounds >= (bbWidth - label.fontSize)) {
                            txt += eachLine[j][i];
                            posX = -bounds;
                            if (!(i == eachLine[j].length - 1)) {
                                text.childNodes[text.childNodes.length] = { text: txt };
                                txt = "";
                            }
                        }
                        else {
                            txt += eachLine[j][i];
                            if (i == eachLine[j].length - 1) {
                                text.childNodes[text.childNodes.length] = { text: txt };
                                txt = "";
                            }
                        }
                    }
                    else {
                        txt += eachLine[j][i];
                    }
                }
            }
            this._wrapTextAlign(text, text.childNodes, label.fontSize, label.textAlign, ctx);
        },

        _wrapTextAlign: function (text, childNodes, height, textAlign, ctx) {
            for (var i = 0; i < childNodes.length; i++) {
                var x = ctx.measureText(childNodes[i].text).width;
                switch (textAlign) {
                    case "left":
                        x = 0;
                        break;
                    case "center":
                        x = -x / 2;
                        break;
                    case "right":
                        x = -x;
                        break;
                }
                childNodes[i].x = Number(x);
                childNodes[i].dy = height;
            }
        },

        _renderGradient: function (node, ctx, x, y) {
            if (node.gradient) {
                var max, min;
                for (var i = 0; i < node.gradient.stops.length; i++) {
                    max = !max ? node.gradient.stops[i].offset : Math.max(max, node.gradient.stops[i].offset);
                    min = !min ? node.gradient.stops[i].offset : Math.min(min, node.gradient.stops[i].offset);
                }
                if (node.gradient.type == "linear") {
                    var grd = ctx.createLinearGradient(x + node.gradient.x1, y + node.gradient.y1, x + node.gradient.x2, y + node.gradient.y2);
                    for (var i = 0; i < node.gradient.stops.length; i++) {
                        var stop = node.gradient.stops[i];
                        var offset = min < 0 ? (max + stop.offset) / (2 * max) : stop.offset / max;
                        grd.addColorStop(offset, stop.color);
                    }
                }
                else if (node.gradient.type == "radial") {
                    var grd = ctx.createRadialGradient(x + node.gradient.cx, y + node.gradient.cy, 0, x + node.gradient.fx, y + node.gradient.fy, node.gradient.r);
                    for (var i = 0; i < node.gradient.stops.length; i++) {
                        var stop = node.gradient.stops[i];
                        var offset = min < 0 ? (max + stop.offset) / (2 * max) : stop.offset / max;
                        grd.addColorStop(offset, stop.color);
                    }
                }
                ctx.fillStyle = grd;
            }
        },

        _renderDecorators: function (connector, canvas) {
            var startPoint;
            var endPoint;
            if (connector.targetDecorator && connector.targetDecorator.shape) {
                var segment = connector.segments[connector.segments.length - 1];
                startPoint = segment.points[segment.points.length - 2];
                endPoint = connector.targetPoint;
                if (segment.type == "bezier") {
                    startPoint = segment._point2;
                }
                this._renderDecorator(connector.name + "_targetDecorator", endPoint,
                    startPoint, connector.targetDecorator, canvas);
            }
            if (connector.sourceDecorator && connector.sourceDecorator.shape) {
                var segment = connector.segments[0];
                startPoint = connector.sourcePoint;
                endPoint = segment.points[1];
                if (segment.type == "bezier") {
                    endPoint = segment._point1;
                }
                this._renderDecorator(connector.name + "_sourceDecorator", startPoint,
                    endPoint, connector.sourceDecorator, canvas);
            }
        },

        _renderDecorator: function (name, point1, point2, decorator, canvas) {
            var shape;
            var attr;
            var d;
            var size = new ej.datavisualization.Diagram.Size(decorator.width, decorator.height);
            var ctx = canvas.document.getContext("2d");
            ctx.fillStyle = decorator.fillColor;
            ctx.strokeStyle = decorator.borderColor;
            var angle = ej.datavisualization.Diagram.Geometry.findAngle(point1, point2);
            var rotation = { angle: angle, x: point1.x, y: point1.y };
            switch (decorator.shape) {
                case "arrow":
                    canvas.arrow(point1, rotation, size);
                    break;
                case "openarrow":
                    canvas.arrow(point1, rotation, size, true);
                    break;
                case "circle":
                    var rx = size.width / 2;
                    var ry = size.height / 2;
                    canvas.ellipse(point1.x + size.width / 2, point1.y, rx, ry, rotation);
                    break;
                case "diamond":
                    canvas.diamond(point1, rotation, size);
                    break;
                case "path":
                    canvas.path(decorator.pathData, point1.x, point1.y, size.width, size.height, rotation);
                    break;
            }
            //apply translate matrix and rotate matrix here
            //shape.setAttribute("transform", "rotate(" + ej.datavisualization.Diagram.Geometry.findAngle(point1, point2) + " " + point1.x + " " + point1.y + ")");
            return shape;
        },

        _updatePolygonPoints: function (node) {
            if (node.shape.points) {
                var points = node.shape.points;
                if (points.length) {
                    this._scalePoints(points, node);
                    var bounds = ej.datavisualization.Diagram.Geometry.rect(points);
                    var x = node.offsetX - node.width / 2 - bounds.x;
                    var y = node.offsetY - node.height / 2 - bounds.y;
                    for (var i = 0, len = points.length; i < len; ++i) {
                        var point = ej.datavisualization.Diagram.Geometry.translate(points[i], x, y);
                        points[i] = point;
                    }
                }
            }
        },

        _scalePoints: function (points, node) {
            var bounds = ej.datavisualization.Diagram.Geometry.rect(points);
            if (bounds.width > 0 && bounds.height > 0) {
                var scaleX = node.width / bounds.width;
                var scaleY = node.height / bounds.height;
                for (var i = 0, len = points.length; i < len; ++i) {
                    points[i].x = points[i].x * scaleX;
                    points[i].y = points[i].y * scaleY;
                }
            }
        },

        updateNode: function (model, canvas) {
            this.refreshCanvas(model, canvas);
        },

        updateConnector: function (model, canvas) { this.refreshCanvas(model, canvas); },

        updateGroup: function (model, canvas) { this.refreshCanvas(model, canvas); },

        refreshCanvas: function (model, canvas) {

            var ctx = canvas.document.getContext("2d");
            ctx.save();
            if (view.scale) {
                ctx.scale(1 / view.scale.x, 1 / view.scale.y);
            }
            var bounds = { x: canvas.document.offsetLeft, y: canvas.document.offsetTop, width: canvas.document.offsetWidth, height: canvas.document.offsetHeight };
            ctx.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);
            if (view.scale) {
                ctx.scale(view.scale.x, view.scale.y);
            }
            ctx.restore();
            for (var i = 0; i < model.nodes.length; i++) {
                if (model.nodes[i].shape)
                    this.renderNode(model.nodes[i], canvas);
                else if (model.nodes[i].type == "group")
                    this.renderGroup(model.nodes[i], canvas);
            }
            for (var i = 0; i < model.connectors.length; i++) {
                this.renderConnector(model.connectors[i], canvas);
            }
        },

        updateViewport: function (diagram) {
            //diagram._scroller._updateViewPort();
            //diagram.model.pageSettings._updatePageSize(diagram, true);
        },

        addNodeLabel: function (model, canvas) { this.refreshCanvas(model, canvas); },

        updateLabel: function (model, canvas) { this.refreshCanvas(model, canvas); },

        setNodeShape: function (model, canvas) { this.refreshCanvas(model, canvas); },

        setLine: function (model, canvas) { this.refreshCanvas(model, canvas); },

        renderDecorators: function (model, canvas) { this.refreshCanvas(model, canvas); },

        clearDecorators: function (model, canvas) { this.refreshCanvas(model, canvas); },

        updateTargetDecoratorStyle: function (model, canvas) { this.refreshCanvas(model, canvas); },

        updateSourceDecoratorStyle: function (model, canvas) { this.refreshCanvas(model, canvas); },

        _updateNodeStyle: function (model, canvas) { this.refreshCanvas(model, canvas); },

        updateLabelStyle: function (model, canvas) { this.refreshCanvas(model, canvas); },

        updateConnectorStyle: function (model, canvas) { this.refreshCanvas(model, canvas); },

        updateTextBlock: function (model, label, canvas) { this.refreshCanvas(model, canvas); },

        removeChild: function (element, view, diagram) {
        }
    };
    //#endregion

})(jQuery, Syncfusion);;
});